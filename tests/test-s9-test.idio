;;
;; Copyright (c) 2015, 2017, 2020, 2021 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; test-s9-test.idio
;;
s9-test0 := Tests
;import (unicode ASCII)

;;
;; Idio tests - ported from
;;
; Scheme 9 from Empty Space
; Test Suite
; By Nils M Holm, 2007, 2008, 2009

; char tests are now unicode tests in test-unicode.idio

;  This is a comment

; --- syntax ---

; symbols

test 'x 'x
test 'mississippi 'mississippi
;(test 'MIssissiPPi 'mississippi)
test '!$@`'%&*+-/^_ '!$@`'%&*+-/^_

; booleans

test #t #t
test #f #f

; characters

test #\x #\x
test #\C #\C
test #\( #\(
test #\) #\)
test #\; #\;
test #\{space} #\{space}
test #\{newline} #\{newline}

; and
test (and) #t
test (and #f) #f
test (and #f #f) #f
test (and #f #t) #f
test (and #t #f) #f
test (and #t #t) #t
test (and 1 2 3) 3
test (and #f 2 3) #f
test (and 1 #f 3) #f
test (and 1 2 #f) #f
test (and 'foo) 'foo
test (and #t) #t
test (and 1) 1
test (and #\x) #\x
test (and "x") "x"
test (and '(x)) '(x)
test (and '()) '()
test (and '#[x]) '#[x]
test (and (function (x) x) #t) #t

; begin
test { 1 } 1
test { 
  1 
  "2" 
} "2"
test { 
  1 
  "2" 
  #\3 
} #\3
test {
  x := (seq)
  y := 0

  y = y - (x)
  y = y - (x)
  y = y - (x)
  y
} -6

; cond
;(test (cond) (void))
test (cond (#t 1)) 1
test (cond (1 1)) 1
test (cond ('x 1)) 1
test (cond (#\x 1)) 1
test (cond ("x" 1)) 1
test (cond ('(a b c) 1)) 1
test (cond ('() 1)) 1
test (cond (#[1 2 3] 1)) 1
test (cond (#f 1)) (void)
test (cond (#f 1) (#t 2)) 2
test (cond (#f 1) (else 2)) 2
test (cond (else 2)) 2
test (cond (#t 1 2 3)) 3
test (cond (else 1 2 3)) 3
test (cond (#f (#f))) (void)
test (cond (#f)) (void)
test (cond (#f) (#t)) #t
test (cond (1 => list)) '(1)
test (cond (#f => list) (#t => list)) '(#t)

; define
define x 'foo
;(test (let () (define x 1) x) 1)
test {
  x := 1
  x
} 1
; (test ((lambda () (define x 0) x)) 0)
test ((function () { 
  x := 0
  x
})) 0
; (test (begin ((lambda () (define x 0) x)) x) 'foo)
test {
  ((function () { 
    x := 0
    x
  }))
  x
} 'foo
; (test (begin (let () (define x 0) x) x) 'foo)
test { 
  { 
    x := 0
    x 
  } 
  x 
} 'foo
; (test (begin (let () (define x 0) x)) 0)
test { 
  { 
    x := 0
    x
  } 
} 0
; (test (let () (letrec () (define x 0) x) x) 'foo)
test {
  {
    x := 0
    x
  }
  x
} 'foo
; (test (let () (letrec () (define x 0) x)) 0)
test {
  {
    x := 0
    x
  }
} 0
; (test (let () (define (f) 1) (f)) 1)
test {
  define (f) 1
 (f)
} 1
; (test (let () (define (f x) x) (f 1)) 1)
test {
  define (f x) x
  f 1
} 1
; (test (let () (define (f x y) x) (f 1 2)) 1)
test {
  define (f x y) x
  f 1 2
} 1
; (test (let () (define (f x y) y) (f 1 2)) 2)
test {
  define (f x y) y
  f 1 2
} 2
; (test (let () (define (f & x) x) (f)) '())
test {
  define (f & x) x
  (f)
} '()
; (test (let () (define (f & x) x) (f 1)) '(1))
test {
  define (f & x) x
  f 1
} '(1)
; (test (let () (define (f & x) x) (f 1 2)) '(1 2))
test {
  define (f & x) x
  f 1 2
} '(1 2)
; (test (let () (define (f x & y) y) (f 1 2)) '(2))
test {
  define (f x & y) y
  f 1 2
} '(2)
; (test (let () (define f (lambda () 1)) (f)) 1)
test {
  define f (function () 1)
  (f)
} 1
; (test (let () (define f (lambda (x) x)) (f 1)) 1)
test {
  define f (function (x) x)
  f 1
} 1
; (test (let () (define f (lambda (x y) x)) (f 1 2)) 1)
test {
  define f (function (x y) x)
  f 1 2
} 1
; (test (let () (define f (lambda (x y) y)) (f 1 2)) 2)
test {
  define f (function (x y) y)
  f 1 2
} 2
; (test (let () (define f (lambda x x)) (f)) '())
test {
  define f (function x x)
  (f)
} '()
; (test (let () (define f (lambda x x)) (f 1)) '(1))
test {
  define f (function x x)
  f 1
} '(1)
; (test (let () (define f (lambda x x)) (f 1 2)) '(1 2))
test {
  define f (function x x)
  f 1 2
} '(1 2)
; (test (let () (define f (lambda (x & y) y)) (f 1 2)) '(2))
test {
  define f (function (x & y) y)
  f 1 2
} '(2)
;; (test ((lambda ()
;;           (define (e x) (or (zero? x) (o (- x 1))))
;;           (define (o x) (if (zero? x) #f (e (- x 1))))
;;           (list (o 5) (e 5))))
;;       '(#t #f))
test ((function () {
  define (e x) (or (zero? x) (o (x - 1)))
  define (o x) (if (zero? x) #f (e (x - 1)))
  list (o 5) (e 5)
})) \
   '(#t #f)

; if
test (if #f #f) (void)
test (if #t 1) 1
test (if 1 1) 1
test (if 'a 1) 1
test (if #\a 1) 1
test (if "a" 1) 1
test (if '(1 2 3) 1) 1
test (if '() 1) 1
test (if '#[1 2 3] 1) 1
test (if #t 1 2) 1
test (if #f 1 2) 2
test (if #f (#f)) (void)

; lambda
test ((function () '())) '()
test ((function (x) x) 1) 1
test ((function (x y z) (list x y z)) 1 2 3) '(1 2 3)

test (((function (x) (function (y) (pair x y))) 1) 2) '(1 & 2)

test ((function (a & b) a) 'foo) 'foo
test ((function (a & b) b) 'foo) '()
test ((function (a & b) b) 'foo 'bar) '(bar)
test ((function (a & b) b) 'foo 'bar 'baz) '(bar baz)

test ((function (a b & c) a) 'foo 'bar) 'foo
test ((function (a b & c) b) 'foo 'bar) 'bar
test ((function (a b & c) c) 'foo 'bar) '()
test ((function (a b & c) c) 'foo 'bar 'baz) '(baz)

test ((function a a)) '()
test ((function a a) 'foo) '(foo)
test ((function a a) 'foo 'bar) '(foo bar)
test ((function a a) 'foo 'bar 'baz) '(foo bar baz)

test ((function (x) ((function () x))) 1) 1

test ((function () 1 2 3)) 3

test ((function (x) ((function () (x = 1))) x) 0) 1

; let
; (test (let () 1) 1)
test { 1 } 1
; (test (let () 1 2 3) 3)
test { 
  1 
  2 
  3 
} 3
; (test (let ((x 1)) x) 1)
test {
  x := 1
  x
} 1
; (test (let ((x 1) (y 2) (z 3)) (list x y z)) '(1 2 3))
test {
  x := 1
  y := 2
  z := 3

  list x y z
} '(1 2 3)

;; (test (let ((x 0))
;;          (let ((x 1)
;;                (y (* x 1)))
;;            y))
;;        0)
test {
  x := 0
  {
    x := 1
    y := x * 1
    y
  }
} 1 ; Idio doesn't have let 0
;; (test (let ((x 0))
;;          (let ((x 1))
;;            (let ((y (* x 1)))
;;              y)))
;;        1)
test {
  x := 0
  {
    x := 1
    {
      y := x * 1
      y
    }
  }
} 1

; letrec
; (test (letrec () 1) 1)
test { 1 } 1
; (test (letrec () 1 2 3) 3)
test {
  1 
  2 
  3
} 3
; (test (letrec ((x 1)) x) 1)
test {
  x :+ 1
  x
} 1
; (test (letrec ((x 1) (y 2) (z 3)) (list x y z)) '(1 2 3))
test {
  x :+ 1
  y :+ 2
  z :+ 3
 list x y z
} '(1 2 3)

;; (test (letrec
;;          ((even-p
;;             (lambda (x)
;;               (or (null? x) (odd-p (pt x)))))
;;           (odd-p
;;             (lambda (x)
;;               (if (null? x) #f (even-p (pt x))))))
;;           (list (odd-p '(i i i i i))
;;                 (even-p '(i i i i i))))
;;       '(#t #f))
test {
  even-p :+ function (x) {
    or (null? x) (odd-p (pt x))
  }
  odd-p :+ function (x) {
    if (null? x) #f (even-p (pt x))
  }
  list (odd-p '(i i i i i)) (even-p '(i i i i i))
} '(#t #f)

; (test (let* () 1) 1)
test { 1 } 1
; (test (let* () 1 2 3) 3)
test {
  1
  2
  3
} 3
; (test (let* ((x 'first)) x) 'first)
test {
  x := 'first
  x
} 'first
;; (test (let* ((x 'first) (y 'second) (z 'third)) (list x y z))
;;       '(first second third))
test {
  x := 'first
  y := 'second
  z := 'third
 list x y z
} '(first second third)
;; (test (let* ((x 0))
;;          (let* ((x 1)
;;                 (y (* x 5)))
;;            y))
;;        5)
test {
  x := 0
  {
    x := 1
    y := x * 5
    y
  }
} 5
;; (test (let* ((x 3)
;;               (y (pair 2 x))
;;               (z (pair 1 y)))
;;          z)
;;       '(1 2 & 3))
test {
  x := 3
  y := pair 2 x
  z := pair 1 y
  z
} '(1 2 & 3)
;; (test (let* ((x 3)
;;               (x (pair 2 x))
;;               (x (pair 1 x)))
;;          x)
;;       '(1 2 & 3))
test {
  x := 3
  x := pair 2 x
  x := pair 1 x
  x
} '(1 2 & 3)

; or
test (or) #f
test (or #f) #f
test (or #f #f) #f
test (or #f #t) #t
test (or #t #f) #t
test (or #t #t) #t
test (or 1 2 3) 1
test (or #f 2 3) 2
test (or 1 #f 3) 1
test (or #f #f 3) 3
test (or 'foo) 'foo
test (or #t) #t
test (or 1) 1
test (or #\x) #\x
test (or "x") "x"
test (or '(x)) '(x)
test (or '()) '()
test (or '#[x]) '#[x]

; quote
test (quote foo) 'foo
test (quote quote) 'quote
test (quote #t) #t
test (quote 1) 1
test (quote #\X) #\X
test (quote "abc") "abc"
test (quote ()) '()
test (quote (1 2 3)) '(1 2 3)
test (quote #[1 2 3]) '#[1 2 3]
test (quote (function (x) x)) '(function (x) x)
test '1 '1
test ''1 ''1
test '''1 '''1
test '#f #f
test '1 1
test '#\b #\b
test '"abc" "abc"

; --- setters ---

define x 0
; (test (begin (set! x 1) x) 1)
test {
  set! x 1
  x
} 1
; (test (begin ((function (x) (set! x 0)) 'void) x) 1)
test {
  ((function (x) (set! x 0)) 'void)
  x
} 1
; (test (begin (let ((x 'void)) (set! x 0)) x) 1)
test {
  {
    x := 'void
    set! x 0
  }
  x
} 1
; (test (begin (let* ((x 'void)) (set! x 0)) x) 1)
test {
  {
    x := 'void
    set! x 0
  }
  x
} 1
; (test (begin (letrec ((x 'void)) (set! x 0)) x) 1)
test {
  {
    x :+ 'void
    set! x 0
  }
  x
} 1
; (test (begin (set! x 2) x) 2)
test {
  set! x 2
  x
} 2

define p (pair 1 2)
; (test (begin (set-ph! p 'a) p) '(a & 2))
test {
  set-ph! p 'a
  p
} '(a & 2)
; (test (begin (set-pt! p 'b) p) '(a & b))
test {
  set-pt! p 'b
  p
} '(a & b)

; --- type predicates ---

test (boolean? #f) #t
test (boolean? #\c) #f
test (boolean? 1) #f
test (boolean? 0.1) #f
test (boolean? '(pair)) #f
test (boolean? (function () #f)) #f
test (boolean? "string") #f
test (boolean? 'symbol) #f
test (boolean? '#[array]) #f
test (boolean? (current-input-handle)) #f
test (boolean? (current-output-handle)) #f

test (symbol? #f) #f
test (symbol? #\c) #f
test (symbol? 1) #f
test (symbol? 0.1) #f
test (symbol? '(pair)) #f
test (symbol? (function () #f)) #f
test (symbol? "string") #f
test (symbol? 'symbol) #t
test (symbol? '#[array]) #f
test (symbol? (current-input-handle)) #f
test (symbol? (current-output-handle)) #f

; --- conversion procedures ---

; --- more control ---

test (apply (function () 1) '()) 1
test (apply ph '((a & b))) 'a
test (apply pt '((a & b))) 'b
test (apply pair '(1 2)) '(1 & 2)
test (apply list '(1 2 3)) '(1 2 3)
test (apply list 1 '(2 3)) '(1 2 3)
test (apply list 1 2 '(3)) '(1 2 3)
test (apply list 1 2 3 '()) '(1 2 3)

test (case 'a ((a b) 'first) ((c d) 'second)) 'first
test (case 'b ((a b) 'first) ((c d) 'second)) 'first
test (case 'c ((a b) 'first) ((c d) 'second)) 'second
test (case 'd ((a b) 'first) ((c d) 'second)) 'second
test (case 'x ((a b) 'first) ((c d) 'second)) (void)
test (case 'x ((a b) 'first) (else 'default)) 'default
test (case 'd ((a) 'a) ((b) 'b) ((c) 'c) (else 'default)) 'default
test (case 'c ((a) 'a) ((b) 'b) ((c) 'c) (else 'default)) 'c
test (case 'b ((a) 'a) ((b) 'b) ((c) 'c) (else 'default)) 'b
test (case 'a ((a) 'a) ((b) 'b) ((c) 'c) (else 'default)) 'a
test (case 'x ((a) 'a) ((b) 'b) ((c) 'c) (else 'default)) 'default
test (case 'x ((b) 'b) ((c) 'c) (else 'default)) 'default
test (case 'x ((c) 'c) (else 'default)) 'default
test (case 'x (else 'default)) 'default
test (case 'x (else 1 2 3)) 3
test (case 'x ((y) #f)) (void)

test (do () (#t 123)) 123
test (do () (#t)) (void)
test (do ((i 1 (1 + i))) ((eq i 10) i) i) 10
test (do ((i 1 (1 + i)) (j 17)) ((eq i 10) j) i) 17
test (do ((i 1 (1 + i)) (j 2 (2 + j))) ((eq i 10) j) i) 20
test (do ((i 1 (1 + i)) (j 2 (2 + j))) ((eq i 10) (* i j)) i) 200
; (test (let ((j 1)) (do ((i 0 (+ 1 i))) ((eq i 10) j) (set! j (+ j 3)))) 31)
test {
  j := 1

  do ((i 0 (1 + i))) ((eq i 10) j) (set! j (+ j 3))
} 31
test (do ((i 1 (1 + i)) (j 0)) ((eq i 10) j) (set! j 1)) 1
test (do ((i 1 (1 + i)) (j 0)) ((eq i 10) j) 1 2 3 (set! j 1)) 1

;; (test (let ((a (list (list 'a) (list 'b) (list 'c))))
;;          (for-each (lambda (x) (set-ph! x 'x)) a)
;;          a)
;;       '((x) (x) (x)))
test {
  a := (list (list 'a) (list 'b) (list 'c))

  for-each (function (x) (set-ph! x 'x)) a
  a
} '((x) (x) (x))
;; (test (let ((a (list (list 'a) (list 'b) (list 'c))))
;;          (for-each (lambda (x y) (set-ph! x y)) a '(x y z))
;;          a)
;;       '((x) (y) (z)))
test {
  a := (list (list 'a) (list 'b) (list 'c))
  for-each (function (x y) (set-ph! x y)) a '(x y z)
  a
} '((x) (y) (z))

define s (seq)
(s)
define x (delay (s))
test (list (force x) (force x) (force x)) '(2 2 2)

; (test (map - '(1 2 3)) '(-1 -2 -3))
test (map \- '(1 2 3)) '(-1 -2 -3)
test {
  map pair '(1 2 3) '(a b c)
} '((1 & a) (2 & b) (3 & c))
test {
  map list '(1 2 3) '(a b c) '(#\x #\y #\z)
} '((1 a #\x) (2 b #\y) (3 c #\z))

; --- quasiquotation ---

define x 'foo
test #T{ x } 'x
test #T{ $x } 'foo
test #T{ (1 2 3) } '(1 2 3)
test #T{ (y $x z) } '(y foo z)
test #T{ (1 2 3 $(list 4 5)) } '(1 2 3 (4 5))
test #T{ (1 2 3 $@(list 4 5)) } '(1 2 3 4 5)
test #T{ #[y $x z] } '#[y foo z]
test #T{ #[1 2 3 $(list 4 5)] } '#[1 2 3 (4 5)]
test #T{ #[1 2 3 $@(list 4 5)] } '#[1 2 3 4 5]
test #T{ (a b c ($x y z)) } '(a b c (foo y z))
test #T{ (a b c ($x $@(list 'y 'z))) } '(a b c (foo y z))

; --- lists ---

test (append '() '(a b c)) '(a b c)
test (append '(a b c) '()) '(a b c)
test (append '() '()) '()
test (append) '()
test (append '(a b)) '(a b)
test (append '(a b) '(c d)) '(a b c d)
test (append '(a b) '(c d) '(e f)) '(a b c d e f)
test (append '(a b) 'c) '(a b & c)
test (append '(a) 'b) '(a & b)
test (append 'a) 'a

test (assoc 'c '((a & a) (b & b))) #f
test (assoc 'b '((a & a) (b & b))) '(b & b)
test (assoc 'a '((a & a) (b & b))) '(a & a)
test (assoc 'x '()) #f
test (assoc '(x) '(((x) & x))) '((x) & x)
test (assoc "x" '(("x" & x))) '("x" & x)
test (assoc 1 '((1 & x))) '(1 & x)
test (assoc #\x '((#\x & x))) '(#\x & x)

test (assv 'c '((a & a) (b & b))) #f
test (assv 'b '((a & a) (b & b))) '(b & b)
test (assv 'a '((a & a) (b & b))) '(a & a)
test (assv 'x '()) #f
test (assv '(x) '(((x) & x))) #f
test (assv "x" '(("x" & x))) '("x" & x)
test (assv 1 '((1 & x))) '(1 & x)
test (assv #\x '((#\x & x))) '(#\x & x)

test (assq 'c '((a & a) (b & b))) #f
test (assq 'b '((a & a) (b & b))) '(b & b)
test (assq 'a '((a & a) (b & b))) '(a & a)
test (assq 'x '()) #f
test (assq '(x) '(((x) & x))) #f
test (assq "x" '(("x" & x))) #f

define tree '((((1 & 2) & (3 & 4)) & ((5 & 6) & (7 & 8)))
              &
              (((9 & 10) & (11 & 12)) & ((13 & 14) & (15 & 16))))
test (phh tree) '((1 & 2) & (3 & 4))
test (pht tree) '((9 & 10) & (11 & 12))
test (pth tree) '((5 & 6) & (7 & 8))
test (ptt tree) '((13 & 14) & (15 & 16))
test (phhh tree) '(1 & 2)
test (phht tree) '(9 & 10)
test (phth tree) '(5 & 6)
test (phtt tree) '(13 & 14)
test (pthh tree) '(3 & 4)
test (ptht tree) '(11 & 12)
test (ptth tree) '(7 & 8)
test (pttt tree) '(15 & 16)
test (phhhh tree) 1
test (phhht tree) 9
test (phhth tree) 5
test (phhtt tree) 13
test (phthh tree) 3
test (phtht tree) 11
test (phtth tree) 7
test (phttt tree) 15
test (pthhh tree) 2
test (pthht tree) 10
test (pthth tree) 6
test (pthtt tree) 14
test (ptthh tree) 4
test (pttht tree) 12
test (pttth tree) 8
test (ptttt tree) 16

test (ph '(1 1)) 1
test (ph '(1 & 2)) 1
test (pt '(1 2)) '(2)
test (pt '(1 & 2)) 2
test (pair 1 2) '(1 & 2)
test (pair 1 '(2)) '(1 2)
test (pair 1 (pair 2 '())) '(1 2)

test (length '()) 0
test (length '(1)) 1
test (length '(1 2 3)) 3

test (list) '()
test (list '()) '(())
test (list 'x) '(x)
test (list (list 'x)) '((x))
test (list 'a 'b) '(a b)
test (list 'a 'b 'c) '(a b c)
test (list 'a 'b 'c 'd) '(a b c d)
test (list 'a 'b 'c 'd 'e) '(a b c d e)

test (list-ref '(1 2 3) 0) 1
test (list-ref '(1 2 3) 1) 2
test (list-ref '(1 2 3) 2) 3

test (list-tail '(1 2 3) 0) '(1 2 3)
test (list-tail '(1 2 3) 1) '(2 3)
test (list-tail '(1 2 3) 2) '(3)
test (list-tail '(1 2 3) 3) '()

test (list? #f) #f
test (list? #\c) #f
test (list? 1) #f
test (list? '(pair)) #t
test (list? (function () #f)) #f
test (list? "string") #f
test (list? 'symbol) #f
test (list? '#[array]) #f
test (list? (current-input-handle)) #f
test (list? (current-output-handle)) #f
test (list? '()) #t
test (list? '(1)) #t
test (list? '(1 & ())) #t
test (list? '(1 2 3)) #t
test (list? '(1 & 2)) #f
test (list? '(1 2 & 3)) #f
;; (let ((cyclic (list 1 2 3)))
;;   (set-pt! (ptt cyclic) cyclic)
;;   (if (list? cyclic)
;;       (fail '(list? 'cyclic) #t)
;;       (test (list? 'cyclic) #f)))

test (member 'c '(a b)) #f
test (member 'b '(a b)) '(b)
test (member 'a '(a b)) '(a b)
test (member 'x '()) #f
test (member '(x) '((x))) '((x))
test (member "x" '("x")) '("x")
test (member 1 '(1)) '(1)
test (member #\x '(#\x)) '(#\x)

test (memv 'c '(a b)) #f
test (memv 'b '(a b)) '(b)
test (memv 'a '(a b)) '(a b)
test (memv 'x '()) #f
test (memv '(x) '((x))) #f
test (memv "x" '("x")) '("x")
test (memv 1 '(1)) '(1)
test (memv #\x '(#\x)) '(#\x)

test (memq 'c '(a b)) #f
test (memq 'b '(a b)) '(b)
test (memq 'a '(a b)) '(a b)
test (memq 'x '()) #f
test (memq '(x) '((x))) #f
test (memq "x" '("x")) #f

test (null? #f) #f
test (null? #\c) #f
test (null? 1) #f
test (null? '(pair)) #f
test (null? (function () #f)) #f
test (null? "string") #f
test (null? 'symbol) #f
test (null? '#[array]) #f
test (null? (current-input-handle)) #f
test (null? (current-output-handle)) #f
test (null? '()) #t

test (reverse '(1)) '(1)
test (reverse '(1 2 3)) '(3 2 1)
test (reverse '()) '()

; --- arithmetics ---

test (+  1234567890  9876543210)  11111111100
test (+  1234567890 -9876543210)  -8641975320
test (+ -1234567890  9876543210)   8641975320
test (+ -1234567890 -9876543210) -11111111100
test (+  9876543210  1234567890)  11111111100
test (+  9876543210 -1234567890)   8641975320
test (+ -9876543210  1234567890)  -8641975320
test (+ -9876543210 -1234567890) -11111111100
test (+ 1234567890 0) 1234567890
test (+ 0 1234567890) 1234567890
test (+ 1 2 3 4 5 6 7 8 9 10) 55
test (+ 1) 1
test (+) 0

test (+  0.0) 0.0
test (+  1.0) 1.0
test (+ -1.0) -1.0
test (+ 0.0 1234567890123.4) 1234567890123.4
test (+ 1234567890123.4 0.0) 1234567890123.4
test (+  123.45  123.45) 246.9
test (+  123.45 -123.45) 0.0
test (+ -123.45  123.45) 0.0
test (+ -123.45 -123.45) -246.9
test (+  1e10  12345.67) 1.000001234567e10
test (+  1e10 -12345.67) 9.99998765433e9
test (+ -1e10  12345.67) -9.99998765433e9
test (+ -1e10 -12345.67) -1.000001234567e10
test (+  1e-10  12345.67) 12345.6700000001
test (+  1e-10 -12345.67) -12345.6699999999
test (+ -1e-10  12345.67) 12345.6699999999
test (+ -1e-10 -12345.67) -12345.6700000001
test (+  12345.67  1e10) 1.000001234567e10
test (+  12345.67 -1e10) -9.99998765433e9
test (+ -12345.67  1e10) 9.99998765433e9
test (+ -12345.67 -1e10) -1.000001234567e10
test (+  12345.67  1e-10) 12345.6700000001
test (+  12345.67 -1e-10) 12345.6699999999
test (+ -12345.67  1e-10) -12345.6699999999
test (+ -12345.67 -1e-10) -12345.6700000001
test (+ 999999999.9 1) 1000000000.9
test (+ 1 999999999.9) 1000000000.9
test (+ 1000000000.9 -1) 999999999.9
test (+ -1 1000000000.9) 999999999.9
test (+ 12345.67  1234567) 1246912.67
test (+ 12345.67 123456.7) 135802.37
test (+ 12345.67 12345.67) 24691.34
test (+ 12345.67 1234.567) 13580.237
test (+ 12345.67 123.4567) 12469.1267
test (+ 12345.67 12.34567) 12358.01567
test (+ 12345.67 1.234567) 12346.904567
test (+ 12345.67 0.1234567) 12345.7934567
test (+  1234567 12345.67) 1246912.67
test (+ 123456.7 12345.67) 135802.37
test (+ 12345.67 12345.67) 24691.34
test (+ 1234.567 12345.67) 13580.237
test (+ 123.4567 12345.67) 12469.1267
test (+ 12.34567 12345.67) 12358.01567
test (+ 1.234567 12345.67) 12346.904567
test (+ 0.1234567 12345.67) 12345.7934567
test (+ 1.1 2.2 3.3 4.4 5.5) 16.5
test (exact? (+   1.0   1.0)) #t
test (exact? (+ #i1.0   1.0)) #f
test (exact? (+   1.0 #i1.0)) #f
test (exact? (+ #i1.0 #i1.0)) #f

test (-  1234567890  9876543210)  -8641975320
test (-  1234567890 -9876543210)  11111111100
test (- -1234567890  9876543210) -11111111100
test (- -1234567890 -9876543210)   8641975320
test (-  9876543210  1234567890)   8641975320
test (-  9876543210 -1234567890)  11111111100
test (- -9876543210  1234567890) -11111111100
test (- -9876543210 -1234567890)  -8641975320
test (- 1234567890 0) 1234567890
test (- 0 1234567890) -1234567890
test (- 1 2 3 4 5 6 7 8 9 10) -53
test (- 1234567890) -1234567890
test (- 0) 0

test (-  0.0) 0.0
test (-  1.0) -1.0
test (- -1.0) 1.0
test (- 0.0 1234567890123.4) -1234567890123.4
test (- 1234567890123.4 0.0) 1234567890123.4
test (-  123.45  123.45) 0.0
test (-  123.45 -123.45) 246.9
test (- -123.45  123.45) -246.9
test (- -123.45 -123.45) 0.0
test (-  1e10  12345.67) 9.99998765433e9
test (-  1e10 -12345.67) 1.000001234567e10
test (- -1e10  12345.67) -1.000001234567e10
test (- -1e10 -12345.67) -9.99998765433e9
test (-  1e-10  12345.67) -12345.6699999999
test (-  1e-10 -12345.67) 12345.6700000001
test (- -1e-10  12345.67) -12345.6700000001
test (- -1e-10 -12345.67) 12345.6699999999
test (-  12345.67  1e10) -9.99998765433e9
test (-  12345.67 -1e10) 1.000001234567e10
test (- -12345.67  1e10) -1.000001234567e10
test (- -12345.67 -1e10) 9.99998765433e9
test (-  12345.67  1e-10) 12345.6699999999
test (-  12345.67 -1e-10) 12345.6700000001
test (- -12345.67  1e-10) -12345.6700000001
test (- -12345.67 -1e-10) -12345.6699999999
test (- 999999999.9 -1) 1000000000.9
test (- -1 999999999.9) -1000000000.9
test (- 1000000000.9 1) 999999999.9
test (- 1 1000000000.9) -999999999.9
test (- 12345.67  1234567) -1222221.33
test (- 12345.67 123456.7) -111111.03
test (- 12345.67 12345.67) 0.0
test (- 12345.67 1234.567) 11111.103
test (- 12345.67 123.4567) 12222.2133
test (- 12345.67 12.34567) 12333.32433
test (- 12345.67 1.234567) 12344.435433
test (- 12345.67 0.1234567) 12345.5465433
test (-  1234567 12345.67) 1222221.33
test (- 123456.7 12345.67) 111111.03
test (- 12345.67 12345.67) 0.0
test (- 1234.567 12345.67) -11111.103
test (- 123.4567 12345.67) -12222.2133
test (- 12.34567 12345.67) -12333.32433
test (- 1.234567 12345.67) -12344.435433
test (- 0.1234567 12345.67) -12345.5465433
test (- 1.1 2.2 3.3 4.4 5.5) -14.3
test (exact? (-   2.0   1.0)) #t
test (exact? (- #i2.0   1.0)) #f
test (exact? (-   2.0 #i1.0)) #f
test (exact? (- #i2.0 #i1.0)) #f

test (*  1234567  7654321)  9449772114007
test (*  1234567 -7654321) -9449772114007
test (* -1234567  7654321) -9449772114007
test (* -1234567 -7654321)  9449772114007
test (*  7654321  1234567)  9449772114007
test (*  7654321 -1234567) -9449772114007
test (* -7654321  1234567) -9449772114007
test (* -7654321 -1234567)  9449772114007
test (* 1234567 1) 1234567
test (* 1 1234567) 1234567
test (* 1234567 0) 0
test (* 0 1234567) 0
test (* 1 2 3 4 5 6 7 8 9 10) 3628800
test (* 1 2 3 4 5 6 7 8 9) 362880
test (* 2) 2
test (*) 1

test (* 0.0  0.0)  0.0
test (* 0.0  0.1)  0.0
test (* 0.0  1.0)  0.0
test (* 0.0 -0.0)  0.0
test (* 0.0 -0.1)  0.0
test (* 0.0 -1.0)  0.0
test (* 0.1  0.0)  0.0
test (* 0.1  0.1)  0.01
test (* 0.1  1.0)  0.1
test (* 0.1 -0.0)  0.0
test (* 0.1 -0.1) -0.01
test (* 0.1 -1.0) -0.1
test (* 1.0  0.0)  0.0
test (* 1.0  0.1)  0.1
test (* 1.0  1.0)  1.0
test (* 1.0 -0.0)  0.0
test (* 1.0 -0.1) -0.1
test (* 1.0 -1.0) -1.0
test (*  123.45  123.45) 15239.9025
test (*  123.45 -123.45) -15239.9025
test (* -123.45  123.45) -15239.9025
test (* -123.45 -123.45) 15239.9025
test (*  123.45e+100  123.45e+100) 1.52399025e204
test (*  123.45e+100 -123.45e+100) -1.52399025e204
test (* -123.45e+100  123.45e+100) -1.52399025e204
test (* -123.45e+100 -123.45e+100) 1.52399025e204
test (*  123.45e-100  123.45e-100) 1.52399025e-196
test (*  123.45e-100 -123.45e-100) -1.52399025e-196
test (* -123.45e-100  123.45e-100) -1.52399025e-196
test (* -123.45e-100 -123.45e-100) 1.52399025e-196
test (* 12345.67 0.1234567) 1524.155677489
test (* 12345.67 1.234567) 15241.55677489
test (* 12345.67 12.34567) 152415.5677489
test (* 12345.67 123.4567) 1524155.677489
test (* 12345.67 1234.567) 15241556.77489
test (* 12345.67 12345.67) 152415567.7489
test (* 12345.67 123456.7) 1.524155677489e9
test (* 12345.67 1234567.) 1.524155677489e10
test (* -0.1234567 12345.67) -1524.155677489
test (* -1.234567 12345.67) -15241.55677489
test (* -12.34567 12345.67) -152415.5677489
test (* -123.4567 12345.67) -1524155.677489
test (* -1234.567 12345.67) -15241556.77489
test (* -12345.67 12345.67) -152415567.7489
test (* -123456.7 12345.67) -1.524155677489e9
test (* -1234567. 12345.67) -1.524155677489e10
test (* 1.0   2   3   4   5   6   7   8   9) 362880.0
test (* 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9) 855652.05811008

test (/ 0.0  0.1) 0.0
test (/ 0.0  1.0) 0.0
test (/ 0.0 -0.1) 0.0
test (/ 0.0 -1.0) 0.0
test (/ 0.1  0.1) 1.0
test (/ 0.1  1.0) 0.1
test (/ 0.1 -0.1) -1.0
test (/ 0.1 -1.0) -0.1
test (/ 1.0  0.1) 10.0
test (/ 1.0  1.0) 1.0
test (/ 1.0 -0.1) -10.0
test (/ 1.0 -1.0) -1.0
test (/  12345.  123.45) 100.0
test (/  12345. -123.45) -100.0
test (/ -12345.  123.45) -100.0
test (/ -12345. -123.45) 100.0
test (/  152337.3  123.4) 1234.5
test (/  152337.3 -123.4) -1234.5
test (/ -152337.3  123.4) -1234.5
test (/ -152337.3 -123.4) 1234.5
test (/  1.52399025e+204  123.45e+100) 123.45e+100
test (/ -1.52399025e+204 -123.45e+100) 123.45e+100
test (/ -1.52399025e+204  123.45e+100) -123.45e+100
test (/  1.52399025e+204 -123.45e+100) -123.45e+100
test (/  1.52399025e-196  123.45e-100) 123.45e-100
test (/ -1.52399025e-196 -123.45e-100) 123.45e-100
test (/ -1.52399025e-196  123.45e-100) -123.45e-100
test (/  1.52399025e-196 -123.45e-100) -123.45e-100
test (/ 12345.67 0.1234567) 100000.0
test (/ 12345.67 1.234567) 10000.0
test (/ 12345.67 12.34567) 1000.0
test (/ 12345.67 123.4567) 100.0
test (/ 12345.67 1234.567) 10.0
test (/ 12345.67 12345.67) 1.0
test (/ 12345.67 123456.7) 0.1
test (/ 12345.67 1234567.) 0.01
test (/ -0.1234567 12345.67) -0.00001
test (/ -1.234567 12345.67) -0.0001
test (/ -12.34567 12345.67) -0.001
test (/ -123.4567 12345.67) -0.01
test (/ -1234.567 12345.67) -0.1
test (/ -12345.67 12345.67) -1.0
test (/ -123456.7 12345.67) -10.0
test (/ -1234567. 12345.67) -100.0
test (/ 1.0) 1.0
test (/ 2.0) 0.5
test (/ 5.0) 0.2
test (/ 128.0 64 32 16 8 4 2 1) 6.103515625e-5

test (lt  1234567890  9876543210) #t
test (lt  1234567890 -9876543210) #f
test (lt -1234567890  9876543210) #t
test (lt -1234567890 -9876543210) #f
test (lt  9876543210  1234567890) #f
test (lt  9876543210 -1234567890) #f
test (lt -9876543210  1234567890) #t
test (lt -9876543210 -1234567890) #t
test (lt -1234567890 -1234567890) #f
test (lt  1234567890  1234567890) #f
test (lt 1234567890 0) #f
test (lt 0 1234567890) #t
test (lt 1 2 3 4 5 6 7 8 9 10) #t
test (lt 1 2 3 4 5 6 7 8 9 9) #f

test (lt  0.0  0.0) #f
test (lt -0.0  0.0) #f
test (lt  0.0 -0.0) #f
test (lt -0.0 -0.0) #f
test (lt  1.0  1.0) #f
test (lt -1.0  1.0) #t
test (lt  1.0 -1.0) #f
test (lt -1.0 -1.0) #f
test (lt  0.1  0.1) #f
test (lt -0.1  0.1) #t
test (lt  0.1 -0.1) #f
test (lt -0.1 -0.1) #f
test (lt  123.45e+67  123.45e+67) #f
test (lt  123.45e+67  123.45e-67) #f
test (lt  123.45e-67  123.45e+67) #t
test (lt  123.45e-67  123.45e-67) #f
test (lt  123.45e+67 -123.45e+67) #f
test (lt  123.45e+67 -123.45e-67) #f
test (lt  123.45e-67 -123.45e+67) #f
test (lt  123.45e-67 -123.45e-67) #f
test (lt -123.45e+67  123.45e+67) #t
test (lt -123.45e+67  123.45e-67) #t
test (lt -123.45e-67  123.45e+67) #t
test (lt -123.45e-67  123.45e-67) #t
test (lt -123.45e+67 -123.45e+67) #f
test (lt -123.45e+67 -123.45e-67) #t
test (lt -123.45e-67 -123.45e+67) #f
test (lt -123.45e-67 -123.45e-67) #f
test (lt  0.0 0.0) #f
test (lt  1.0 0.0) #f
test (lt -1.0 0.0) #t
test (lt  0.1 0.0) #f
test (lt -0.1 0.0) #t
test (lt  1e+0 0.0) #f
test (lt -1e+0 0.0) #t
test (lt  1e-0 0.0) #f
test (lt -1e-0 0.0) #t
test (lt  1e+100 0.0) #f
test (lt -1e+100 0.0) #t
test (lt  1e-100 0.0) #f
test (lt -1e-100 0.0) #t
test (lt  1e+10000 0.0) #f
test (lt -1e+10000 0.0) #t
test (lt  1e-10000 0.0) #f
test (lt -1e-10000 0.0) #t
test (lt 0.0  0.0) #f
test (lt 0.0  1.0) #t
test (lt 0.0 -1.0) #f
test (lt 0.0  0.1) #t
test (lt 0.0 -0.1) #f
test (lt 0.0  1e+0) #t
test (lt 0.0 -1e+0) #f
test (lt 0.0  1e-0) #t
test (lt 0.0 -1e-0) #f
test (lt 0.0  1e+100) #t
test (lt 0.0 -1e+100) #f
test (lt 0.0  1e-100) #t
test (lt 0.0 -1e-100) #f
test (lt 0.0  1e+10000) #t
test (lt 0.0 -1e+10000) #f
test (lt 0.0  1e-10000) #t
test (lt 0.0 -1e-10000) #f
test (lt  1.0e14  1.0e14) #f
test (lt  1.0e14 -1.0e14) #f
test (lt -1.0e14  1.0e14) #t
test (lt -1.0e14 -1.0e14) #f
test (lt  1.0e14  1.1e14) #t
test (lt  1.0e14 -1.1e14) #f
test (lt -1.0e14  1.1e14) #t
test (lt -1.0e14 -1.1e14) #f
test (lt  1.0e-14  1.0e-14) #f
test (lt  1.0e-14 -1.0e-14) #f
test (lt -1.0e-14  1.0e-14) #t
test (lt -1.0e-14 -1.0e-14) #f
test (lt  1.0e-14  1.1e-14) #t
test (lt  1.0e-14 -1.1e-14) #f
test (lt -1.0e-14  1.1e-14) #t
test (lt -1.0e-14 -1.1e-14) #f
test (lt  1234567890123.4  1234567890123) #f
test (lt  1234567890123.4 -1234567890123) #f
test (lt -1234567890123.4  1234567890123) #t
test (lt -1234567890123.4 -1234567890123) #t
test (lt  1234567890123  1234567890123.4) #t
test (lt  1234567890123 -1234567890123.4) #f
test (lt -1234567890123  1234567890123.4) #t
test (lt -1234567890123 -1234567890123.4) #f
test (lt 1e-5 1e-4 1e-3 0.01 0.1 1.0 10.0) #t
test (lt 1e-5 1e-4 1e-3 0.01 0.1 1.0  1.0) #f
test (lt 1.0 1.0 1.0 1.0 1.0 1.0) #f

test (le  1234567890  9876543210) #t
test (le  1234567890 -9876543210) #f
test (le -1234567890  9876543210) #t
test (le -1234567890 -9876543210) #f
test (le  9876543210  1234567890) #f
test (le  9876543210 -1234567890) #f
test (le -9876543210  1234567890) #t
test (le -9876543210 -1234567890) #t
test (le -1234567890 -1234567890) #t
test (le  1234567890  1234567890) #t
test (le 1234567890 0) #f
test (le 0 1234567890) #t
test (le 1 2 3 4 5 6 7 8 9 10) #t
test (le 1 2 3 4 5 6 7 8 9 9) #t

test (le  0.0  0.0) #t
test (le -0.0  0.0) #t
test (le  0.0 -0.0) #t
test (le -0.0 -0.0) #t
test (le  1.0  1.0) #t
test (le -1.0  1.0) #t
test (le  1.0 -1.0) #f
test (le -1.0 -1.0) #t
test (le  0.1  0.1) #t
test (le -0.1  0.1) #t
test (le  0.1 -0.1) #f
test (le -0.1 -0.1) #t
test (le  123.45e+67  123.45e+67) #t
test (le  123.45e+67  123.45e-67) #f
test (le  123.45e-67  123.45e+67) #t
test (le  123.45e-67  123.45e-67) #t
test (le  123.45e+67 -123.45e+67) #f
test (le  123.45e+67 -123.45e-67) #f
test (le  123.45e-67 -123.45e+67) #f
test (le  123.45e-67 -123.45e-67) #f
test (le -123.45e+67  123.45e+67) #t
test (le -123.45e+67  123.45e-67) #t
test (le -123.45e-67  123.45e+67) #t
test (le -123.45e-67  123.45e-67) #t
test (le -123.45e+67 -123.45e+67) #t
test (le -123.45e+67 -123.45e-67) #t
test (le -123.45e-67 -123.45e+67) #f
test (le -123.45e-67 -123.45e-67) #t
test (le  0.0 0.0) #t
test (le  1.0 0.0) #f
test (le -1.0 0.0) #t
test (le  0.1 0.0) #f
test (le -0.1 0.0) #t
test (le  1e+0 0.0) #f
test (le -1e+0 0.0) #t
test (le  1e-0 0.0) #f
test (le -1e-0 0.0) #t
test (le  1e+100 0.0) #f
test (le -1e+100 0.0) #t
test (le  1e-100 0.0) #f
test (le -1e-100 0.0) #t
test (le  1e+10000 0.0) #f
test (le -1e+10000 0.0) #t
test (le  1e-10000 0.0) #f
test (le -1e-10000 0.0) #t
test (le 0.0  0.0) #t
test (le 0.0  1.0) #t
test (le 0.0 -1.0) #f
test (le 0.0  0.1) #t
test (le 0.0 -0.1) #f
test (le 0.0  1e+0) #t
test (le 0.0 -1e+0) #f
test (le 0.0  1e-0) #t
test (le 0.0 -1e-0) #f
test (le 0.0  1e+100) #t
test (le 0.0 -1e+100) #f
test (le 0.0  1e-100) #t
test (le 0.0 -1e-100) #f
test (le 0.0  1e+10000) #t
test (le 0.0 -1e+10000) #f
test (le 0.0  1e-10000) #t
test (le 0.0 -1e-10000) #f
test (le  1.0e14  1.0e14) #t
test (le  1.0e14 -1.0e14) #f
test (le -1.0e14  1.0e14) #t
test (le -1.0e14 -1.0e14) #t
test (le  1.0e14  1.1e14) #t
test (le  1.0e14 -1.1e14) #f
test (le -1.0e14  1.1e14) #t
test (le -1.0e14 -1.1e14) #f
test (le  1.0e-14  1.0e-14) #t
test (le  1.0e-14 -1.0e-14) #f
test (le -1.0e-14  1.0e-14) #t
test (le -1.0e-14 -1.0e-14) #t
test (le  1.0e-14  1.1e-14) #t
test (le  1.0e-14 -1.1e-14) #f
test (le -1.0e-14  1.1e-14) #t
test (le -1.0e-14 -1.1e-14) #f
test (le  1234567890123.4  1234567890123) #f
test (le  1234567890123.4 -1234567890123) #f
test (le -1234567890123.4  1234567890123) #t
test (le -1234567890123.4 -1234567890123) #t
test (le  1234567890123  1234567890123.4) #t
test (le  1234567890123 -1234567890123.4) #f
test (le -1234567890123  1234567890123.4) #t
test (le -1234567890123 -1234567890123.4) #f
test (le 1e-5 1e-4 1e-3 0.01 0.1 1.0 10.0) #t
test (le 1e-5 1e-4 1e-3 0.01 0.1 1.0  1.0) #t
test (le 1.0 1.0 1.0 1.0 1.0 1.0) #t

test (eq  1234567890  9876543210) #f
test (eq  1234567890 -9876543210) #f
test (eq -1234567890  9876543210) #f
test (eq -1234567890 -9876543210) #f
test (eq  9876543210  1234567890) #f
test (eq  9876543210 -1234567890) #f
test (eq -9876543210  1234567890) #f
test (eq -9876543210 -1234567890) #f
test (eq -1234567890  1234567890) #f
test (eq  1234567890 -1234567890) #f
test (eq  1234567890  1234567890) #t
test (eq -1234567890 -1234567890) #t
test (eq 0 0) #t
test (eq 0 1234567890) #f
test (eq 1234567890 0) #f
test (eq 1 1 1 1 1 1 1 1 1 1) #t
test (eq 1 1 1 1 1 1 1 1 1 0) #f

test (eq  0.0  0.0) #t
test (eq  0.0 -0.0) #t
test (eq -0.0  0.0) #t
test (eq -0.0 -0.0) #t
test (eq  1.0  1.0) #t
test (eq  1.0 -1.0) #f
test (eq -1.0  1.0) #f
test (eq -1.0 -1.0) #t
test (eq  0.1  0.1) #t
test (eq  0.1 -0.1) #f
test (eq -0.1  0.1) #f
test (eq -0.1 -0.1) #t
test (eq 1.0   1) #t
test (eq   1 1.0) #t
test (eq  123.456e3 123456) #t
test (eq  123.456e4 1234560) #t
test (eq  123.456e5 12345600) #t
test (eq  123.456e10 1234560000000) #t
test (eq -123.456e3  -123456) #t
test (eq -123.456e4  -1234560) #t
test (eq -123.456e5  -12345600) #t
test (eq -123.456e10 -1234560000000) #t
test (eq  1.2345678901234  12345678901234.) #f
test (eq  1.2345678901234  1234567890123.4) #f
test (eq  1.2345678901234  123456789012.34) #f
test (eq  1.2345678901234  12345678901.234) #f
test (eq  1.2345678901234  1234567890.1234) #f
test (eq  1.2345678901234  123456789.01234) #f
test (eq  1.2345678901234  12345678.901234) #f
test (eq  1.2345678901234  1234567.8901234) #f
test (eq  1.2345678901234  123456.78901234) #f
test (eq  1.2345678901234  12345.678901234) #f
test (eq  1.2345678901234  1234.5678901234) #f
test (eq  1.2345678901234  123.45678901234) #f
test (eq  1.2345678901234  12.345678901234) #f
test (eq  1.2345678901234  1.2345678901234) #t
test (eq -1.2345678901234 1.2345678901234) #f
test (eq  1.2345678901234 -1.2345678901234) #f
test (eq  1.2345678901234  1.2345678901233) #f
test (eq  1.2345678901234  1.2345678901235) #f
test (eq 1e50 100000000000000000000000000000000000000000000000000) #t
test (eq 100000000000000000000000000000000000000000000000000 1e50) #t
test (eq 12345678901234.0 12345678901234) #t
test (eq 12345678901234 12345678901234.0) #t
test (eq -12345678901234.0 -12345678901234) #t
test (eq -12345678901234 -12345678901234.0) #t
test (eq 1.0 1.0 1.0 1.0 1.0 1.0 1.0) #t
test (eq 1.0 1.0 1.0 1.0 1.0 1.0 0.1) #f

test (gt  1234567890  9876543210) #f
test (gt  1234567890 -9876543210) #t
test (gt -1234567890  9876543210) #f
test (gt -1234567890 -9876543210) #t
test (gt  9876543210  1234567890) #t
test (gt  9876543210 -1234567890) #t
test (gt -9876543210  1234567890) #f
test (gt -9876543210 -1234567890) #f
test (gt -1234567890 -1234567890) #f
test (gt  1234567890  1234567890) #f
test (gt 1234567890 0) #t
test (gt 0 1234567890) #f
test (gt 9 8 7 6 5 4 3 2 1 0) #t
test (gt 9 8 7 6 5 4 3 2 1 1) #f

test (gt  0.0  0.0) #f
test (gt -0.0  0.0) #f
test (gt  0.0 -0.0) #f
test (gt -0.0 -0.0) #f
test (gt  1.0  1.0) #f
test (gt -1.0  1.0) #f
test (gt  1.0 -1.0) #t
test (gt -1.0 -1.0) #f
test (gt  0.1  0.1) #f
test (gt -0.1  0.1) #f
test (gt  0.1 -0.1) #t
test (gt -0.1 -0.1) #f
test (gt  123.45e+67  123.45e+67) #f
test (gt  123.45e+67  123.45e-67) #t
test (gt  123.45e-67  123.45e+67) #f
test (gt  123.45e-67  123.45e-67) #f
test (gt  123.45e+67 -123.45e+67) #t
test (gt  123.45e+67 -123.45e-67) #t
test (gt  123.45e-67 -123.45e+67) #t
test (gt  123.45e-67 -123.45e-67) #t
test (gt -123.45e+67  123.45e+67) #f
test (gt -123.45e+67  123.45e-67) #f
test (gt -123.45e-67  123.45e+67) #f
test (gt -123.45e-67  123.45e-67) #f
test (gt -123.45e+67 -123.45e+67) #f
test (gt -123.45e+67 -123.45e-67) #f
test (gt -123.45e-67 -123.45e+67) #t
test (gt -123.45e-67 -123.45e-67) #f
test (gt  0.0 0.0) #f
test (gt  1.0 0.0) #t
test (gt -1.0 0.0) #f
test (gt  0.1 0.0) #t
test (gt -0.1 0.0) #f
test (gt  1e+0 0.0) #t
test (gt -1e+0 0.0) #f
test (gt  1e-0 0.0) #t
test (gt -1e-0 0.0) #f
test (gt  1e+100 0.0) #t
test (gt -1e+100 0.0) #f
test (gt  1e-100 0.0) #t
test (gt -1e-100 0.0) #f
test (gt  1e+10000 0.0) #t
test (gt -1e+10000 0.0) #f
test (gt  1e-10000 0.0) #t
test (gt -1e-10000 0.0) #f
test (gt 0.0  0.0) #f
test (gt 0.0  1.0) #f
test (gt 0.0 -1.0) #t
test (gt 0.0  0.1) #f
test (gt 0.0 -0.1) #t
test (gt 0.0  1e+0) #f
test (gt 0.0 -1e+0) #t
test (gt 0.0  1e-0) #f
test (gt 0.0 -1e-0) #t
test (gt 0.0  1e+100) #f
test (gt 0.0 -1e+100) #t
test (gt 0.0  1e-100) #f
test (gt 0.0 -1e-100) #t
test (gt 0.0  1e+10000) #f
test (gt 0.0 -1e+10000) #t
test (gt 0.0  1e-10000) #f
test (gt 0.0 -1e-10000) #t
test (gt  1.0e14  1.0e14) #f
test (gt  1.0e14 -1.0e14) #t
test (gt -1.0e14  1.0e14) #f
test (gt -1.0e14 -1.0e14) #f
test (gt  1.0e14  1.1e14) #f
test (gt  1.0e14 -1.1e14) #t
test (gt -1.0e14  1.1e14) #f
test (gt -1.0e14 -1.1e14) #t
test (gt  1.0e-14  1.0e-14) #f
test (gt  1.0e-14 -1.0e-14) #t
test (gt -1.0e-14  1.0e-14) #f
test (gt -1.0e-14 -1.0e-14) #f
test (gt  1.0e-14  1.1e-14) #f
test (gt  1.0e-14 -1.1e-14) #t
test (gt -1.0e-14  1.1e-14) #f
test (gt -1.0e-14 -1.1e-14) #t
test (gt  1234567890123.4  1234567890123) #t
test (gt  1234567890123.4 -1234567890123) #t
test (gt -1234567890123.4  1234567890123) #f
test (gt -1234567890123.4 -1234567890123) #f
test (gt  1234567890123  1234567890123.4) #f
test (gt  1234567890123 -1234567890123.4) #t
test (gt -1234567890123  1234567890123.4) #f
test (gt -1234567890123 -1234567890123.4) #t
test (gt 10.0 1.0 0.1 0.01 1e-3 1e-4 1e-5) #t
test (gt 10.0 1.0 0.1 0.01 1e-3 1e-4 1e-4) #f
test (gt 1.0 1.0 1.0 1.0 1.0 1.0) #f

test (ge  1234567890  9876543210) #f
test (ge  1234567890 -9876543210) #t
test (ge -1234567890  9876543210) #f
test (ge -1234567890 -9876543210) #t
test (ge  9876543210  1234567890) #t
test (ge  9876543210 -1234567890) #t
test (ge -9876543210  1234567890) #f
test (ge -9876543210 -1234567890) #f
test (ge -1234567890 -1234567890) #t
test (ge  1234567890  1234567890) #t
test (ge 1234567890 0) #t
test (ge 0 1234567890) #f
test (ge 9 8 7 6 5 4 3 2 1 0) #t
test (ge 9 8 7 6 5 4 3 2 1 1) #t

test (ge  0.0  0.0) #t
test (ge -0.0  0.0) #t
test (ge  0.0 -0.0) #t
test (ge -0.0 -0.0) #t
test (ge  1.0  1.0) #t
test (ge -1.0  1.0) #f
test (ge  1.0 -1.0) #t
test (ge -1.0 -1.0) #t
test (ge  0.1  0.1) #t
test (ge -0.1  0.1) #f
test (ge  0.1 -0.1) #t
test (ge -0.1 -0.1) #t
test (ge  123.45e+67  123.45e+67) #t
test (ge  123.45e+67  123.45e-67) #t
test (ge  123.45e-67  123.45e+67) #f
test (ge  123.45e-67  123.45e-67) #t
test (ge  123.45e+67 -123.45e+67) #t
test (ge  123.45e+67 -123.45e-67) #t
test (ge  123.45e-67 -123.45e+67) #t
test (ge  123.45e-67 -123.45e-67) #t
test (ge -123.45e+67  123.45e+67) #f
test (ge -123.45e+67  123.45e-67) #f
test (ge -123.45e-67  123.45e+67) #f
test (ge -123.45e-67  123.45e-67) #f
test (ge -123.45e+67 -123.45e+67) #t
test (ge -123.45e+67 -123.45e-67) #f
test (ge -123.45e-67 -123.45e+67) #t
test (ge -123.45e-67 -123.45e-67) #t
test (ge  0.0 0.0) #t
test (ge  1.0 0.0) #t
test (ge -1.0 0.0) #f
test (ge  0.1 0.0) #t
test (ge -0.1 0.0) #f
test (ge  1e+0 0.0) #t
test (ge -1e+0 0.0) #f
test (ge  1e-0 0.0) #t
test (ge -1e-0 0.0) #f
test (ge  1e+100 0.0) #t
test (ge -1e+100 0.0) #f
test (ge  1e-100 0.0) #t
test (ge -1e-100 0.0) #f
test (ge  1e+10000 0.0) #t
test (ge -1e+10000 0.0) #f
test (ge  1e-10000 0.0) #t
test (ge -1e-10000 0.0) #f
test (ge 0.0  0.0) #t
test (ge 0.0  1.0) #f
test (ge 0.0 -1.0) #t
test (ge 0.0  0.1) #f
test (ge 0.0 -0.1) #t
test (ge 0.0  1e+0) #f
test (ge 0.0 -1e+0) #t
test (ge 0.0  1e-0) #f
test (ge 0.0 -1e-0) #t
test (ge 0.0  1e+100) #f
test (ge 0.0 -1e+100) #t
test (ge 0.0  1e-100) #f
test (ge 0.0 -1e-100) #t
test (ge 0.0  1e+10000) #f
test (ge 0.0 -1e+10000) #t
test (ge 0.0  1e-10000) #f
test (ge 0.0 -1e-10000) #t
test (ge  1.0e14  1.0e14) #t
test (ge  1.0e14 -1.0e14) #t
test (ge -1.0e14  1.0e14) #f
test (ge -1.0e14 -1.0e14) #t
test (ge  1.0e14  1.1e14) #f
test (ge  1.0e14 -1.1e14) #t
test (ge -1.0e14  1.1e14) #f
test (ge -1.0e14 -1.1e14) #t
test (ge  1.0e-14  1.0e-14) #t
test (ge  1.0e-14 -1.0e-14) #t
test (ge -1.0e-14  1.0e-14) #f
test (ge -1.0e-14 -1.0e-14) #t
test (ge  1.0e-14  1.1e-14) #f
test (ge  1.0e-14 -1.1e-14) #t
test (ge -1.0e-14  1.1e-14) #f
test (ge -1.0e-14 -1.1e-14) #t
test (ge  1234567890123.4  1234567890123) #t
test (ge  1234567890123.4 -1234567890123) #t
test (ge -1234567890123.4  1234567890123) #f
test (ge -1234567890123.4 -1234567890123) #f
test (ge  1234567890123  1234567890123.4) #f
test (ge  1234567890123 -1234567890123.4) #t
test (ge -1234567890123  1234567890123.4) #f
test (ge -1234567890123 -1234567890123.4) #t
test (ge 10.0 1.0 0.1 0.01 1e-3 1e-4 1e-5) #t
test (ge 10.0 1.0 0.1 0.01 1e-3 1e-4 1e-4) #t
test (ge 1.0 1.0 1.0 1.0 1.0 1.0) #t

test (abs 1234567890) 1234567890
test (abs -1234567890) 1234567890
test (abs 0) 0
test (abs 1.234567890) 1.23456789
test (abs 1.234567890) 1.23456789
test (abs 0.0) 0.0
test (abs -0.0) 0.0

test (lt 1.570796320 (acos 0.00) 1.570796329) #t
test (lt 1.318116070 (acos 0.25) 1.318116079) #t
test (lt 1.047197550 (acos 0.50) 1.047197559) #t
test (lt 0.722734240 (acos 0.75) 0.722734249) #t
test (lt 3.141592650 (acos -1.00) 3.141592659) #t
test (lt 2.418858400 (acos -0.75) 2.418858409) #t
test (lt 2.094395100 (acos -0.50) 2.094395109) #t
test (lt 1.823476580 (acos -0.25) 1.823476589) #t
test (acos 1) 0

test (asin 0) 0
test (lt 0.252680250 (asin 0.25) 0.252680259) #t
test (lt 0.523598770 (asin 0.50) 0.523598779) #t
test (lt 0.848062070 (asin 0.75) 0.848062079) #t
test (lt 1.570796320 (asin 1.00) 1.570796329) #t
test (lt -1.570796329 (asin -1.00) -1.570796320) #t
test (lt -0.848062079 (asin -0.75) -0.848062070) #t
test (lt -0.523598779 (asin -0.50) -0.523598770) #t
test (lt -0.252680259 (asin -0.25) -0.252680250) #t

test (atan 0) 0
test (lt 0.244978660 (atan 0.25) 0.244978669) #t
test (lt 0.463647600 (atan 0.50) 0.463647610) #t
test (lt 0.643501100 (atan 0.75) 0.643501109) #t
test (lt 0.785398160 (atan 1.00) 0.785398169) #t
test (lt -0.244978669 (atan -0.25) -0.244978660) #t
test (lt -0.463647610 (atan -0.50) -0.463647600) #t
test (lt -0.643501109 (atan -0.75) -0.643501100) #t
test (lt -0.785398169 (atan -1.00) -0.785398160) #t

test (ceiling  0.0) 0.0
test (ceiling  1.0) 1.0
test (ceiling -1.0) -1.0
test (ceiling  1.1) 2.0
test (ceiling  1.4) 2.0
test (ceiling  1.5) 2.0
test (ceiling  1.9) 2.0
test (ceiling -1.1) -1.0
test (ceiling -1.4) -1.0
test (ceiling -1.5) -1.0
test (ceiling -1.9) -1.0

define pi 3.141592653589793238462643383279502884197169399375105820974944
define pi/4  (/ pi 4)
define pi/2  (/ pi 2)
define 3pi/4 (+ pi/2 pi/4)
define 3pi/2 (+ pi pi/2)
define 5pi/4 (+ pi pi/4)
define 7pi/4 (+ pi 3pi/4)
define 2pi   (+ pi pi)

test (cos   0.0) 1.0
test (cos  pi/2) (if (exact? pi)  0.0 #i0.0)
test (cos  pi  ) (if (exact? pi) -1.0 #i-1.0)
test (cos 3pi/2) (if (exact? pi)  0.0 #i0.0)
test (cos 2pi  ) 1.0
test (lt  0.7071067810 (cos  pi/4)  0.7071067819) #t
test (lt -0.7071067819 (cos 3pi/4) -0.7071067810) #t
test (lt -0.7071067819 (cos 5pi/4) -0.7071067810) #t
test (lt  0.7071067810 (cos 7pi/4)  0.7071067819) #t
test (lt  0.1699671420 (cos   1.4)  0.1699671430) #t
test (lt -0.9422223409 (cos   2.8) -0.9422223400) #t
test (lt -0.4902608219 (cos   4.2) -0.4902608210) #t
test (lt  0.7755658780 (cos   5.6)  0.7755658789) #t

test (even? -1) #f
test (even? 0) #t
test (even? 1) #f
test (even? 2) #t
test (even? 1234567890) #t
test (even? 1234567891) #f

test (exact->inexact  #e0.0) #i0
test (exact->inexact  #i0.0) #i0
test (exact->inexact #e-0.0) #i0
test (exact->inexact #i-0.0) #i0
test (exact->inexact  #e1.0) #i1
test (exact->inexact  #i1.0) #i1
test (exact->inexact #e-1.0) #i-1
test (exact->inexact #i-1.0) #i-1
test (exact->inexact  #e1.1) #i1.1
test (exact->inexact  #i1.1) #i1.1
test (exact->inexact #e-1.1) #i-1.1
test (exact->inexact #i-1.1) #i-1.1
test (exact? (exact->inexact  0)) #f
test (exact? (exact->inexact  1)) #f
test (exact? (exact->inexact -1)) #f
test (exact? (exact->inexact  12345678901234567890)) #f
test (exact? (exact->inexact -12345678901234567890)) #f
test (exact? (exact->inexact  0.0)) #f
test (exact? (exact->inexact -0.0)) #f
test (exact? (exact->inexact  0.1)) #f
test (exact? (exact->inexact -0.1)) #f
test (exact? (exact->inexact  1.0)) #f
test (exact? (exact->inexact -1.0)) #f
test (exact? (exact->inexact  1234567890.1234)) #f
test (exact? (exact->inexact -1234567890.1234)) #f
test (exact? (exact->inexact  0.1234567890123)) #f
test (exact? (exact->inexact -0.1234567890123)) #f
test (exact? (exact->inexact  1.2345e+100)) #f
test (exact? (exact->inexact  1.2345e-100)) #f
test (exact? (exact->inexact -1.2345e+100)) #f
test (exact? (exact->inexact -1.2345e-100)) #f

test (exact?  0) #t
test (exact?  1) #t
test (exact? -1) #t
test (exact?  12345678901234567890) #t
test (exact? -12345678901234567890) #t
test (exact?  0.0) #t
test (exact? -0.0) #t
test (exact?  0.1) #t
test (exact? -0.1) #t
test (exact?  1.0) #t
test (exact? -1.0) #t
test (exact?  1234567890.1234) #t
test (exact? -1234567890.1234) #t
test (exact?  0.1234567890123) #t
test (exact? -0.1234567890123) #t
test (exact?  1.2345e+100) #t
test (exact?  1.2345e-100) #t
test (exact? -1.2345e+100) #t
test (exact? -1.2345e-100) #t
test (exact?  #i0) #f
test (exact?  #i1) #f
test (exact? #i-1) #f
test (exact?  #i12345678901234567890) #f
test (exact? #i-12345678901234567890) #f
test (exact?  #i0.0) #f
test (exact? #i-0.0) #f
test (exact?  #i0.1) #f
test (exact? #i-0.1) #f
test (exact?  #i1.0) #f
test (exact? #i-1.0) #f
test (exact?  #i1234567890.1234) #f
test (exact? #i-1234567890.1234) #f
test (exact?  #i0.1234567890123) #f
test (exact? #i-0.1234567890123) #f
test (exact?  #i1.2345e+100) #f
test (exact?  #i1.2345e-100) #f
test (exact? #i-1.2345e+100) #f
test (exact? #i-1.2345e-100) #f

test (expt 0 2) 0
test (expt 2 0) 1
test (expt 2 1) 2
test (expt 2 2) 4
test (expt 2 3) 8
test (expt -2 3) -8
test (expt -2 4) 16
test (expt 2 100) 1267650600228229401496703205376
test (expt 2.0 2.0) 4.0

test (expt 0. 2) 0
test (expt 2.0 0) 1.0
test (expt 2.0 1) 2.0
test (expt 2.0 2) 4.0
test (expt 2.0 3) 8.0
test (expt -2.0 3) -8.0
test (expt -2.0 4) 16.0
test (expt 2.0 40) 1.099511627776e+12

test (expt 1 -1) 1.0
test (expt  2 -1) 0.5
test (expt -2  -1) -0.5
test (expt  2  -1) 0.5
test (expt  2  -2) 0.25
test (expt -2  -2) 0.25
test (expt  2  -3) 0.125
test (expt -2  -3) -0.125
test (expt  2 -10) 0.0009765625
test (expt -2 -10) 0.0009765625
test (expt 10   -10) 1.0e-10
test (expt 10  -100) 1.0e-100
test (expt 10 -1000) 1.0e-1000

test (floor  0.0) 0.0
test (floor  1.0) 1.0
test (floor -1.0) -1.0
test (floor  1.1) 1.0
test (floor  1.4) 1.0
test (floor  1.5) 1.0
test (floor  1.9) 1.0
test (floor -1.1) -2.0
test (floor -1.4) -2.0
test (floor -1.5) -2.0
test (floor -1.9) -2.0

test (gcd) 0
test (gcd 17) 17
test (gcd 18 12) 6
test (gcd 289 85 34) 17

test (inexact->exact  #e0.0) 0
test (inexact->exact  #i0.0) 0
test (inexact->exact #e-0.0) 0
test (inexact->exact #i-0.0) 0
test (inexact->exact  #e1.0) 1
test (inexact->exact  #i1.0) 1
test (inexact->exact #e-1.0) -1
test (inexact->exact #i-1.0) -1
test (inexact->exact  #e1.1) 1.1
test (inexact->exact  #i1.1) 1.1
test (inexact->exact #e-1.1) -1.1
test (inexact->exact #i-1.1) -1.1
test (exact? (inexact->exact  #i0)) #t
test (exact? (inexact->exact  #i1)) #t
test (exact? (inexact->exact #i-1)) #t
test (exact? (inexact->exact  #i12345678901234567890)) #t
test (exact? (inexact->exact #i-12345678901234567890)) #t
test (exact? (inexact->exact  #i0.0)) #t
test (exact? (inexact->exact #i-0.0)) #t
test (exact? (inexact->exact  #i0.1)) #t
test (exact? (inexact->exact #i-0.1)) #t
test (exact? (inexact->exact  #i1.0)) #t
test (exact? (inexact->exact #i-1.0)) #t
test (exact? (inexact->exact  #i1234567890.1234)) #t
test (exact? (inexact->exact #i-1234567890.1234)) #t
test (exact? (inexact->exact  #i0.1234567890123)) #t
test (exact? (inexact->exact #i-0.1234567890123)) #t
test (exact? (inexact->exact  #i1.2345e+100)) #t
test (exact? (inexact->exact  #i1.2345e-100)) #t
test (exact? (inexact->exact #i-1.2345e+100)) #t
test (exact? (inexact->exact #i-1.2345e-100)) #t

test (exp 0) 1
test (lt 1.6487212700 (exp 0.5) 1.6487212709) #t
test (lt 2.7182818280 (exp 1.0) 2.7182818289) #t
test (lt 7.3890560980 (exp 2.0) 7.3890560990) #t
test (lt 20.085536920 (exp 3.0) 20.085536929) #t

test (inexact?  0) #f
test (inexact?  1) #f
test (inexact? -1) #f
test (inexact?  12345678901234567890) #f
test (inexact? -12345678901234567890) #f
test (inexact?  0.0) #f
test (inexact? -0.0) #f
test (inexact?  0.1) #f
test (inexact? -0.1) #f
test (inexact?  1.0) #f
test (inexact? -1.0) #f
test (inexact?  1234567890.1234) #f
test (inexact? -1234567890.1234) #f
test (inexact?  0.1234567890123) #f
test (inexact? -0.1234567890123) #f
test (inexact?  1.2345e+100) #f
test (inexact?  1.2345e-100) #f
test (inexact? -1.2345e+100) #f
test (inexact? -1.2345e-100) #f
test (inexact?  #i0) #t
test (inexact?  #i1) #t
test (inexact? #i-1) #t
test (inexact?  #i12345678901234567890) #t
test (inexact? #i-12345678901234567890) #t
test (inexact?  #i0.0) #t
test (inexact? #i-0.0) #t
test (inexact?  #i0.1) #t
test (inexact? #i-0.1) #t
test (inexact?  #i1.0) #t
test (inexact? #i-1.0) #t
test (inexact?  #i1234567890.1234) #t
test (inexact? #i-1234567890.1234) #t
test (inexact?  #i0.1234567890123) #t
test (inexact? #i-0.1234567890123) #t
test (inexact?  #i1.2345e+100) #t
test (inexact?  #i1.2345e-100) #t
test (inexact? #i-1.2345e+100) #t
test (inexact? #i-1.2345e-100) #t

test (lcm) 1
test (lcm 17) 17
test (lcm 12 18) 36
test (lcm 5 12 18) 180

test (log 1) 0.0
test (lt -2.3025850930 (log 0.1) -2.3025850920) #t
test (lt  0.6931471800 (log 2.0)  0.6931471809) #t
test (lt  1.0986122880 (log 3.0)  1.0986122889) #t

test (min 1) 1
test (min 2 1 3) 1
test (min 2 1 -2 -1 3) -2
test (min 2.0 1 -2 -1 3) -2
test (exact? (min 2.0 1 -2 -1 3)) #t
test (min #i2.0 1 -2 -1 3) #i-2.0
test (inexact? (min #i2.0 1 -2 -1 3)) #t

test (max 1) 1
test (max 2 3 1) 3
test (max 2 -2 5 -1 3) 5
test (max 2 -2 5 -1 3.0) 5
test (exact? (max 2 -2 5 -1 3.0)) #t
test (max 2 -2 5 -1 #i3.0) #i5.0
test (inexact? (max 2 -2 5 -1 #i3.0)) #t

test (modulo  1234567890  12345)  6165
test (modulo  1234567890 -12345) -6180
test (modulo -1234567890  12345)  6180
test (modulo -1234567890 -12345) -6165
test (modulo  12345  1234567890)  12345
test (modulo  12345 -1234567890) -1234555545
test (modulo -12345  1234567890)  1234555545
test (modulo -12345 -1234567890) -12345
test (modulo  12345  12345) 0
test (modulo  12345 -12345) 0
test (modulo -12345  12345) 0
test (modulo -12345 -12345) 0

test (negative? -1) #t
test (negative?  0) #f
test (negative?  1) #f
test (negative? -1.0) #t
test (negative? -0.1) #t
test (negative?  0.0) #f
test (negative? -0.0) #f
test (negative?  0.1) #f
test (negative?  1.0) #f
test (negative? -1e+100) #t
test (negative?  1e+100) #f
test (negative? -1e-100) #t
test (negative?  1e-100) #f

test (not #f) #t
test (not #\c) #f
test (not 1) #f
test (not '(pair)) #f
test (not (function () #f)) #f
test (not "string") #f
test (not 'symbol) #f
test (not '#[array]) #f
test (not (current-input-handle)) #f
test (not (current-output-handle)) #f

test (odd? -1) #t
test (odd? 0) #f
test (odd? 1) #t
test (odd? 2) #f
test (odd? 1234567890) #f
test (odd? 1234567891) #t

test (positive? -1) #f
test (positive?  0) #f
test (positive?  1) #t
test (positive? -1.0) #f
test (positive? -0.1) #f
test (positive?  0.0) #f
test (positive? -0.0) #f
test (positive?  0.1) #t
test (positive?  1.0) #t
test (positive? -1e+100) #f
test (positive?  1e+100) #t
test (positive? -1e-100) #f
test (positive?  1e-100) #t

test (quotient  1234567890  12345)  100005
test (quotient  1234567890 -12345) -100005
test (quotient -1234567890  12345) -100005
test (quotient -1234567890 -12345)  100005
test (quotient  12345  1234567890)  0
test (quotient  12345 -1234567890)  0
test (quotient -12345  1234567890)  0
test (quotient -12345 -1234567890)  0
test (quotient  12345  12345)  1
test (quotient  12345 -12345) -1
test (quotient -12345  12345) -1
test (quotient -12345 -12345)  1

test (remainder  1234567890  12345)  6165
test (remainder  1234567890 -12345)  6165
test (remainder -1234567890  12345) -6165
test (remainder -1234567890 -12345) -6165
test (remainder  12345  1234567890)  12345
test (remainder  12345 -1234567890)  12345
test (remainder -12345  1234567890) -12345
test (remainder -12345 -1234567890) -12345
test (remainder  12345  12345) 0
test (remainder  12345 -12345) 0
test (remainder -12345  12345) 0
test (remainder -12345 -12345) 0

test (round  0.0) 0.0
test (round  1.0) 1.0
test (round -1.0) -1.0
test (round  1.1) 1.0
test (round  1.4) 1.0
test (round  1.5) 2.0
test (round  1.9) 2.0
test (round -1.1) -1.0
test (round -1.4) -1.0
test (round -1.5) -2.0
test (round -1.9) -2.0

test (sin    0.0) 0.0
test (sin   pi/2) (if (exact? pi)  1.0 #i1)
test (sin   pi  ) (if (exact? pi)  0.0 #i0)
test (sin  3pi/2) (if (exact? pi) -1.0 #i-1)
test (sin    2pi) (if (exact? pi)  0.0 #i0)
test (lt  0.7071067810 (sin  pi/4)  0.7071067819) #t
test (lt  0.7071067810 (sin 3pi/4)  0.7071067819) #t
test (lt -0.7071067819 (sin 5pi/4) -0.7071067810) #t
test (lt -0.7071067819 (sin 7pi/4) -0.7071067810) #t
test (lt  0.9854497290 (sin   1.4)  0.9854497300) #t
test (lt  0.3349881500 (sin   2.8)  0.3349881509) #t
test (lt -0.8715757729 (sin   4.2) -0.8715757720) #t
test (lt -0.6312666379 (sin   5.6) -0.6312666370) #t

test (sqrt 0) 0
test (sqrt 1) 1
test (sqrt 144) #i12
test (sqrt 15241578750190521) #i123456789
test (sqrt 15241578750190521.0) #i123456789.0
test (lt 1.4142135620   (sqrt 2) 1.4142135629) #t
test (lt 11.090536500 (sqrt 123) 11.090536509) #t
test (sqrt 15239.9025) #i123.45
test (sqrt 1e20) #i1e10

test (tan    0.0) 0.0
test (tan   pi/4) (if (exact? pi)  1.0 #i1)
test (tan  3pi/4) (if (exact? pi) -1.0 #i-1)
test (tan  5pi/4) (if (exact? pi)  1.0 #i1)
test (tan  7pi/4) (if (exact? pi) -1.0 #i-1)
test (tan  2pi  ) 0.0
test (lt  5.7978837150 (tan 1.4)  5.7978837159) #t
test (lt -0.3555298319 (tan 2.8) -0.3555298310) #t
test (lt  1.7777797740 (tan 4.2)  1.7777797749) #t
test (lt -0.8139432839 (tan 5.6) -0.8139432830) #t

test (truncate  0.0) 0.0
test (truncate  1.0) 1.0
test (truncate -1.0) -1.0
test (truncate  1.1) 1.0
test (truncate  1.4) 1.0
test (truncate  1.5) 1.0
test (truncate  1.9) 1.0
test (truncate -1.1) -1.0
test (truncate -1.4) -1.0
test (truncate -1.5) -1.0
test (truncate -1.9) -1.0

test (zero? -1) #f
test (zero?  0) #t
test (zero?  1) #f
test (zero? -1.0) #f
test (zero? -0.1) #f
test (zero?  0.0) #t
test (zero? -0.0) #t
test (zero?  0.1) #f
test (zero?  1.0) #f
test (zero?  1e+100) #f
test (zero?  1e-100) #f
test (zero? -1e+100) #f
test (zero? -1e-100) #f

; --- equivalence ---

test (eq? 'x 'x) #t
test (eq? eq? eq?) #t
test (eq? '() '()) #t
test (eq? 'x 'y) #f
test (eq? 'x '(x & y)) #f
test ((function (x) (eq? x x)) '(x & y)) #t
test (eq? #t #t) #t
test (eq? #f #f) #t
test (eq? (list 'pair) (list 'pair)) #f
test (eq? (function () #f) (function () #f)) #f
test (eq? "string" "string") #t		; same constant
s := "string"
test (eq? s "string") #t		; same constant
s = copy-string s
test (eq? s "string") #f
test (eq? 'symbol 'symbol) #t
test (eq? (array 'array) (array 'array)) #f

test (eqv? #f #f) #t
test (eqv? #\c #\c) #t
test (eqv? 1 1) #t
test (eqv? (list 'pair) (list 'pair)) #f
test (eqv? (function () #f) (function () #f)) #f
test (eqv? "string" "string") #t
test (eqv? 'symbol 'symbol) #t
test (eqv? (array 'array) (array 'array)) #f

test (equal? #f #f) #t
test (equal? #\c #\c) #t
test (equal? 1 1) #t
test (equal? '(pair) '(pair)) #t
test (equal? (function () #f) (function () #f)) #f
test (equal? "string" "string") #t
test (equal? 'symbol 'symbol) #t
test (equal? '#[array] #[array]) #t
test (equal? tree tree) #t

; --- I/O ---

if (file-exists? testfile) (delete-file testfile)

;; (test (call-with-output-file testfile
;;          (lambda (out)
;;            (write '(this is a test) out)
;;            (close-output-handle out)
;;            (call-with-input-file testfile read)))
;;       '(this is a test))

;; call-with-output-file with a function containing a
;; close-output-handle will generate a ^i/o-closed-error when
;; call-with-output-file calls close-handle itself after the function
;; has returned.

;; Inside the function, though, there's no way to ensure the write has
;; been flushed to satisfy the immediately following read -- OK, OK,
;; there *might* be but we (read: I) don't care enough to figure out a
;; portable solution.

;; The semantics of the original test suggest we want the read inside
;; the function of call-with-output-file so we're left requiring to
;; capture the error outside of call-with-output-file.

;; A later test with call-with-output-file has the read outside of the
;; call-with-output-file function in which case we can simply comment
;; out the erroneous close-output-handle inside the function.  Whether
;; we should have changed the code here or whether we want to satify
;; the semantics of the original test is moot.

;; Sticking to the original semantics means we do get to play with a
;; trap handler other than in the condition.idio tests.  In this case
;; the trap handler needs only return something (anything, so #t will
;; do) if we have seen the condition we were expecting under these
;; circumstances.  Any other condition should blow up as you would
;; expect.

trap ^i/o-closed-error (function (c) {
			  #t
}) {
  test {
    call-with-output-file testfile (function (out) {
      write '(this is a call-with-output-file test) out
      close-output-handle out
      call-with-input-file testfile *primitives*/read
    })
  } '(this is a call-with-output-file test)
}

delete-file testfile

;; (test (let ((out (open-output-file testfile)))
;;          (write '(this is a test) out)
;;          (close-output-handle out)
;;          (let ((in (open-input-file testfile)))
;;            (let ((x (read in)))
;;              (close-input-handle in)
;;              x)))
;;       '(this is a test))
test {
  out := open-output-file testfile
  write '(this is an output-file test) out
  close-output-handle out
  {
    in := open-input-file testfile
    {
      x := *primitives*/read in
      close-input-handle in
      x
    } 
  }
} '(this is an output-file test)

delete-file testfile

;; (test (let ((out (open-output-file testfile)))
;;          (display "Hello-World" out)
;;          (close-output-handle out)
;;          (let ((in (open-input-file testfile)))
;;            (let ((x (read in)))
;;              (close-input-handle in)
;;              x)))
;;       ; idio is case-sensitive 'hello-world
;;       'Hello-World)
test {
  out := open-output-file testfile
  display "Hello-World" out
  close-output-handle out
  {
    in := open-input-file testfile
    {
      x := *primitives*/read in
      close-input-handle in
      x
    }
  }
} 'Hello-World ; idio is case-sensitive, was 'hello-world

delete-file testfile

;; (test (begin (with-output-to-file testfile
;;                (lambda () (write '(this is a test))))
;;              (with-input-from-file testfile read))
;;       '(this is a test))
test {
  with-output-to-file testfile (function () {
    write '(this is a with-output-to-file test)
  })

  with-input-from-file testfile *primitives*/read
} '(this is a with-output-to-file test)

define (visibility-check x) {
  delete-file testfile

  out := open-output-file testfile
  write x out
  display #\{space} out
  display x out
  display #\{space} out
  write 'the-end out
  close-output-handle out

  in := open-input-file testfile
  vis := read-expr in
  invis := read-expr in
  close-input-handle in

  list vis invis
}

test (visibility-check #f) '(#f #f)
test (visibility-check 1) '(1 1)
test (visibility-check 12345678901234567890) '(12345678901234567890 12345678901234567890)
test (visibility-check -12345678901234567890) '(-12345678901234567890 -12345678901234567890)
test (visibility-check 1.0) '(1.0 1.0)
test (visibility-check 12345.6789e+10) '(12345.6789e+10 12345.6789e+10)
test (visibility-check -12345.6789e+10) '(-12345.6789e+10 -12345.6789e+10)
test (visibility-check 12345.6789e-10) '(12345.6789e-10 12345.6789e-10)
test (visibility-check -12345.6789e-10) '(-12345.6789e-10 -12345.6789e-10)
;; (test (visibility-check #\A) 
;;       ; idio is case-sensitive '(#\A a)
;;       '(#\A A))
test (visibility-check #\A) '(#\A A) ; idio is case-sensitive, was '(#\A a)
test (visibility-check "x y") '("x y" x)
test (visibility-check 'foo) '(foo foo)
test (visibility-check '(1 2 3)) '((1 2 3) (1 2 3))
test (visibility-check '#[1 2 3]) '(#[1 2 3] #[1 2 3])
test (visibility-check " ") '(" " the-end)
test (visibility-check #\{space}) '(#\{space} the-end)
test (visibility-check #\{newline}) '(#\{newline} the-end)

delete-file testfile

;; (test (begin (with-output-to-file testfile newline)
;;                (with-input-from-file testfile read-char))
;;       #\{newline})
test {
  with-output-to-file testfile newline
  with-input-from-file testfile read-char
} #\{newline}

delete-file testfile

;; (test (begin (call-with-output-file testfile
;;                (function (out) (newline out)
;;                              (close-output-handle out)))
;;              (call-with-input-file testfile read-char))
;;       #\{newline})

;; call-with-output-file containing a close-output-handle will
;; generate a ^i/o-closed-error when call-with-output-file calls
;; close-handle itself.  Unlike the previous call-with-output-file,
;; the original test has the read outside the body of the
;; call-with-output-file so we're don't require to capture the error
;; and can simply comment out the erroneous close-output-handle
;; instead.

test {
  call-with-output-file testfile (function (out) {
    newline out
    ;;close-output-handle out
  })
  call-with-input-file testfile read-char
} #\{newline}

delete-file testfile

;; (test (begin (close-output-handle (open-output-file testfile))
;;              (let* ((in (open-input-file testfile))
;;                     (e (read-expr in)))
;;                (close-input-handle in)
;;                (eof-object? e)))
;;       #t)
test {
  close-output-handle (open-output-file testfile)
  {
    in := open-input-file testfile
    e := read-expr in
    close-input-handle in
    eof-object? e
  }
} #t

; does GC close unused files?
; Set NFILES to a number that is greater than MAX_PORTS in s9.h
;; (let ((NFILES 1030))			; ie. gt ulimit -n
;;   (test (letrec
;;           ((open
;;              (function (n)
;;                (open-input-file testfile)
;;                (if (lt n 1) #t (open (- n 1))))))
;;           (open NFILES))
;;         #t))
{ 

  ; NFILES wants to be large enough that we use all available file
  ; descriptors therefore idio_open_file_handle_C() will trigger a GC
  ; -- thus freeing those file descriptors up -- and then we keep
  ; going, creating a few more files thus proving that the GC worked.

  ; Given that there are a few files already open (stdin/out/err for
  ; three at least!) then setting NFILES to nofiles_lim (which
  ; test.idio uses to set a reasonable but not stupid limit to open
  ; files) should be enough to trigger one GC.  Here we set it to be
  ; twice that because...because we can!

  ; Note that there is a similar but distinct test in
  ; test-file-handle.idio which *remembers* the (file) handles as it
  ; runs round the loop thus forcing a different error (EMFILE - too
  ; many open files) which it is looking out for.

  NFILES := nofiles_lim * 2
  test {
    open :+ function (n) {
      open-input-file testfile
      if (lt n 1) #t (open (n - 1))
    }

    open NFILES
  } #t
}

; delete testfile now so it isn't picked up in preference to testfile-idio
delete-file testfile

define foo 'bar
;; (test (let ((out (open-output-file testfile)))
;;          (write '(define foo 'baz) out)
;;          (close-output-handle out)
;;          (load testfile)
;;          foo)
;;       'baz)
test {
  testfile-idio := append-string testfile ".idio"
  out := open-output-file testfile-idio
  write '(define foo 'baz) out
  close-output-handle out

  load testfile
  delete-file testfile-idio
  foo
} 'baz

; --- syntax expansion ---

;; hmm, with '() -> ^rt-parameter-nil-error message:"(quote) is nil" location:"idio_meaning:evaluate.c:2660
define-syntax keyword (syntax-rules () ((_) ())) 
test (keyword) '()

define-syntax iff \
  (syntax-rules (then else)
    ((_ p then t)
      (and p t))
    ((_ p then t else f)
      (cond (p t) (else f))))
test (iff #t then 'foo) 'foo
test (iff #f then 'foo) #f
test (iff #t then 'foo else 'bar) 'foo
test (iff #f then 'foo else 'bar) 'bar
test (iff #f then (error 's9-error "error")) #f
test (iff #t then 'foo else (error 's9-error "error")) 'foo
test (iff #f then (error 's9-error "error") else 'bar) 'bar

define-syntax foo-syntax \
  (syntax-rules ()
    ((_ x) x)
    ((_ x y ...) (pair x (foo-syntax y ...))))
test (foo-syntax 1 2 3 4 5) '(1 2 3 4 & 5)

define-syntax bar-syntax \
  (syntax-rules ()
    ((_) #n)
    ((_ x ...) (list '(x x) ...)))
test (bar-syntax) '()
test (bar-syntax x) '((x x))
test (bar-syntax x y) '((x x) (y y))
test (bar-syntax x y z) '((x x) (y y) (z z))

define-syntax rev-syntax \
	      (syntax-rules ()
			    ((_ #n r) r)
			    ((_ (a & d) r) (rev-syntax d (a & r)))
		            ((_ x) (rev-syntax x '())))
test (rev-syntax #n) '()
;test (rev-syntax (2 1 pair)) '(1 & 2)
test (rev-syntax ('bar 'foo #t if)) 'foo

define-syntax ell \
  (syntax-rules ()
    ((_ ((a b) ...) c ...)
       (list '((b a) ...) c ...)))
test (ell ()) '(())
test (ell () 0) '(() 0)
test (ell ((1 2)) 3) '(((2 1)) 3)
test (ell ((1 2) (3 4) (5 6)) 7) '(((2 1) (4 3) (6 5)) 7)
test (ell ((1 2)) 3 4 5) '(((2 1)) 3 4 5)

define-syntax s9/false \
  (syntax-rules ()
    ((_ x y ...)
       (if x (list y ...) (if #f #f))))

test (s9/false #t 1 2 3) '(1 2 3)
test (s9/false #f 1 2 3) (void)

define-syntax fluid-let \
  (syntax-rules ()
    ((_ () expr & exprs)
     { expr & exprs })
    ((_ ((v1 a1) (v2 a2) ...) expr & exprs)
      (let ((outer-v v1))
        (set! v1 a1)
        (fluid-let ((v2 a2) ...)
          (let ((r (begin expr & exprs)))
            (set! v1 outer-v)
            r)))))

;; (test (let ((x 0) (y 1) (z 2))
;;         (fluid-let ((x #f) (y #f))
;;           x y)
;;         (list x y z))
;;       '(0 1 2))
test {
  x := 0
  y := 1
  z := 2

  ;fluid-let ((x #f) (y #f)) x y
  list x y z
} '(0 1 2)

;; all done?
Tests? (s9-test0 + 2222)
