;;
;; Copyright (c) 2021 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; test-libc-wrap.idio
;;
module tests/libc-wrap
import libc

libc-wrap0 := Tests

define (number-cmp low high) {
  if (not (eqv? low high)) {
    test (C/< low high) #t
    test (C/< high low) #f
    test (C/<= low high) #t
    test (C/<= high low) #f
    test (C/<= high high) #t
    test (C/== high high) #t
    test (C/== low high) #f
    test (C/> low high) #f
    test (C/> high low) #t
    test (C/>= low high) #f
    test (C/>= high low) #t
    test (C/>= high high) #t
  } {
    test (C/== low high) #t
  }
}
;; numbers

;; quick type tests of the primitively-definied INTMAX_MAX and the
;; locally defined intmax-max
test (C/int? INTMAX_MAX) #t
intmax-max := INTMAX_MAX
test (C/int? intmax-max) #t

;; comparison tests vs. 0
number-cmp (C/integer-> 0) INTMAX_MAX
number-cmp INTMAX_MIN (C/integer-> 0)

;; comparison tests vs lim-1
INTMAX_MAX-1 := C/integer-> ((C/->integer INTMAX_MAX) - 1)
number-cmp INTMAX_MAX-1 INTMAX_MAX

;; comparison tests vs lim+1
INTMAX_MIN+1 := C/integer-> ((C/->integer INTMAX_MIN) + 1)
number-cmp INTMAX_MIN INTMAX_MIN+1

;; overflow conversion tests -- one beyond the C MAX/MIN
trap ^rt-bignum-conversion-error (function (c) {
				    ;; eprintf "bignum INTMAX_MAX+1 conversion error: %s\n" c
				    test (rt-bignum-conversion-error? c) #t
				    #f
}) {
  INTMAX_MAX+1 := (C/integer-> ((C/->integer INTMAX_MAX) + 1))
  test INTMAX_MAX+1 #f
  ;; printf "INTMAX_MAX+1 %s %s\n" INTMAX_MAX INTMAX_MAX+1
}

trap ^rt-bignum-conversion-error (function (c) {
				    ;; eprintf "bignum INTMAX_MIN-1 conversion error: %s\n" c
				    test (rt-bignum-conversion-error? c) #t
				    #f
}) {
  INTMAX_MIN-1 := (C/integer-> ((C/->integer INTMAX_MIN) - 1))
  test INTMAX_MIN-1 #f
  ;; printf "INTMAX_MIN-1 %s %s\n" INTMAX_MIN INTMAX_MIN-1
}

;; overflow conversion tests -- many beyond the C MAX/MIN
trap ^rt-bignum-conversion-error (function (c) {
				    ;; eprintf "bignum INTMAX_MAX+1 conversion error: %s\n" c
				    test (rt-bignum-conversion-error? c) #t
				    #f
}) {
  INTMAX_MAX+1 := (C/integer-> ((C/->integer INTMAX_MAX) * 100000))
  test INTMAX_MAX+1 #f
  ;; printf "INTMAX_MAX+1 %s %s\n" INTMAX_MAX INTMAX_MAX+1
}

trap ^rt-bignum-conversion-error (function (c) {
				    ;; eprintf "bignum INTMAX_MIN-1 conversion error: %s\n" c
				    test (rt-bignum-conversion-error? c) #t
				    #f
}) {
  INTMAX_MIN-1 := (C/integer-> ((C/->integer INTMAX_MIN) * 100000))
  test INTMAX_MIN-1 #f
  ;; printf "INTMAX_MIN-1 %s %s\n" INTMAX_MIN INTMAX_MIN-1
}

;; code coverage
rus := (getrusage RUSAGE_SELF)
ru-ut := struct-rusage-ru_utime rus
ru-st := struct-rusage-ru_stime rus

struct-timeval-as-string ru-ut

;; time tickles the struct-timeval adding/subtracting code
OTIMEFORMAT := TIMEFORMAT
TIMEFORMAT = ""
;; while we're here, sleep return a C-uint which is a code coverage
;; issue itself
time sleep (sleep 0)
TIMEFORMAT = OTIMEFORMAT

;; NB 0 is a fixnum for code coverage
nfd := dup 0
close nfd

;; Sorry, fd 99
;; NB 99 is a C-int for code coverage
nfd := dup2 0 (C/integer-> 99)
close nfd

;; NB 99 is a C-int for code coverage
nfd := fcntl 0 F_DUPFD (C/integer-> 99)
close nfd

(cond-expand
 (F_DUPFD_CLOEXEC {
   ;; NB 99 is a fixnum for code coverage
   nfd := fcntl 0 F_DUPFD_CLOEXEC 99
   close nfd

   ;; NB 99 is a C-int for code coverage
   nfd := fcntl 0 F_DUPFD_CLOEXEC (C/integer-> 99)
   close nfd
 })
 (else {
   printf "no F_DUPFD_CLOEXEC on this system, skipping\n"
 }))

;; get the file descriptor flags -- CLOEXEC?
fd-flags := fcntl 0 F_GETFD

fcntl 0 F_SETFD fd-flags

(getpgrp)

;; I sometimes run the tests with redirected I/O
trap ^system-error (function (c) {
		      #t
}) {
  isatty (C/integer-> 0)
}

kill (C/integer-> PID) (C/integer-> 0)

;; test mkdir(2) for which we need a directory we can mkdir safely --
;; how about a random one we just deleted?
tmpdir := (make-tmp-dir)
rmdir tmpdir
mkdir tmpdir (C/integer-> #o555)
rmdir tmpdir

;; test read with a C-int count -- a lot of work for code coverage!
ofh := open-output-file testfile
hprintf ofh "hello\n"
close-handle ofh

ifh := open-input-file testfile
test (read (fileno ofh) (C/integer-> 2)) "he"
close-handle ifh

;; should be safe...
setpgid (getpid) (getpgrp)

;; should be safe...
signal SIGUSR1 (signal-handler SIGUSR1)

strerror EPERM
strerror (C/->integer EPERM)

strsignal SIGHUP

;; should be safe to set the termios of stdin to stdin...
(cond-expand
 (uname/sysname/SunOS {
   eprintf "SunOS: skipping tcsetattr *stdin* test\n"
 })
 (else {
   tcsetattr (C/integer-> 0) (C/integer-> 0) (tcgetattr (C/integer-> 0))
 }))

;; should be safe...
tcsetpgrp (C/integer-> 0) (tcgetpgrp (C/integer-> 0))

(times)

(uname)

ofh := open-output-file testfile
test (write (fileno ofh) "hello\n") 6
close-handle ofh

sig-name SIGHUP

(sig-names)
(signal-names)

errno-name EPERM
(errno-names)
strerrno EPERM

sprintf "%s" errno

(rlimit-names)

EGID = (C/->integer EGID)		; fixnum
EGID = EGID				; C-int

EUID = (C/->integer EUID)		; fixnum
EUID = EUID				; C-int

GID = (C/->integer GID)			; fixnum
GID = GID				; C-int

UID = (C/->integer UID)			; fixnum
UID = UID				; C-int

linkfile := "__link__"
ln -s testfile linkfile
; block special devices?
test (b? "/dev/tty") #f
test (b? ".")        #f
test (b? testfile)   #f
test (b? linkfile)   #f

test (c? "/dev/tty") #t
test (c? ".")	     #f
test (c? testfile)   #f
test (c? linkfile)   #f

test (d? "/dev/tty") #f
test (d? ".")	     #t
test (d? testfile)   #f
test (d? linkfile)   #f

test (e? "/dev/tty") #t
test (e? ".")	     #t
test (e? testfile)   #t
test (e? linkfile)   #t

test (f? "/dev/tty") #f
test (f? ".")	     #f
test (f? testfile)   #t
test (f? linkfile)   #t

(cond-expand
 (uname/sysname/SunOS {
   ;; symlink on SunOS
   test (l? "/dev/tty") #t
 })
 (else {
   test (l? "/dev/tty") #f
 }))
test (l? ".")	     #f
test (l? testfile)   #f
test (l? linkfile)   #t

test (p? "/dev/tty") #f
test (p? ".")	     #f
test (p? testfile)   #f
test (p? linkfile)   #f

test (r? "/dev/tty") #t
test (r? ".")	     #t
test (r? testfile)   #t
test (r? linkfile)   #t

test (s? "/dev/tty") #f
test (s? ".")	     #f
test (s? testfile)   #f
test (s? linkfile)   #f

test (w? "/dev/tty") #t
test (w? ".")	     #t
test (w? testfile)   #t
test (w? linkfile)   #t

(cond-expand
 (uname/sysname/FreeBSD {
   ;; crw--w----  1 idf  tty  0x5a Jan 30 13:10 /dev/tty
   ;; tests for X_OK
   test (x? "/dev/tty") #t
 })
 (else {
   test (x? "/dev/tty") #f
 }))
test (x? ".")	     #t
test (x? testfile)   #f
test (x? linkfile)   #f

;; if someone has redirected stdin...
t? (stdin-fileno)

rm -f linkfile

;; STDIN/STDOUT/STDERR are computed values in libc (not exported)
module libc

test STDIN (current-input-handle)
test STDOUT (current-output-handle)
test STDERR (current-error-handle)

;; go back otherwise libc-wrap0 doesn't exist!
module tests/libc-wrap

;; all done?
Tests? (libc-wrap0 + 107)
