;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; test-unicode.idio
;;
unicode-test0 := Tests
import unicode
;;
;; Idio tests - ported from
;;
; Scheme 9 from Empty Space
; Test Suite
; By Nils M Holm, 2007, 2008, 2009

;  This is a comment

test (unicode? #f) #f
test (unicode? #\c) #t
test (unicode? #U+61) #t
test (unicode? #U+0061) #t
test (unicode? 1) #f
test (unicode? 0.1) #f
test (unicode? '(pair)) #f
test (unicode? (function () #f)) #f
test (unicode? "string") #f
test (unicode? 'symbol) #f
test (unicode? '#[array]) #f
test (unicode? (current-input-handle)) #f
test (unicode? (current-output-handle)) #f

; --- conversion procedures ---

test (unicode->integer #\A) 65
test (unicode->integer #\z) 122
test (unicode->integer #\{newline}) 10
test (unicode->integer #\{space}) 32

test (integer->unicode 65) #\A
test (integer->unicode 122) #\z
test (integer->unicode 10) #\{newline}
test (integer->unicode 32) #\{space}
test (integer->unicode 65.0) #\A

; --- chars ---

test (unicode-alphabetic? #\a) #t
test (unicode-alphabetic? #\A) #t
test (unicode-alphabetic? #\z) #t
test (unicode-alphabetic? #\Z) #t
test (unicode-alphabetic? #\@) #f
test (unicode-alphabetic? #\[) #f
test (unicode-alphabetic? #\`) #f
test (unicode-alphabetic? #\{lbrace}) #f
test (unicode-alphabetic? #\{{}) #f

test (unicode-downcase #\a) #\a
test (unicode-downcase #\A) #\a
test (unicode-downcase #\z) #\z
test (unicode-downcase #\Z) #\z
test (unicode-downcase #\@) #\@
test (unicode-downcase #\[) #\[
test (unicode-downcase #\`) #\`
test (unicode-downcase #\{lbrace}) #\{lbrace}
test (unicode-downcase #\{lbrace}) #\{{}
test (unicode-downcase #\{{}) #\{{}
test (unicode-downcase #\{{}) #\{lbrace}

test (unicode-lower-case? #\a) #t
test (unicode-lower-case? #\A) #f
test (unicode-lower-case? #\z) #t
test (unicode-lower-case? #\Z) #f
test (unicode-lower-case? #\@) #f
test (unicode-lower-case? #\[) #f
test (unicode-lower-case? #\`) #f
test (unicode-lower-case? #\{lbrace}) #f
test (unicode-lower-case? #\{{}) #f

test (unicode-numeric? #\0) #t
test (unicode-numeric? #\9) #t
test (unicode-numeric? #\/) #f
test (unicode-numeric? #\:) #f

test (unicode-upcase #\a) #\A
test (unicode-upcase #\A) #\A
test (unicode-upcase #\z) #\Z
test (unicode-upcase #\Z) #\Z
test (unicode-upcase #\@) #\@
test (unicode-upcase #\[) #\[
test (unicode-upcase #\`) #\`
test (unicode-upcase #\{lbrace}) #\{lbrace}
test (unicode-upcase #\{lbrace}) #\{{}
test (unicode-upcase #\{{}) #\{{}
test (unicode-upcase #\{{}) #\{lbrace}

test (unicode-upper-case? #\a) #f
test (unicode-upper-case? #\A) #t
test (unicode-upper-case? #\z) #f
test (unicode-upper-case? #\Z) #t
test (unicode-upper-case? #\@) #f
test (unicode-upper-case? #\[) #f
test (unicode-upper-case? #\`) #f
test (unicode-upper-case? #\{lbrace}) #f
test (unicode-upper-case? #\{{}) #f

test (unicode-whitespace? #\0) #f
test (unicode-whitespace? #\9) #f
test (unicode-whitespace? #\a) #f
test (unicode-whitespace? #\z) #f
test (unicode-whitespace? #\ ) #t
test (unicode-whitespace? #\{space}) #t
test (unicode-whitespace? #\{newline}) #t
test (unicode-whitespace? (integer->unicode 9)) #t
test (unicode-whitespace? (integer->unicode 10)) #t
test (unicode-whitespace? (integer->unicode 12)) #t
test (unicode-whitespace? (integer->unicode 13)) #t

test (unicode=? #\+ #\+) #t
test (unicode=? #\+ #\-) #f
test (unicode=? #\A #\A) #t
test (unicode=? #\A #\a) #f
test (unicode=? #\a #\A) #f
test (unicode=? #\a #\a) #t
test (unicode=? #\A #\Z) #f
test (unicode=? #\A #\z) #f
test (unicode=? #\a #\Z) #f
test (unicode=? #\a #\z) #f
test (unicode=? #\Z #\A) #f
test (unicode=? #\Z #\a) #f
test (unicode=? #\z #\A) #f
test (unicode=? #\z #\a) #f
test (unicode=? #\a #\a #\a) #t
test (unicode=? #\a #\a #\b #\a) #f

; --- strings ---

define (string-downcase s) {
  apply string (map unicode-downcase (string->list s))
}

test (string-downcase (number->string 11259375 16)) "abcdef"
test (string-downcase (number->string +11259375 16)) "abcdef"
test (string-downcase (number->string -11259375 16)) "-abcdef"

define (with-range lo hi fn) {
  if (lt hi lo) '() {
    pair (fn lo) (with-range (1 + lo) hi fn)
  }
}

test {
  call-with-output-file testfile (function (out) {
    with-range 32 126 (function (x) {
      write-char (integer->unicode x) out
      integer->unicode x
    })
  })
} (with-range 32 126 integer->unicode)

define (while-not-eof input fn) {
  c := fn input
  if (eof-object? c) '() {
    pair c (while-not-eof input fn)
  }
}

;; (test (let ((in (open-input-file testfile)))
;;          (while-not-eof in read-char))
;;       (with-range 32 126 integer->unicode))
test {
  in := open-input-file testfile
  while-not-eof in read-char
} (with-range 32 126 integer->unicode)

;; (test (let ((in (open-input-file testfile)))
;;          (let ((c (peek-char in)))
;;            (pair c (while-not-eof in read-char))))
;;        (pair #\{space} (with-range 32 126 integer->unicode)))
test {
  in := open-input-file testfile
  c := peek-char in
  pair c (while-not-eof in read-char)
} (pair #\{space} (with-range 32 126 integer->unicode))

;; all done?
test (unicode-test0 + 108) Tests
