;;
;; Copyright (c) 2015, 2020, 2021 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; test-file-handle.idio
;;

module tests/file-handle

file-handle0 := Tests

test (file-handle? 0)				#f ; FIXNUM
test (file-handle? #t)				#f ; CONSTANT
test (file-handle? (integer->char 1))		#f ; CHARACTER (deprecated)
test (file-handle? #\a)				#f ; UNICODE
test (file-handle? "a")				#f ; STRING
test (file-handle? 'a)				#f ; SYMBOL
test (file-handle? :a)				#f ; KEYWORD
test (file-handle? (pair 1 2))			#f ; PAIR
test (file-handle? #[])				#f ; ARRAY
test (file-handle? #{})				#f ; HASH
test (file-handle? (function #n #n))		#f ; CLOSURE
test (file-handle? pair)			#f ; PRIMITIVE
test (file-handle? 1.0)				#f ; BIGNUM
test (file-handle? (find-module 'Idio))		#f ; MODULE
test (file-handle? (current-input-handle))	#t ; HANDLE
test (file-handle? ^error)			#f ; STRUCT_TYPE
test (file-handle? libc/idio-uname)		#f ; STRUCT_INSTANCE
test (file-handle? #B{ 3 })			#f ; BITSET
test (file-handle? libc/INTMAX_MAX)		#f ; C_INT
test (file-handle? libc/UINTMAX_MAX)		#f ; C_UINT

test-str := "foo"
test (file-handle? test-str) #f
test (input-file-handle? test-str) #f
test (output-file-handle? test-str) #f

ofh := open-output-file testfile
test (file-handle? ofh) #t
test (output-file-handle? ofh) #t
test (input-file-handle? ofh) #f

fho := "Hello"
write fho ofh
close-handle ofh

test (file-handle? ofh) #t
test (output-file-handle? ofh) #t
test (input-file-handle? ofh) #f

ifh := open-input-file testfile
test (file-handle? ifh) #t
test (input-file-handle? ifh) #t
test (output-file-handle? ifh) #f

fhi := *primitives*/read ifh
close-handle ifh

test (file-handle? ifh) #t
test (input-file-handle? ifh) #t
test (output-file-handle? ifh) #f

test fhi fho

;; use the text read in again
ifh := open-input-file testfile
test (file-handle? ifh) #t
test (input-file-handle? ifh) #t
test (output-file-handle? ifh) #f

;; XXX this is all wrong -- need to remove FILE*

;; seek to the second character of "Hello" , #\e
test (seek-handle ifh 2) 2

test (read-char ifh) #\e
test (peek-char ifh) #\l

; default is SEEK_SET
test (seek-handle ifh 2) 2
test (peek-char ifh) #\e

test (seek-handle ifh -2 'cur) 0
test (peek-char ifh) #\"

test (seek-handle ifh 2 'set) 2
test (peek-char ifh) #\e

test (seek-handle ifh -2 'end) 5
test (peek-char ifh) #\o

rewind-handle ifh
test (peek-char ifh) #\"

test (handle-pos ifh) 0
test (seek-handle ifh 2) 2
test (handle-pos ifh) 2

;; GC and file handles

;; Keep opening a file until we've used up all (per-process) file
;; descriptors -- we retain the handles in an array.

;; Outside of this block the array is no longer in scope and the
;; attempt to open another file should trigger a GC and we're good to
;; go again.
{
  fds := #[ ]
  loop-k := #n
  trap ^system-error (function (c) {
			test (C/== (system-error-errno c) libc/EMFILE) #t
			if (C/== (system-error-errno c) libc/EMFILE) {
                          printf "test file-handle trap: created %d\n" (array-length fds)
                        } {
                          condition-report "test file-handle trap" c (current-error-handle)
                        }
			loop-k 'too-many-open-files
  }) {
    call/cc (function (k) {
	       loop-k = k
	       loop :+ function () {
			 ish := open-input-file testfile
			 fds =+ ish
			 (loop)
	       }

	       (loop)
    })
  }
}

;; fds is now out of scope and should be collectable thus freeing up
;; all those file descriptors
ifh := open-input-file testfile
test (input-file-handle? ifh) #t

; code coverage: "+" modes
ifh = open-file testfile "r+"
test (input-file-handle? ifh) #t
test (output-file-handle? ifh) #t
test (ready? ifh) #t
close-handle ifh

ofh = open-file testfile "w+"
test (output-file-handle? ofh) #t
test (input-file-handle? ofh) #t
test (ready? ofh) #t
close-handle ofh

ofh = open-file testfile "a+"
test (output-file-handle? ofh) #t
test (input-file-handle? ofh) #t
test (ready? ofh) #t
close-handle ofh

;; ready? code coverage!
ofh = open-file testfile "w"
hprintf ofh "hello\n"
close-handle ofh

ifh = open-file testfile "r"
;; buffered byte count code path!
test (read-char ifh) #\h
test (ready? ifh) #t
;; feof code path!
read-line ifh				; stops on the \n -- not yet
					; EOF
test (eof? ifh) #f
test (ready? ifh) #t
read-line ifh				; should have provoked EOF
test (eof? ifh) #t
test (ready? ifh) #t
close-handle ifh
test (eof? ifh) #t

;; trigger some internal buffer (BUFSIZ) flushing with a single
;; character -- technically only the last character counts
ofh = open-file testfile "w"
{
  loop :+ (function (n) {
	     if (n gt 0) {
	       write-char #\A ofh
	       loop (n - 1)
	     } #n
  })

  loop ((C/->integer libc/BUFSIZ) + 1)
}
close-handle ofh

;; trigger some internal buffer (BUFSIZ) flushing with a string
ofh = open-file testfile "w"
hprintf ofh (make-string ((C/->integer libc/BUFSIZ) + 1) #\A)
close-handle ofh

ofh = open-file testfile "w"
hprintf ofh "hello\n"
fflush-file-handle ofh
close-handle ofh

;; trigger a seek -> clear EOF clause
ofh = open-file testfile "w"
hprintf ofh "hello\n"
close-handle ofh

ifh = open-input-file testfile
read-line ifh
test (eof? ifh) #f
read-line ifh				; EOF
test (eof? ifh) #t
test (seek-handle ifh 0) 0
test (eof? ifh) #f
test (string-length (read-line ifh)) 5
close-handle ifh

;; find-lib code coverage
OIDIOLIB := IDIOLIB
IDIOLIB = #t
find-lib "empty"
IDIOLIB = ""
find-lib "empty"
IDIOLIB = ":"
find-lib "empty"
IDIOLIB = OIDIOLIB

find-lib "empty"

;; load code coverage

;; reduce IDIOLIB to the grandparent directory of a known library file

;; (findlib "empty") => ".../lib/empty.idio" from which we want "..."
parts := regexec (regcomp "(.*)/[^/]+/[^/]+$") (find-lib "empty")
IDIOLIB = parts.1

load "lib/empty.idio"
load "lib/empty"

IDIOLIB = OIDIOLIB
;; all done?
Tests? (file-handle0 + 77)
