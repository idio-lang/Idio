
;; dynamic values

;; XXX be careful to use new non-lexical toplevel symbols...

;; have functions ready to test a future dynamic variables
define (test-dynx1 exp) {
  ;; test a regular local
  test exp x

  ;; test the dynamic variable
  test (dynamic dynx1) exp
}

define (test-dynx2 exp) {
  ;; test a regular local
  test exp x

  ;; test the dynamic variable
  test (dynamic dynx2) exp
}

x = 10

;; create a local dynamic variable
dynamic-let (dynx1 x) {
  ;; test it here
  test (dynamic dynx1) x

  ;; test it in our prepared function
  test-dynx1 x
}

;; ^rt-dynamic-variable-unbound-error is raised when calling a
;; function where no such variable is in scope
monitor (function (cont cond) {
  ;; display* "unbound dynamic monitor condition:" (struct-type-name cond)
  test (rt-dynamic-variable-unbound-error? cond) #t
  if cont {
    if (rt-dynamic-variable-unbound-error? cond) {
      name := condition-ref cond 'name

      ;; we know that test-dynx1 in our body was passed x
      x
    } (error "unbound dynamic: unexpected condition" cond)
  } (error "unbound dynamic: unexpected non-continuable error" cond)
}) {
  ;; display* "using unbound dynamic variable"
  test-dynx1 x
}

;; create a toplevel dynamic variable
dynx2 :* 11

;; test it here
test dynx2 11

;; test it in a prepared function
test-dynx2

%%vm-trace 0
%%vm-dis 0
