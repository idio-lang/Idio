;;
;; Copyright (c) 2015 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; command.idio
;;

;; How to test external commands?

;; side-effects?

;; tinker with the PATH
OPATH := PATH
PATH = string-append PATH ":" PWD 

;; to avoid repeating the bulk of the error handler we'll just
;; (re)define the interesting bit, rt-command-status-error-handler or
;; rcseh:
rcseh := #n

monitor (function (cont cond) {
  ;; edisplay* "command tests: monitor" cont cond
  test (rt-command-status-error? cond) #t
  if cont {
    ;; We are deliberately trying to provoke command status errors so
    ;; we should check that the condition is a command status error
    ;; and complain loudly otherwise
    if (rt-command-status-error? cond) {
      ;; Finally we can run our error-specific handler
      rcseh cond
    } {
      edisplay* "command tests: unexpected condition" cond
      raise cont cond
    }
  } {
    edisplay* "command tests: unexpected non-continuable condition" cond
    raise cont cond
  }
}) {

  ;; define some rt-command-status-error-handlers for the conditions
  ;; we are contriving to generate so that we can switch between them
  ;; as we go along

  ;; for exit0 we don't expect this code to be run at all -- hence
  ;; complaining loudly and testing for something that isn't generated
  ;; (spotting an error in the summary is easier to spot)
  exit0 := function (cond) {
    edisplay* "command tests: exit0: unexpected status error" cond
    job := idio-error-location cond
    edisplay* "pipeline:" (%idio-job-pipeline job)
    edisplay* "detail:" (pipeline-detail job)
    test (rt-command-status-error-status cond) 'job-failed
  }

  exit1 := function (cond) {
    ;; edisplay* "command tests: exit1" cond
    job := idio-error-location cond
    test (job-detail job) %T{ (exit $(c/integer-> 1)) }
    rt-command-status-error-status cond
  }

  killed1 := function (cond) {
    ;; edisplay* "command tests: killed1" cond
    job := idio-error-location cond
    test (job-detail job) %T{ (killed $(c/integer-> 1)) }
    rt-command-status-error-status cond
  }

  killed13 := function (cond) {
    ;; edisplay* "command tests: killed13" cond
    job := idio-error-location cond
    test (job-detail job) %T{ (killed $(c/integer-> 13)) }
    rt-command-status-error-status cond
  }

  ;; Testing the tests! 
  ;; 
  ;; We need to be sure that the OOB handlers are successfully kicked
  ;; off (or not kicked off) so we'll have a couple of functions to
  ;; store and check the Tests number has been incremented OOB (in the
  ;; main monitor handler and the rcseh functions above) as we expect.

  ;; Remember, though, the test itself, as written in the rest of this
  ;; block, will increment Tests as well as any potential OOB handler.
  ;; The OOB handler will increment Tests twice: once to check the
  ;; condition is an rt-command-status-error and once in exit1/killed1
  ;; to verify the value of the status.

  test-id := Tests

  ;; test= exists to be sure of resetting test-id
  define (test=) {
    test-id = Tests
  }

  define (test+0) {
    test-cur-n := Tests
    test (test-id + 0) test-cur-n
    test-id = Tests
  }

  define (test+1) {
    test-cur-n := Tests
    test (test-id + 1) test-cur-n
    test-id = Tests
  }

  define (test+2) {
    test-cur-n := Tests
    test (test-id + 2) test-cur-n
    test-id = Tests
  }

  define (test+3) {
    test-cur-n := Tests
    test (test-id + 3) test-cur-n
    test-id = Tests
  }

  rcseh = exit0
  (test=)
  test (auto-exit -e 0) #t
  (test+1)

  rcseh = exit1
  (test=)
  test (auto-exit -e 1) #f
  (test+3)

  rcseh = killed1
  (test=)
  test (auto-exit -k 1) #f
  (test+3)

  rcseh = exit0
  (test=)
  test (auto-exit -w 1) #t
  (test+1)

  ;; backgrounded job
  (test=)
  bg-job auto-exit -s 1

  ;; As the bg-job's purpose is to sleep for one second we can be
  ;; moderately confident that an immediate test here that nothing has
  ;; happened to the number of tests will be OK.  But it is
  ;; technically a race condition as this parent process could have
  ;; been stalled.  YMMV.
  (test+0)

  ;; If we wait for the job to finish we should have...no change as it
  ;; should have exited 0.
  wait %%last-job
  (test+0)

  ;; check the bg-job didn't fail
  test (job-failed %%last-job) #f
  (test+1)

  ;; pipeline
  (test=)
  test (auto-exit -w 1 | auto-exit -r 1) #t
  (test+1)

  ;; In the following test the second command should finish first
  ;; causing a SIGPIPE in the first command.

  ;; However, the likes of gdb conspire to have SIGPIPE sigignore()d
  ;; by children and ultimately auto-exit.  Rather than auto-exit's
  ;; write to the pipe be killed by a SIGPIPE for '(killed 13) we'll
  ;; get an '(exit 1).
  ;;
  ;; There's no obvious way to test for being run under gdb (nor
  ;; anything else that predisposes itself to have children ignore
  ;; SIGPIPE).  All we can usefully do is look at and see if SIGPIPE
  ;; is being ignored and use the appropriate handler.
  ;;
  ;; This doesn't look like art.  Maybe it's contemporary art, then.

  if (c/== (c/signal-handler c/SIGPIPE) c/SIG_IGN) {
    rcseh = exit1
  } {
    rcseh = killed13
  }
  (test=)
  test (auto-exit -w 2 -s 1 | auto-exit -r 1) #f
  edisplay* "??" %%last-job (pipeline-detail %%last-job)
  (test+3)

  ;; pipeline with regular Idio as the writer
  rcseh = exit0
  (test=)
  test (display* "first" | auto-exit -r 1) #t
  (test+1)

  ;; pipeline with the writer not writing anything
  rcseh = exit1
  (test=)
  test (auto-exit -e 0 | auto-exit -r 1) #f
  (test+3)

  ;; bg-job pipeline
  (test=)
  bg-job auto-exit -w 1 | auto-exit -r 1
  ;; no sleep this time so the only safe bet is to wait for the job to
  ;; finish
  wait %%last-job
  ;; no error so no increment in test-id
  (test+0)

  ;; check the bg-job didn't fail
  test (job-failed %%last-job) #f
  (test+1)

  ;; bg-job pipeline fail
  rcseh = exit1
  (test=)
  bg-job auto-exit -w 1 | auto-exit -r 2
  ;; no sleep this time so the only safe bet is to wait for the job to
  ;; finish
  wait %%last-job
  ;; this time we should have hit the two OOB tests
  (test+2)

  ;; check the bg-job DID fail
  test (job-failed %%last-job) #t
  (test+1)

}

;; IO redirection
{
  oih := (current-input-handle)
  ooh := (current-output-handle)

  ;; first of all, create {testfile} that external commands can access
  test-str := "Hello world"
  with-output-to-file testfile (function () {
    display test-str
  })

  stdinfile := "..stdin.."
  stdoutfile := "..stdout.."

  ;; Test (implied) file-handle stdout
  with-output-to stdoutfile (function () {
    cat testfile
  })

  th := open-input-file stdoutfile
  fho-str := read-lines th
  close-handle th

  test fho-str test-str

  stdoutstring := (open-output-string)
  ;; Test (implied) string-handle stdout
  with-output-to stdoutstring (function () {
    cat testfile
  })

  edisplay* "sho" stdoutstring
  sho-str := get-output-string stdoutstring

  test sho-str test-str

  if (file-exists? stdinfile) (delete-file stdinfile)
  if (file-exists? stdoutfile) (delete-file stdoutfile)

  set-input-handle! oih
  set-output-handle! ooh
}

PATH = OPATH
