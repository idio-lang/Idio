;;
;; Copyright (c) 2015 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; command.idio
;;

;; How to test external commands?

;; side-effects?

;; tinker with the PATH
OPATH := PATH
PATH = string-append PATH ":" PWD 

;; to avoid repeating the bulk of the error handler we'll just
;; (re)define the interesting bit, rt-command-status-error-handler
rcseh := #n

monitor (function (cont cond) {
  ;; edisplay* "command tests: monitor" cont cond
  test (rt-command-status-error? cond) #t
  if cont {
    if (rt-command-status-error? cond) {
      rcseh cond
    } {
      edisplay* "command tests: unexpected condition" cond
      raise cont cond
    }
  } {
    edisplay* "command tests: unexpected non-continuable condition" cond
    raise cont cond
  }
}) {

  ;; define some rt-command-status-error-handlers for the conditions
  ;; we are contriving to generate so that we can switch between them
  ;; as we go along

  ;; for exit0 we don't expect this code to be run at all -- hence
  ;; complaining loudly and testing for something that isn't generated
  ;; (spotting an error in the summary is easier to spot)
  exit0 := function (cond) {
    edisplay* "command tests: exit0: unexpected status error" cond
    job := idio-error-location cond
    edisplay* "pipeline:" (%idio-job-pipeline job)
    edisplay* "detail:" (pipeline-detail job)
    test (rt-command-status-error-status cond) 'job-failed
  }

  exit1 := function (cond) {
    ;; edisplay* "command tests: exit1" cond
    job := idio-error-location cond
    test (job-detail job) %T{ (exit $(c/integer-> 1)) }
    rt-command-status-error-status cond
  }

  killed1 := function (cond) {
    ;; edisplay* "command tests: killed1" cond
    job := idio-error-location cond
    test (job-detail job) %T{ (killed $(c/integer-> 1)) }
    rt-command-status-error-status cond
  }

  ;; Testing the tests!  We need to be sure that the OOB handlers are
  ;; successfully kicked off (or not kicked off) so we'll have a
  ;; couple of functions to store and check the Tests number has been
  ;; incremented OOB as we expect.

  ;; Remember, though, the test itself, as written in the rest of this
  ;; block, will increment Tests as well as any potential OOB handler.
  ;; The OOB handler will increment Tests twice: once to check the
  ;; condition is an rt-command-status-error and once in exit1/killed1
  ;; to verify the value of the status.

  test-id := Tests

  ;; test= exists to be sure of resetting test-id
  define (test=) {
    test-id = Tests
  }

  define (test+0) {
    test-cur-n := Tests
    test (test-id + 0) test-cur-n
    test-id = Tests
  }

  define (test+1) {
    test-cur-n := Tests
    test (test-id + 1) test-cur-n
    test-id = Tests
  }

  define (test+2) {
    test-cur-n := Tests
    test (test-id + 2) test-cur-n
    test-id = Tests
  }

  define (test+3) {
    test-cur-n := Tests
    test (test-id + 3) test-cur-n
    test-id = Tests
  }

  rcseh = exit0
  (test=)
  test (auto-exit -e 0) #t
  (test+1)

  rcseh = exit1
  (test=)
  test (auto-exit -e 1) #f
  (test+3)

  rcseh = killed1
  (test=)
  test (auto-exit -k 1) #f
  (test+3)

  rcseh = exit0
  (test=)
  test (auto-exit -w 1) #t
  (test+1)

  ;; backgrounded job
  (test=)
  bg-job auto-exit -s 1

  ;; As the bg-job is to sleep for one second we can be moderately
  ;; confident that an immediate test here that nothing has happened
  ;; will be OK.  But it is technically a race condition as this
  ;; parent process could have been stalled.  YMMV.
  (test+0)

  ;; If we wait for the job to finish we should have...no change as it
  ;; should have exited 0.
  wait %%last-job
  (test+0)

  ;; check the bg-job didn't fail
  test (job-failed %%last-job) #f
  (test+1)

  ;; pipeline
  (test=)
  test (auto-exit -w 1 | auto-exit -r 1) #t
  (test+1)

  ;; second command should finish first
  (test=)
  test (auto-exit -w 2 -s 1 | auto-exit -r 1) #t
  (test+1)

  ;; pipeline with regular Idio as the writer
  (test=)
  test (display* "first" | auto-exit -r 1) #t
  (test+1)

  ;; pipeline with the writer not writing anything
  rcseh = exit1
  (test=)
  test (auto-exit -e 0 | auto-exit -r 1) #f
  (test+3)

  ;; bg-job pipeline
  (test=)
  bg-job auto-exit -w 1 | auto-exit -r 1
  ;; no sleep this time so the only safe bet is to wait for the job to
  ;; finish
  wait %%last-job
  ;; no error so no increment in test-id
  (test+0)

  ;; check the bg-job didn't fail
  test (job-failed %%last-job) #f
  (test+1)

  ;; bg-job pipeline fail
  rcseh = exit1
  (test=)
  bg-job auto-exit -w 1 | auto-exit -r 2
  ;; no sleep this time so the only safe bet is to wait for the job to
  ;; finish
  wait %%last-job
  ;; this time we should have hit the two OOB tests
  (test+2)

  ;; check the bg-job DID fail
  test (job-failed %%last-job) #t
  (test+1)

}

PATH = OPATH
