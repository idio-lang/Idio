#! /usr/bin/env bash

# Copyright (c) 2015 Ian Fitchet <idf@idio-lang.org>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you
# may not use this file except in compliance with the License.  You
# may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#

# 
# io-check -- verify the stdin/out/err are what they should be
#

# -e should only apply to read (write?) and broken pipes
set -ue

usage () 
{
    (
	echo "usage: $0 [options]" 
	echo "where options are:" 
	echo "	-i S		stdin is from S" 
	echo "	-o D		stdout is to D" 	
	echo "	-e D		stderr is to D" 	
	echo
	echo "s/D can be:"
	echo "  null		/dev/null"
	echo "  NUM		fd NUM"
    ) >&2
}

pid=$$

opt_input=
opt_output=
opt_error=

while getopts "e:i:o:" opt ; do
    case "${opt}" in
    e)
	opt_error=${OPTARG}
	;;
    i)
	opt_input=${OPTARG}
	;;
    o)
	opt_output=${OPTARG}
	;;
    *)
	usage
	exit 1
	;;
    esac
done

error ()
{
    echo $* >&2
    lsof -a -p ${pid} -d 0-2
    exit 1
}

_uname=( $(uname -mrps) )
OS=${_uname[0]}

case "${OS}" in
FreeBSD)
    dev_null_dev=$(stat -f 0x%Xr /dev/null)
    ;;
esac

typeset -a stdio ftype rdev

lsof_data ()
{
    typeset fd file

    # whoops!
    #
    # while ... < <(...)
    #
    # causes the shell's own stdin to be a pipe (from the process
    # substitution) for the duration of the while loop, ie. we're
    # reporting a Bash side-effect not The Truth.

    tmpfile=/tmp/${0##*/}.$$

    lsof -a -p ${pid} -d 0-2 -F ftnr > ${tmpfile}

    while read line ; do
	case "${line}" in
	p${pid}) ;;
	f[0-2])
	    fd="${line#f}"
	    ;;
	t*)
	    ftype[fd]="${line#t}"
	    case "${ftype[fd]}" in
	    FIFO)
		ftype[fd]=PIPE
		;;
	    esac
	    ;;
	r*)
	    rdev[fd]="${line#r}"
	    ;;
	n*)
	    file="${line#n}"

	    # Normalise the output of lsof.  
	    #
	    # pipe: On CentOS it reports "pipe" for a pipe 'device'.
	    # On FreeBSD/Darwin it reports "->0x..." with a 64bit hex
	    # number.
	    #
	    # /dev/null: On FreeBSD /dev/null is just a regular
	    # /dev/fd/n.  However, the device should match the output
	    # from stat(1).
	    case "${OS}" in
	    FreeBSD|Darwin)
		case "${file}" in
		"->0x"*)
		    file=pipe
		    ;;
		esac
		;;
	    esac
	    case "${OS}" in
	    FreeBSD)
		case "${file}" in
		/dev/fd/*)
		    case "${ftype[fd]}" in
		    VCHR)
			if [[ ${rdev[fd]} = ${dev_null_dev} ]] ; then
			    file=/dev/null
			fi
			;;
		    esac
		    ;;
		esac
		;;
	    esac
	    stdio[fd]="${file}"
	    ;;
	esac
    done < ${tmpfile}

    rm -f ${tmpfile}
}

lsof_data

if [[ ${opt_input} ]] ; then
    case "${opt_input}" in
    null) 
	if [[ ${stdio[0]} != /dev/null ]] ; then
	    error "stdin: != /dev/null"
	fi
	;;
    pipe) 
	if [[ ${ftype[0]} != PIPE ]] ; then
	    error "stdin: != pipe"
	fi
	;;
    [0-2])
	if [[ ${stdio[0]} != ${stdio[opt_input]} ]] ; then
	    error "stdin: ${stdio[0]} != ${stdio[${opt_input}]}"
	fi
	;;
    /*)
	if [[ ! ${stdio[0]} =~ .*${opt_input}$ ]] ; then
	    error "stdin: ${stdio[0]} !~ .*${opt_input}$"
	fi
	;;
    *)
	read line
	case "$line" in
	"${opt_input}") ;;
	*)
	    error "stdin: read => $line != ${opt_input}"
	    ;;
	esac
	;;
    esac
fi

if [[ ${opt_output} ]] ; then
    case "${opt_output}" in
    null) 
	if [[ ${stdio[1]} != /dev/null ]] ; then
	    error "stdout: != /dev/null"
	fi
	;;
    pipe) 
	if [[ ${ftype[1]} != PIPE ]] ; then
	    error "stdout: != pipe"
	fi
	;;
    [0-2])
	if [[ ${stdio[1]} != ${stdio[opt_output]} ]] ; then
	    error "stdout: ${stdio[1]} != ${stdio[${opt_output}]}"
	fi
	;;
    /*)
	if [[ ! ${stdio[1]} =~ .*${opt_output}$ ]] ; then
	    error "stdout: ${stdio[1]} !~ .*${opt_output}$"
	fi
	;;
    *)
	echo "${opt_output}"
	;;
    esac
fi

if [[ ${opt_error} ]] ; then
    case "${opt_error}" in
    null) 
	if [[ ${stdio[2]} != /dev/null ]] ; then
	    error "stderr: != /dev/null"
	fi
	;;
    pipe) 
	if [[ ${ftype[2]} != PIPE ]] ; then
	    error "stderr: != pipe"
	fi
	;;
    [0-2])
	if [[ ${stdio[2]} != ${stdio[opt_error]} ]] ; then
	    error "stderr: ${stdio[2]} != ${stdio[${opt_error}]}"
	fi
	;;
    /*)
	if [[ ! ${stdio[2]} =~ .*${opt_error}$ ]] ; then
	    error "stderr: ${stdio[2]} !~ .*${opt_error}$"
	fi
	;;
    *)
	echo "${opt_output}" >&2
	;;
    esac
fi
