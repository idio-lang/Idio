#! /usr/bin/env bash

# Copyright (c) 2015 Ian Fitchet <idf@idio-lang.org>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you
# may not use this file except in compliance with the License.  You
# may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#

# 
# auto-exit -- die deterministically
#

# -e should only apply to read (write?) and broken pipes
set -ue

usage () 
{
    (
	echo "usage: $0 [options]" 
	echo "where options are:" 
	echo "	-i S		stdin is from S" 
	echo "	-o D		stdout is to D" 	
	echo "	-e D		stderr is to D" 	
	echo
	echo "s/D can be:"
	echo "  null		/dev/null"
	echo "  NUM		fd NUM"
    ) >&2
}

pid=$$

opt_input=
opt_output=
opt_error=

while getopts "e:i:o:" opt ; do
    case "${opt}" in
    e)
	opt_error=${OPTARG}
	;;
    i)
	opt_input=${OPTARG}
	;;
    o)
	opt_output=${OPTARG}
	;;
    *)
	usage
	exit 1
	;;
    esac
done

error ()
{
    echo $* >&2
    lsof -a -p ${pid} -d 0-2
    exit 1
}

typeset -a stdio
lsof_data ()
{
    typeset fd
    typeset file

    # whoops!
    #
    # while ... < <(...)
    #
    # causes the shell's own stdin to be a pipe (from the process
    # substitution) for the duration of the while loop, ie. we're
    # reporting a Bash side-effect not The Truth.

    tmpfile=/tmp/${0##*/}.$$

    lsof -a -p ${pid} -d 0-2 -F fn > ${tmpfile}

    while read line ; do
	case "${line}" in
	p${pid}) ;;
	f[0-2])
	    fd="${line#f}"
	    ;;
	n*)
	    file="${line#n}"
	    stdio[fd]="${file}"
	    ;;
	esac
    done < ${tmpfile}

    rm -f ${tmpfile}
}

lsof_data

if [[ ${opt_input} ]] ; then
    case "${opt_input}" in
    null) 
	if [[ ${stdio[0]} != /dev/null ]] ; then
	    error "stdin: != /dev/null"
	fi
	;;
    pipe) 
	if [[ ${stdio[0]} != pipe ]] ; then
	    error "stdin: != pipe"
	fi
	;;
    [0-2])
	if [[ ${stdio[0]} != ${stdio[opt_input]} ]] ; then
	    error "stdin: ${stdio[0]} != ${stdio[${opt_input}]}"
	fi
	;;
    /*)
	if [[ ! ${stdio[0]} =~ .*${opt_input}$ ]] ; then
	    error "stdin: ${stdio[0]} !~ .*${opt_input}$"
	fi
	;;
    *)
	read line
	case "$line" in
	"${opt_input}") ;;
	*)
	    error "stdin: read => $line != ${opt_input}"
	    ;;
	esac
	;;
    esac
fi

if [[ ${opt_output} ]] ; then
    case "${opt_output}" in
    null) 
	if [[ ${stdio[1]} != /dev/null ]] ; then
	    error "stdout: != /dev/null"
	fi
	;;
    pipe) 
	if [[ ${stdio[1]} != pipe ]] ; then
	    error "stdout: != pipe"
	fi
	;;
    [0-2])
	if [[ ${stdio[1]} != ${stdio[opt_output]} ]] ; then
	    error "stdout: ${stdio[1]} != ${stdio[${opt_output}]}"
	fi
	;;
    /*)
	if [[ ! ${stdio[1]} =~ .*${opt_output}$ ]] ; then
	    error "stdout: ${stdio[1]} !~ .*${opt_output}$"
	fi
	;;
    *)
	echo "${opt_output}"
	;;
    esac
fi

if [[ ${opt_error} ]] ; then
    case "${opt_error}" in
    null) 
	if [[ ${stdio[2]} != /dev/null ]] ; then
	    error "stderr: != /dev/null"
	fi
	;;
    pipe) 
	if [[ ${stdio[2]} != pipe ]] ; then
	    error "stderr: != pipe"
	fi
	;;
    [0-2])
	if [[ ${stdio[2]} != ${stdio[opt_error]} ]] ; then
	    error "stderr: ${stdio[2]} != ${stdio[${opt_error}]}"
	fi
	;;
    /*)
	if [[ ! ${stdio[2]} =~ .*${opt_error}$ ]] ; then
	    error "stderr: ${stdio[2]} !~ .*${opt_error}$"
	fi
	;;
    *)
	echo "${opt_output}" >&2
	;;
    esac
fi
