;;
;; Copyright (c) 2015 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; command.idio
;;

;;
;; These algorithms are directly from the libc info pages on Job
;; Control
;;

define (job-is-stopped-1 job) {
  loop :+ function (procs) {
    if+ (null? procs) #t \
	(and (not (%idio-process-completed (ph procs)))
	     (not (%idio-process-stopped (ph procs)))) #f \
	else (loop (pt procs))
  }

  loop (%idio-job-procs job)
}

define (job-is-completed-1 job) {
  loop :+ function (procs) {
    if+ (null? procs) #t \
	(not (%idio-process-completed (ph procs))) #f \
	else (loop (pt procs))
  }

  loop (%idio-job-procs job)
}

define (job-failed-1 job) {
  loop :+ function (procs) {
    if (null? procs) #f {
      status := %idio-process-status (ph procs)
      if+ (c/WIFEXITED status) {
	    if (not (c/== (c/WEXITSTATUS status) 0)) #t {
	      loop (pt procs)
	    }
          } (c/WIFSIGNALED status) #t \
	  else {
	    loop (pt procs)
	  }
    }
  }

  if (job-is-completed job) {
    loop (%idio-job-procs job)
  } #f
}

define (job-status-1 job) {
  loop :+ function (procs) {
    if (null? procs) #f {
      status := %idio-process-status (ph procs)
      if+ (c/WIFEXITED status) {
	    if (not (c/== (c/WEXITSTATUS status) 0)) (list 'exit (c/WEXITSTATUS status)) {
	      loop (pt procs)
	    }
          } (c/WIFSIGNALED status) (list 'killed (c/WTERMSIG status)) \
	  else {
	    loop (pt procs)
	  }
    }
  }

  ;; return rightmost non-zero exit status or the status from the last
  ;; (or any as they all succeeded but the last is top of procs)
  procs := reverse (%idio-job-procs job)
  or (loop procs) \
     (list 'exit (c/WEXITSTATUS (%idio-process-status (ph procs))))
}

define (mark-process-status-1 pid status) {
  if+ (c/> pid 0) {
    jobs-loop :+ function (jobs) {
      if+ (null? jobs) {
	    edisplay* "no child process" pid
	    #t
	  } else {
	    procs-loop :+ function (procs) {
              if+ (null? procs) #f \
	          (c/== pid (%idio-process-pid (ph procs))) {
                    set-%idio-process-status! (ph procs) status
                    if (c/WIFSTOPPED status) {
                      set-%idio-process-stopped! (ph procs) #t
                    } {
                      set-%idio-process-completed! (ph procs) #t
                      if (c/WIFSIGNALED status) {
                        edisplay* "Job Terminated: kill -" (c/WTERMSIG status)  pid ":" (c/strsignal (c/WTERMSIG status))
                      }
		    }
		    #f
                  } else {
		    procs-loop (pt procs)
		  }
            }

	    procs-loop (%idio-job-procs (ph jobs))
          }
    }

    jobs-loop %idio-jobs
  } (or (c/== pid 0)
	 #t ;(c/== c/errno ECHLD)
	 ) {
    #t
  } else {
    ;; an error in c/waitpid would have been signalled there
    error "mark-process-status: inconceivable!" pid status
  }
}

define (update-status-1) {
  waitany := function () {
    apply values (c/waitpid c/WAIT_ANY (c/WUNTRACED c/| c/WNOHANG))
  }

  do () ((call-with-values waitany mark-process-status) #n) #n
}

define (wait-for-job-1 job) {
  waitany := function () {
    apply values (c/waitpid c/WAIT_ANY c/WUNTRACED)
  }

  do () ((not (and (not (call-with-values waitany mark-process-status))
	      (not (job-is-stopped job))
	      (not (job-is-completed job)))) #n) #n
}

define (format-job-info-1 job msg) {
  edisplay* "job:" (%idio-job-pgid job) "(" msg ")"
}

define (do-job-notification) {
  ;; get the latest data
  (update-status)

  failed-jobs := #n

  loop :+ function (jobs r) {
    if+ (null? jobs) (reverse r) \
	else {
          job := ph jobs
          if+ (job-is-completed job) {
            format-job-info job "completed"
	    if (job-failed job) {
	      failed-jobs = pair job failed-jobs
	    }
            ;; remove job from list (by not including it!)
            loop (pt jobs) r
          } (job-is-stopped job) {
            if (not (%idio-job-notified job)) {
              format-job-info job "stopped"
              set-%idio-job-notified! job #t
            }
            loop (pt jobs) (pair job r)
          } else {
	    loop (pt jobs) (pair job r)
          }
        }
  }

  %idio-jobs = loop %idio-jobs #n

  if (not (null? failed-jobs)) {
    report :+ function (jobs) {
      if+ (null? jobs) #n \
          else {
	    job := ph jobs
	    c := make-condition ^rt-command-status-error "job failed" (%idio-job-pipeline job) (%idio-job-pgid job) (job-status job)
	    raise #t c

	    ;; if someone handled that error and returned (anything)
	    ;; then we can loop onto the next
	    report (pt jobs)
	  }
    }

    report failed-jobs
  }
}

define (foreground-job-1 job cont) {
  job-pgid := %idio-job-pgid job
  if cont {
    c/tcsetattr %idio-terminal c/TCSADRAIN (%idio-job-tcattrs job)
    kill (- job-pgid) c/SIGCONT
  }
  wait-for-job job
  c/tcsetpgrp %idio-terminal %idio-pgid
  set-%idio-job-tcattrs! job (c/tcgetattr %idio-terminal)
  c/tcsetattr %idio-terminal c/TCSADRAIN %idio-tcattrs
  job-status job
}

define (background-job-1 job cont) {
  job-pgid := %idio-job-pgid job
  if cont {
    kill (- job-pgid) c/SIGCONT
  }

  ;; result of a backgrounded job is 0
  0
}

define (mark-job-as-running-1 job) {
  loop := function (procs) {
    if+ (null? procs) #n \
	else {
      set-%idio-process-stopped! (ph procs) #f
      loop (pt procs)
    }
  }

  loop (%idio-job-procs job)
  set-%idio-job-notified! job #f
}

define (continue-job-1 job foreground) {
  mark-job-as-running job
  if foreground {
    foreground-job job #t
  } {
    background-job job #t
  }
}

define (prep-process-1 pgid infile outfile foreground) {
  if %idio-interactive {
    pid := (c/getpid)
    if (c/== pgid 0) {
      pgid = pid
    }
    c/setpgid pid pgid
    if foreground {
      c/tcsetpgrp %idio-terminal pgid
      c/signal c/SIGINT c/SIG_DFL
      c/signal c/SIGQUIT c/SIG_DFL
      c/signal c/SIGTSTP c/SIG_DFL
      c/signal c/SIGTTIN c/SIG_DFL
      c/signal c/SIGTTOU c/SIG_DFL
      c/signal c/SIGCHLD c/SIG_DFL
    }
    if (not (c/== infile c/STDIN_FILENO)) {
      c/dup2 infile c/STDIN_FILENO
      c/close infile
    }
    if (not (c/== outfile c/STDOUT_FILENO)) {
      c/dup2 outfile c/STDOUT_FILENO
      c/close outfile
    }
  }
}

define-operator | {
  pipeline := append before (append (list op) after)

  ;; we want a list of lists -- a list of the |-separated commands
  split :+ function (op op-args expr after) {
    cond ((null? after) (reverse (pair (reverse expr) op-args))) \
         ((not (pair? after)) (error "bad syntax" op (reverse op-args) after)) \
	 ((eq? op (ph after)) (split op (pair (reverse expr) op-args) #n (pt after))) \
	 (else (split op op-args (pair (ph after) expr) (pt after)))
  }

  op-args := split op (list before) #n after

  ;; looping over the list of commands prepping the children uses a
  ;; number of variables which are a pain to manage as they will be
  ;; doubly indirected inside templates.  So we'll "cheat" and use the
  ;; outer template to generate a block to hold our working variables.
  foreground := #t
  nprocs := length op-args
  %T{
    {
      procs := #n
      stdin := c/STDIN_FILENO
      infile := stdin
      stdout := c/STDOUT_FILENO
      outfile := stdout
      pgid := 0
      job := make-%idio-job '$pipeline procs pgid #f #n stdin stdout
      proc-id := 0
      pipe := #n
      $@(map (function (cmd) {
	        %T{
		  {
		    proc := make-%idio-process cmd -1 #f #f #n
		    $procs = pair proc $procs
		    if (le ($proc-id + 2) $nprocs) {
		      $pipe = (c/pipe)
		      $outfile = (c/pipe-writer $pipe)
		    } {
		      $outfile = stdout
		    }
		    pid := (c/fork)
		    if+ (c/== pid 0) {
		      prep-process $pgid $infile $outfile $foreground
		      $cmd

		      ;; If {cmd} was some Idio scripting then it will
		      ;; do its thing and continue onto here.  So we
		      ;; ought to stop.
		      c/exit 0
		    } else {
		      set-%idio-process-pid! proc pid
		      if %idio-interactive {
			if (c/== $pgid 0) {
			  $pgid = pid
			  set-%idio-job-pgid! $job $pgid
			}
			c/setpgid pid $pgid
		      }
		    }
		    if (not (c/== $infile $stdin)) (c/close $infile)
		    if (not (c/== $outfile $stdout)) (c/close $outfile)
		    $infile = (c/pipe-reader $pipe)
		    $proc-id = $proc-id + 1
		  }
	        }
	      })
	     op-args)
      set-%idio-job-procs! job (reverse procs)
      %idio-jobs = pair job %idio-jobs
      if+ (not %idio-interactive) {
	    wait-for-job $job
	  } $foreground {
	    foreground-job $job #f
	  } else {
	    background-job $job #f
          }
    }
  }
}

define (launch-1proc foreground & command) {
  stdin := c/STDIN_FILENO
  stdout := c/STDOUT_FILENO
  pgid := 0
  proc := make-%idio-process command -1 #f #f #n
  job := make-%idio-job command (list proc) pgid #f #n stdin stdout

  pid := (c/fork)
  if+ (c/== pid 0) {
    prep-process pgid stdin stdout foreground
    ;; command is a list so apply %exec to it
    apply %exec command
    error "exec" command
  } else {
    set-%idio-process-pid! proc pid
    if %idio-interactive {
      pgid = pid
      set-%idio-job-pgid! job pgid
      c/setpgid pid pgid
    }
  }

  %idio-jobs = pair job %idio-jobs

  if+ (not %idio-interactive) {
    wait-for-job job
  } foreground {
    foreground-job job #f
  } else {
    background-job job #f
  }
}

define-macro (launch-1proc-fg & command) {
  %T{
    launch-1proc #t $@command
  }
}

define-macro (launch-1proc-bg & command) {
  %T{
    launch-1proc #f $@command
  }
}

