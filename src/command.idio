;;
;; Copyright (c) 2015 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; command.idio
;;

%%last-job := #n
;;
;; These algorithms are directly from the libc info pages on Job
;; Control
;;

define (job-is-stopped job) {
  loop :+ function (procs) {
    if+ (null? procs) #t \
	(and (not (%idio-process-completed (ph procs)))
	     (not (%idio-process-stopped (ph procs)))) #f \
	else (loop (pt procs))
  }

  loop (%idio-job-procs job)
}

define (job-is-completed job) {
  loop :+ function (procs) {
    if+ (null? procs) #t \
	(not (%idio-process-completed (ph procs))) #f \
	else (loop (pt procs))
  }

  loop (%idio-job-procs job)
}

define (job-failed job) {
  loop :+ function (procs) {
    if (null? procs) #f {
      status := %idio-process-status (ph procs)
      if+ (c/WIFEXITED status) {
	    if (not (c/== (c/WEXITSTATUS status) 0)) #t {
	      loop (pt procs)
	    }
          } (c/WIFSIGNALED status) #t \
	  else {
	    loop (pt procs)
	  }
    }
  }

  if (job-is-completed job) {
    loop (%idio-job-procs job)
  } #f
}

define (job-status job) {
  loop :+ function (procs) {
    if (null? procs) #f {
      status := %idio-process-status (ph procs)
      if+ (c/WIFEXITED status) {
	    if (not (c/== (c/WEXITSTATUS status) 0)) (list 'exit (c/WEXITSTATUS status)) {
	      loop (pt procs)
	    }
          } (c/WIFSIGNALED status) (list 'killed (c/WTERMSIG status)) \
	  else {
	    loop (pt procs)
	  }
    }
  }

  ;; return rightmost non-zero exit status or the status from the last
  ;; (or any as they all succeeded but the last is top of procs)
  ;;
  ;; NB. the procs were pushed onto the list in reverse order so
  ;; walking down the list we encounter the rightmost first
  procs := %idio-job-procs job
  or (loop procs) \
     (list 'exit (c/WEXITSTATUS (%idio-process-status (ph procs))))
}

define (pipeline-detail job) {
  loop :+ function (procs st) {
    if (null? procs) st {
      status := %idio-process-status (ph procs)
      if+ (c/WIFEXITED status) {
            loop (pt procs) (pair (list 'exit (c/WEXITSTATUS status)) st)
          } (c/WIFSIGNALED status) {
	    loop (pt procs) (pair (list 'killed (c/WTERMSIG status)) st)
	  } \
	  else {
	    loop (pt procs) (pair (list 'unknown) st)
	  }
    }
  }

  loop (%idio-job-procs job) #n
}

define (mark-process-status pid status) {
  if+ (c/> pid 0) {
    jobs-loop :+ function (jobs) {
      if+ (null? jobs) {
	    edisplay* "no child process" pid
	    #t
	  } else {
	    procs-loop :+ function (procs) {
              if+ (null? procs) #f \
	          (c/== pid (%idio-process-pid (ph procs))) {
                    set-%idio-process-status! (ph procs) status
                    if (c/WIFSTOPPED status) {
                      set-%idio-process-stopped! (ph procs) #t
                    } {
                      set-%idio-process-completed! (ph procs) #t
                      if (c/WIFSIGNALED status) {
                        edisplay* "Job Terminated: kill -" (c/sig-name (c/WTERMSIG status))  pid ":" (c/strsignal (c/WTERMSIG status))
                      }
		    }
		    #f
                  } else {
		    procs-loop (pt procs)
		  }
            }

	    procs-loop (%idio-job-procs (ph jobs))
          }
    }

    jobs-loop %idio-jobs
  } (or (c/== pid 0)
	 #t ;(c/== c/errno ECHLD)
	 ) {
    #t
  } else {
    ;; an error in c/waitpid would have been signalled there
    error "mark-process-status: inconceivable!" pid status
  }
}

define (update-status) {
  waitany := function () {
    apply values (c/waitpid c/WAIT_ANY (c/WUNTRACED c/| c/WNOHANG))
  }

  do () ((call-with-values waitany mark-process-status) #n) #n
}

define (wait-for-job job) {
  waitany := function () {
    apply values (c/waitpid c/WAIT_ANY c/WUNTRACED)
  }

  do () ((not (and (not (call-with-values waitany mark-process-status))
	      (not (job-is-stopped job))
	      (not (job-is-completed job)))) #n) #n
}

define (format-job-info job msg) {
  edisplay* "job:" (%idio-job-pgid job) "(" msg ")"
}

define (do-job-notification-1) {
  ;; get the latest data
  (update-status)

  %%vm-trace 1
  failed-jobs := #n

  loop :+ function (jobs r) {
    if+ (null? jobs) (reverse r) \
	else {
          job := ph jobs
          if+ (job-is-completed job) {
            format-job-info job "completed"
	    if (job-failed job) {
	      failed-jobs = pair job failed-jobs
	    }
            ;; remove job from list (by not including it!)
            loop (pt jobs) r
          } (job-is-stopped job) {
            if (not (%idio-job-notified job)) {
              format-job-info job "stopped"
              set-%idio-job-notified! job #t
            }
            loop (pt jobs) (pair job r)
          } else {
	    loop (pt jobs) (pair job r)
          }
        }
  }

  %idio-jobs = loop %idio-jobs #n

  if (not (null? failed-jobs)) {
    report :+ function (jobs) {
      if+ (null? jobs) #n \
          else {
	    job := ph jobs
	    c := make-condition ^rt-command-status-error "job failed" job #n (job-status job)
	    raise #t c

	    ;; if someone handled that error and returned (anything)
	    ;; then we can loop onto the next
	    report (pt jobs)
	  }
    }

    report failed-jobs
  }

  %%vm-trace 0
  #n
}

define (foreground-job job cont) {
  job-pgid := %idio-job-pgid job
  c/tcsetpgrp %idio-terminal job-pgid
  if cont {
    c/tcsetattr %idio-terminal c/TCSADRAIN (%idio-job-tcattrs job)
    c/kill (- job-pgid) c/SIGCONT
  }

  r := wait-for-job job

  c/tcsetpgrp %idio-terminal %idio-pgid
  set-%idio-job-tcattrs! job (c/tcgetattr %idio-terminal)
  c/tcsetattr %idio-terminal c/TCSADRAIN %idio-tcattrs

  job-status job
  r
}

define (background-job job cont) {
  job-pgid := %idio-job-pgid job
  if cont {
    c/kill (- job-pgid) c/SIGCONT
  }

  ;; result of a backgrounded job is 0
  0
}

define (hangup-job job) {
  job-pgid := %idio-job-pgid job
  c/kill (- job-pgid) c/SIGCONT
  c/kill (- job-pgid) c/SIGHUP

  ;; result of a hungup job is 0
  0
}

define (mark-job-as-running job) {
  loop := function (procs) {
    if+ (null? procs) #n \
	else {
      set-%idio-process-stopped! (ph procs) #f
      loop (pt procs)
    }
  }

  loop (%idio-job-procs job)
  set-%idio-job-notified! job #f
}

define (continue-job job foreground) {
  mark-job-as-running job
  if foreground {
    foreground-job job #t
  } {
    background-job job #t
  }
}

define (prep-process pgid infile outfile foreground) {
  if %idio-interactive {
    pid := (c/getpid)
    if (c/== pgid 0) {
      pgid = pid
    }
    c/setpgid pid pgid

    if foreground {
      c/tcsetpgrp %idio-terminal pgid
    }

    c/signal c/SIGINT c/SIG_DFL
    c/signal c/SIGQUIT c/SIG_DFL
    c/signal c/SIGTSTP c/SIG_DFL
    c/signal c/SIGTTIN c/SIG_DFL
    c/signal c/SIGTTOU c/SIG_DFL
    c/signal c/SIGCHLD c/SIG_DFL
  }

  if (not (c/== infile c/STDIN_FILENO)) {
    c/dup2 infile c/STDIN_FILENO
    c/close infile
  }
  if (not (c/== outfile c/STDOUT_FILENO)) {
    c/dup2 outfile c/STDOUT_FILENO
    c/close outfile
  }
}

define-operator | {
  edisplay* "operator" op before after
  pipeline := append before (append (list op) after)

  ;; we want a list of lists -- a list of the |-separated commands
  split :+ function (op op-args expr after) {
    cond ((null? after) (reverse (pair (reverse expr) op-args))) \
         ((not (pair? after)) (error "bad syntax" op (reverse op-args) after)) \
	 ((eq? op (ph after)) (split op (pair (reverse expr) op-args) #n (pt after))) \
	 (else (split op op-args (pair (ph after) expr) (pt after)))
  }

  op-args := split op (list before) #n after
  edisplay* "operator" op op-args

  ;; looping over the list of commands prepping the children uses a
  ;; number of variables which are a pain to manage as we don't want
  ;; to pollute the calling environment and they will be doubly
  ;; indirected inside templates.  So we'll "cheat" and use the outer
  ;; template to generate a block to hold our working variables.

  ;; There's also a little process coordination trickery ported from
  ;; Bash -- noting that if the race condition occurs in a slick and
  ;; fast pure C environment then our meandering and inefficient
  ;; script has no hope!
  ;;
  ;; We need to prevent the first process in the pipeline from
  ;; starting until all the others are in place -- otherwise you can
  ;; have the first process, the process group leader, run and exit
  ;; before you manage to start any of the others!  That also leaves
  ;; the small issue of trying to call setpgid with a process group
  ;; that no longer exists (and, worse, could have been replaced with
  ;; a different process all together).  That's all bad for business.
  ;;
  ;; The trick is to open another pipe and have the first process
  ;; block reading from the pipe just before it starts.  All the other
  ;; processes in the pipeline simply close the pipe when they're
  ;; about to exec/start.  When the last one has closed the pipe the
  ;; first will have its blocking read() return (with zero bytes, ie
  ;; EOF -- we don't care) and we're good to go.
  ;;
  ;; Incidentally, as we created the pipe in the main Idio process, it
  ;; too holds the pipe open so we can be fairly confident that all
  ;; the child processes are set up and running when the main Idio
  ;; process closes the (last?) pipe write-end.
  ;;
  ;; Well, probably, there's always a race condition between closing
  ;; the pgrp-pipe and exec()ing or starting processing the Idio code
  ;; in which the last process can be prevented from running before
  ;; all the previous processes have been and gone.  But we've done a
  ;; decent job, what more can we do?

  foreground := #t
  nprocs := length op-args
  %T{
    {
      stdin := c/STDIN_FILENO
      infile := stdin
      stdout := c/STDOUT_FILENO
      outfile := stdout
      pgid := 0
      job := make-%idio-job '$pipeline #n pgid #f #n stdin stdout
      %idio-jobs = pair job %idio-jobs

      proc-id := 1
      pipe := #n
      pgrp-pipe := (c/pipe)

      $@(map (function (cmd) {
	        %T{
		  {
		    ;%%vm-trace 1
		    proc := make-%idio-process '$cmd -1 #f #f #n

		    ;; NB. Update the procs list asap as we can get a
		    ;; signal about processes in the pipeline at any
		    ;; time including, annoyingly, before we've
		    ;; finished creating the pipeline.
		    ;; do-job-notification/update-status will want to
		    ;; have a proc entry to update.
		    set-%idio-job-procs! job (pair proc (%idio-job-procs job))

		    if (lt $proc-id $nprocs) {
		      $pipe = (c/pipe)
		      $outfile = (c/pipe-writer $pipe)
		    } {
		      $outfile = $stdout
		    }
		    pid := (c/fork)
		    if (c/== pid 0) {
		      prep-process $pgid $infile $outfile $foreground
		      if (c/== $pgid 0) {
			c/close (c/pipe-writer $pgrp-pipe)

			;; $pgid is 0 so we must be the first in the
			;; pipeline -- block reading a single byte
			;; from the $pgrp-pipe
			c/read (c/pipe-reader $pgrp-pipe) 1
			c/close (c/pipe-reader $pgrp-pipe)
                      } {
			c/close (c/pipe-reader $pgrp-pipe)
			c/close (c/pipe-writer $pgrp-pipe)
		      }
		      ;; edisplay* "child" (c/getpid) "cmd" '$cmd
		      if+ (pair? (ph '$cmd)) {
			    ;; edisplay* "=>" (ph '$cmd)
			    (ph '$cmd)
			  } \
			  else $cmd

		      ;; If {cmd} was an external command then this
		      ;; child will have exec()'d it otherwise it is
		      ;; some Idio scripting whereon it will do its
		      ;; thing and continue onto here.  So we ought to
		      ;; stop before this child continues back into
		      ;; the main Idio engine.
		      c/exit 0
		    } {
		      set-%idio-process-pid! proc pid
		      if %idio-interactive {
			if (c/== $pgid 0) {
			  $pgid = pid
			  set-%idio-job-pgid! $job $pgid
			}
			c/setpgid pid $pgid
		      }
		    }
		    if (not (c/== $infile $stdin)) (c/close $infile)
		    if (not (c/== $outfile $stdout)) (c/close $outfile)
		    $infile = (c/pipe-reader $pipe)
		    $proc-id = $proc-id + 1
		  }
	        }
	      })
	     op-args)

      ;; finally let the first process go
      c/close (c/pipe-reader pgrp-pipe)
      c/close (c/pipe-writer pgrp-pipe)

      %%last-job = job
      %%vm-trace 0
      if+ (not %idio-interactive) {
	    wait-for-job job
	  } $foreground {
	    foreground-job job #f
	  } else {
	    background-job job #f
          }
    }
  }
}

define (launch-1proc foreground & command) {
  stdin := c/STDIN_FILENO
  stdout := c/STDOUT_FILENO
  pgid := 0
  proc := make-%idio-process command -1 #f #f #n
  job := make-%idio-job command (list proc) pgid #f #n stdin stdout

  pid := (c/fork)
  if+ (c/== pid 0) {
    prep-process pgid stdin stdout foreground
    ;; command is a list so apply %exec to it
    apply %exec command
    error "exec" command
  } else {
    set-%idio-process-pid! proc pid
    if %idio-interactive {
      pgid = pid
      set-%idio-job-pgid! job pgid
      c/setpgid pid pgid
    }
  }

  %idio-jobs = pair job %idio-jobs

  if+ (not %idio-interactive) {
    wait-for-job job
  } foreground {
    foreground-job job #f
  } else {
    background-job job #f
  }
}

define-macro (launch-1proc-fg & command) {
  %T{ launch-1proc #t $@command }
}

define-macro (launch-1proc-bg & command) {
  %T{ launch-1proc #f $@command }
}

