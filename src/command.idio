;;
;; Copyright (c) 2015 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; command.idio
;;

define (job-is-stopped job) {
  loop :+ function (procs) {
    if+ (null? procs) #t \
	(and (not (%command-process-completed (ph procs)))
	     (not (%command-process-stopped (ph procs)))) #f \
	else (loop (pt procs))
  }

  loop (%command-job-procs job)
}

define (job-is-completed job) {
  loop :+ function (procs) {
    if+ (null? procs) #t \
	(not (%command-process-completed (ph procs))) #f \
	else (loop (pt procs))
  }

  loop (%command-job-procs job)
}

define (mark-process-status pid status) {
  if+ (c/gt pid 0) {
    jobs-loop :+ function (jobs) {
      if+ (null? jobs) {
	    display* "no child process" pid
	    #t
	  } else {
	    procs-loop :+ function (procs) {
              if (null? procs) #n \
		 (c/eq pid (%command-proc-pid (ph procs))) {
                   set-%command-process-status! (ph procs) status
                   if (c/WIFSTOPPED status) {
                     set-%command-process-stopped (ph procs) #t
                   } {
                     set-%command-process-completed (ph procs) #t
                     if (c/WIFSIGNALED status) {
                       display* pid "Terminated by signal" (c/WTERMSIG status)
                     }
		   }
		   #t
                 } else (procs-loop (pt procs))
            }

	    procs-loop (%command-job-procs job)
          }
    }

    jobs-loop %command-jobs
  } (and (c/eq pid 0)
	 (c/eq c/errno ECHLD)) {
    #f
  } else {
    error "mark-process-status: impossible!" pid status
  }
}

define (update-status) {
  waitany := function () {
    apply values (c/waitpid c/WAIT_ANY c/WUNTRACED)
  }
  do () (call-with-values waitany mark-process-status) #n
}

define (wait-for-job job) {
  waitany := function () {
    apply values (c/waitpid c/WAIT_ANY c/WUNTRACED)
  }
  do () (and (call-with-values waitany mark-process-status)
	     (not (job-is-stopped job))
	     (not (job-is-completed job))) #n
}

define (foreground-job job cont) {
  job-pgid := %command-job-pgid job
  if cont {
    c/tcsetattr %idio-terminal c/TCSADRAIN (%command-job-tcattrs job)
    kill (- job-pgid) c/SIGCONT
  }
  wait-for-job job
  c/tcsetpgrp %idio-terminal %idio-pgid
  set-%command-job-tcattrs! job (c/tcgetattr %idio-terminal)
  c/tcsetattr %idio-terminal c/TCSADRAIN %idio-tcattrs
}

define (background-job job cont) {
  job-pgid := %command-job-pgid job
  if cont {
    kill (- job-pgid) c/SIGCONT
  }
}

define (prep-process pgid infile outfile foreground) {
  display* "prep-process: pgid" pgid infile "->" outfile "fg" foreground "int?" %idio-interactive
  if %idio-interactive {
    pid := (c/getpid)
    if (c/eq pgid 0) {
      pgid = pid
    }
    c/setpgid pid pgid
    if foreground {
      c/tcsetpgrp %idio-terminal pgid
      c/signal c/SIGINT c/SIG_DFL
      c/signal c/SIGQUIT c/SIG_DFL
      c/signal c/SIGTSTP c/SIG_DFL
      c/signal c/SIGTTIN c/SIG_DFL
      c/signal c/SIGTTOU c/SIG_DFL
      c/signal c/SIGCHLD c/SIG_DFL
    }
    if (not (c/eq infile c/STDIN_FILENO)) {
      c/dup2 infile c/STDIN_FILENO
      c/close infile
    }
    if (not (c/eq outfile c/STDOUT_FILENO)) {
      c/dup2 outfile c/STDOUT_FILENO
      c/close outfile
    }
  }
}

define-operator | {
  pipeline := append before (append (list op) after)

  ;; we want a list of lists -- a list of the |-separated commands
  split :+ function (op op-args expr after) {
    cond ((null? after) (reverse (pair (reverse expr) op-args))) \
         ((not (pair? after)) (error "bad syntax" op (reverse op-args) after)) \
	 ((eq? op (ph after)) (split op (pair (reverse expr) op-args) #n (pt after))) \
	 (else (split op op-args (pair (ph after) expr) (pt after)))
  }

  op-args := split op (list before) #n after

  ;; looping over the list of commands prepping the children uses a
  ;; number of variables which are a pain to manage as they will be
  ;; doubly indirected inside templates.  So we'll "cheat" and use the
  ;; outer template to generate a block to hold our working variables.
  foreground := #t
  nprocs := length op-args
  %T{
    {
      procs := #n
      stdin := c/STDIN_FILENO
      infile := stdin
      stdout := c/STDOUT_FILENO
      outfile := stdout
      pgid := 0
      job := make-%command-job '$pipeline procs pgid #f #n stdin stdout
      proc-id := 0
      pipe := #n
      $@(map (function (cmd) {
	        %T{
		  {
		    proc := make-%command-process cmd -1 #f #f #n
		    $procs := pair proc $procs
		    if (le ($proc-id + 2) $nprocs) {
		      display* "new pipe because" ($proc-id + 2) "le" $nprocs
		      $pipe = (c/pipe)
		      $outfile = (c/pipe-writer $pipe)
		    } {
		      $outfile = stdout
		    }
		    pid := (c/fork)
		    if+ (c/eq pid 0) {
		      prep-process $pgid $infile $outfile $foreground
		      $cmd
		      c/exit 3
		    } else {
		      set-%command-process-pid! proc pid
		      if %idio-interactive {
			if (c/eq $pgid 0) {
			  $pgid = pid
			  set-%command-job-pgid! $job $pgid
			}
			c/setpgid pid $pgid
		      }
		    }
		    if (not (c/eq $infile $stdin)) (c/close $infile)
		    if (not (c/eq $outfile $stdout)) (c/close $outfile)
		    $infile = (c/pipe-reader $pipe)
		    $proc-id = $proc-id + 1
		  }
	        }
	      })
	     op-args)
      set-%command-job-procs! job (reverse procs)
      %command-jobs := pair job %command-jobs
      if+ (not %idio-interactive) {
	wait-for-job $job
      } $foreground {
	foreground-job $job #f
      } else {
	background-job $job #f
      }
    }
  }
}

