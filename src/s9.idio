;;
;; Idio - ported from
;;
;; Scheme 9 from Empty Space
;; By Nils M Holm <nmh@t3x.org>, 2007,2008,2009
;;

;;----- Library -----

;; Some obvious procedures first

define (caaaar x) (car (car (car (car x))))
define (caaadr x) (car (car (car (cdr x))))
define (caadar x) (car (car (cdr (car x))))
define (caaddr x) (car (car (cdr (cdr x))))
define (cadaar x) (car (cdr (car (car x))))
define (cadadr x) (car (cdr (car (cdr x))))
define (caddar x) (car (cdr (cdr (car x))))
define (cadddr x) (car (cdr (cdr (cdr x))))
define (cdaaar x) (cdr (car (car (car x))))
define (cdaadr x) (cdr (car (car (cdr x))))
define (cdadar x) (cdr (car (cdr (car x))))
define (cdaddr x) (cdr (car (cdr (cdr x))))
define (cddaar x) (cdr (cdr (car (car x))))
define (cddadr x) (cdr (cdr (car (cdr x))))
define (cdddar x) (cdr (cdr (cdr (car x))))
define (cddddr x) (cdr (cdr (cdr (cdr x))))

define (caaar x) (car (car (car x)))
define (caadr x) (car (car (cdr x)))
define (cadar x) (car (cdr (car x)))
define (caddr x) (car (cdr (cdr x)))
define (cdaar x) (cdr (car (car x)))
define (cdadr x) (cdr (car (cdr x)))
define (cddar x) (cdr (cdr (car x)))
define (cdddr x) (cdr (cdr (cdr x)))

define (caar x) (car (car x))
define (cadr x) (car (cdr x))
define (cdar x) (cdr (car x))
define (cddr x) (cdr (cdr x))

define (list & x) x

define (null? x) (eq? #n x)

define (void) (if #f #f)

;; Auxiliary definitions, will be redefined later

; Idio already defines append so to ensure append is this function we
; need a recursive definition

append = {
  %append :+ function (a b) {
    if (null? a) b {
      cons (car a) (%append (cdr a) b)
    }
  }
  %append
}

; There is no LET or LETREC yet, so

define-macro (let-s9 bindings expr & exprs) {
  ((function (split)
    ((function (tmp-split) {
       set! split tmp-split
       apply (function (vars args) {
	 append \
	   (list (append (list 'lambda)
			 (append (list vars)
				 (append (list expr)
					 exprs)))) \
	   args
	  }) \
	  split bindings #n #n
       })
      (function (bind* vars args) {
 	 if (null? bind*) {
	   list vars args
	 } {
	   split (cdr bind*) \
		 (cons (caar bind*) vars)
		 (cons (cadr (car bind*)) args)
	 }
       })))
   #f)
}

define (map-car f a) {
  %mapcar :+ function (a) {
    if (null? a) {
      '#n
    } {
      cons (f (car a)) (%mapcar (cdr a))
    }
  }
  %mapcar a
}

define (map f a b) {
  map2 :+ function (a b) {
    if (null? a) {
      '#n
    } {
      cons (f (car a) (car b)) (map2 (cdr a) (cdr b))
    }
  }
  map2 a b
}

define-macro (letrec-s9 bindings expr & exprs) {
  append3 := function (a b c) {
    append a (append b c)
  }
  tmps := map-car (function (x) (gensym)) bindings
  vars := map-car car bindings
  args := map-car cadr bindings

  undefineds := map-car (function (v) (list v #f)) vars
  tmp-bindings := map list tmps args
  updates := map (function (v t) (list 'set! v t)) vars tmps
  list 'let \
       undefineds \
       (append3 '(let) 
                (list tmp-bindings)
		(append3 updates
			 (list expr)
			 exprs))
}

;; Library procedures

;; if+ a b c d e
;; =>
;; (cond (a b) (c d) (else e))
define-macro (if+ & clauses) {
  loop :+ function (c) {
    cond ((null? c) '#n) \
	 ((not (pair? c)) (error "bad syntax")) \
	 ((null? (cdr c)) {
	   list 'else (car c)
	 }) (else {
	  cons (list (car c) (car (cdr c))) (loop (cdr (cdr c)))
	 })
  }

  `(cond ,@(loop clauses))
}

;; Booleans

define (not x) (eq? #f x)

;; Type predicates

; conflicts with Idio fixnum/bignum
;(define number? real?)

define (port? x) {
  or (input-port? x) \
     (output-port? x)
}

;; Equivalence predicates

define (eqv? a b) {
  if+ (number? a) (and (number? b)
		       (= a b)) \
      (char? a)   (and (char? b)
		       (char=? a b)) \
      else        (eq? a b)
}

define (equal? a b) {
  if+ (eq? a b) #t \
      (and (pair? a)
	   (pair? b)) (and (equal? (car a) (car b))
			   (equal? (cdr a) (cdr b))) \
      (string? a) (and (string? b)
		       (string=? a b)) \
      (vector? a) (and (vector? b)
		       (equal? (vector->list a)
			       (vector->list b))) \
      else (eqv? a b)
}

;; List procedures

define (list? x) {
  l? :+ function (x y) {
    if+ (eq? x y) #f \
	(null? x) #t \
	(pair? x) (or (null? (cdr x))
		      (and (pair? (cdr x))
			   (l? (cddr x) (cdr y)))) \
        else #f
    }

  or (null? x) \
     (and (pair? x)
	  (l? (cdr x) x))
}

define (assoc x a) {
  if+ (null? a) #f \
      (equal? (caar a) x) (car a) \
      else (assoc x (cdr a))
}

define (assq x a) {
  if+ (null? a) #f \
      (eq? (caar a) x) (car a) \
      else (assq x (cdr a))
}

define (assv x a) {
  if+ (null? a) #f \
      (eqv? (caar a) x) (car a) \
      else (assv x (cdr a))
}

define (member x a) {
  if+ (null? a) #f \
      (equal? (car a) x) a \
      else (member x (cdr a))
}

define (memq x a) {
  if+ (null? a) #f \
      (eq? (car a) x) a \
      else (memq x (cdr a))
}

define (memv x a) {
  if+ (null? a) #f \
      (eqv? (car a) x) a \
      else (memv x (cdr a))
}

define (reverse a) {
  reverse2 :+ function (a b) {
    if (null? a) b {
      reverse2 (cdr a) (cons (car a) b)
    }
  }
  reverse2 a '#n
}

; Auxiliary functions for FOLD-LEFT, FOLD-RIGHT, MAP

define (map-car f a) {
  mapcar1 :+ function (a r) {
    if (null? a) {
      reverse r
    } {
      mapcar1 (cdr a) (cons (f (car a)) r)
    }
  }

  mapcar1 a '#n
}

car-of := {
  map-car := map-car

  function (a*) {
    map-car car a*
  }
}

cdr-of := {
  map-car := map-car

  function (a*) {
    map-car cdr a*
  }
}

any-null? := {
  map-car := map-car

  function (a*) {
    and (memq #t (map-car null? a*)) \
	#t
  }
}

fold-left := {
  car-of := car-of
  cdr-of := cdr-of
  any-null? := any-null?

  function (f b & a*) {
    fold :+ function (a* r) {
      if (any-null? a*) r {
        fold (cdr-of a*) (apply f r (car-of a*))
      }
    }
 
    if (null? a*) {
      error "fold-left: too few arguments"
    } {
      fold a* b
    }
  }
}

fold-right := {
  car-of := car-of
  cdr-of := cdr-of
  any-null? := any-null?
  map-car := map-car

  function (f b & a*) {
    foldr :+ function (a* r) {
      if (any-null? a*) r {
         foldr (cdr-of a*) (apply f (append (car-of a*)
					    (list r)))
      }
    }

    if (null? a*) {
      error "fold-right: too few arguments"
    } {
      foldr (map-car reverse a*) b
    }
  }
}

append := {
  fold-left := fold-left

  function a {
    append2 :+ function (a b) {
      if (null? a) b {
        append2 (cdr a) (cons (car a) b)
      }
    }
    append-wrapper :+ function (a b) {
      if (null? b) a {
        append2 (reverse a) b
      }
    }
     
    fold-left append-wrapper '#n a
  }
}

define (length x) {
  length2 :+ function (x r) {
    if (null? x) r {
      length2 (cdr x) (+ r 1)
    }
  }

  length2 x 0
}

define (list-tail x n) {
  if+ (zero? n) x \
      (null? x) (error "list-tail: index out of range" n) \
      else (list-tail (cdr x) (- n 1))
}

define (list-ref x n) {
  car (list-tail x n)
}

map := {
  car-of := car-of
  cdr-of := cdr-of
  any-null? := any-null?

  function (f & a*) {
    map2 :+ function (a* r) {
      if (null? (car a*)) {
        reverse r
      } {
	map2 (cdr-of a*) (cons (apply f (car-of a*))
			       r)
      }
    }

    if (null? a*) {
      error "map: too few arguments"
    } {
      map2 a* '#n
    }
  }
}

define (for-each f & a*) {
  if (null? a*) {
    error "for-each: too few arguments"
  } {
    apply map f a*
  }
  (void)
}

;; Arithmetic procedures

define (abs x) (if (< x 0) (- x) x)

define (even? x) (zero? (remainder x 2))

define (expt x y) {
  square :+ function (x) (* x x)
  expt2 :+ function (x y) {
    if+ (zero? y) 1 \
	(even? y) (square (expt2 x (quotient y 2))) \
	else      (x * (square (expt2 x (quotient y 2))))
  }
  
  if+ (negative? y) {
        / (expt2 (0.0 + x) y)
      } (integer? y) {
        expt2 x y
      } else (exp (y * (log x)))
}

gcd := {
  fold-left := fold-left

  function a {
    gcd2 :+ function (a b) {
      if+ (zero? b) a \
	  (zero? a) b \
	  (< a b) (gcd2 a (remainder b a)) \
	  else (gcd2 b (remainder a b))
    }

    fold-left gcd2 0 (map abs a)
  }
}

lcm := {
  fold-left := fold-left

  function a {
    lcm2 :+ function (a b) {
      cd := (gcd a b)
      
      * cd (* (quotient a cd)
                        (quotient b cd))
    }
    
    fold-left lcm2 1 (map abs a)
  }
}

max := {
  fold-left := fold-left

  function (a & b) {
    fold-left (function (a b) {
      if (or (inexact? a) (inexact? b)) {
        exact->inexact (if (> a b) a b)
      } {
        if (> a b) a b
      }
    }) a b
  }
}

min := {
  fold-left := fold-left

  function (a & b) {
    fold-left (function (a b) {
      if (or (inexact? a) (inexact? b)) {
        exact->inexact (if (< a b) a b)
      } {
	if (< a b) a b
      }
    }) a b
  }
}

define (modulo a b) {
  rem := remainder a b

  if+ (zero? rem) 0 \
      (eq? (negative? a) (negative? b)) rem \
      else (+ b rem)
}

define (negative? x) (< x 0)

define (odd? x) (not (even? x))

define (positive? x) (> x 0)

define (ceiling x) (- (floor (- x)))

define (round x) {
  x+ := 0.5 + x
  rx := floor x+

  if (and (odd? (inexact->exact rx))
	  (= x+ rx)) {
    rx - 1
  } rx
}

define (truncate x) {
  (if (< x 0) ceiling floor) x
}

; used by EXP and SIN
define (fact2 x r) {
  if (= x 0) r {
    fact2 (x - 1) (x * r)
  }
}

exp := {
  fact2 := fact2

  function (x) {
    e-series :+ function (x y r last) {
      if (= r last) r {
        e-series x \
		 (1 + y) \
		 (r + ((expt x y) /
		       (fact2 y 1))) \
		 r
      }
    }

    if (>= x 2.0) {
      e^x/2 := 1 + (x / 2) + (e-series (x / 2) 
				       2 
				       0.0 
				       1.0)

      e^x/2 * e^x/2
    } {
      1 + x + (e-series x 
			2 
			0.0 
			1.0)
    }
  }
}

define (log x) {
  l-series :+ function (x y r last lim) {
    if+ (and lim (zero? lim)) r \
	(= r last) (2 * r) \
	else (l-series x
		       (2 + y)
		       (r + ((expt ((x - 1) /
				    (x + 1))
                                         y) /
				   y)) \
		       r
		       (if lim (lim - 1) lim))
    }

    if+ (negative? x) (1.0 / 0) \
        (< 0.1 x 5) (l-series x 
			      1 
			      0.0 
			      1.0 
			      #f) \
        else {
          approx := l-series x 1 0.0 1.0 5
          a := x / (exp approx)
          approx + (log a)
        }
}

; auxilary definitions for SIN, COS, TAN
pi := 3.141592653589793238462643383279502884197169399375105820974944
pi/4 := pi / 4
pi/2 := pi / 2
3pi/4 := pi/2 + pi/4
3pi/2 := pi + pi/2
5pi/4 := pi + pi/4
7pi/4 := pi + 3pi/4
2pi := pi + pi

->circle := {
  2pi := 2pi

  function (x) {
    x+ := abs x
    d := 2pi * (floor (x+ / 2pi))
    x+ = x+ - d
    if (negative? x) {
      2pi - x+
    } {
      x+
    }
  }
}

p-series  := {
  fact2 := fact2

  function (x y r add last) {
    if (= r last) r {
      p-series x \
	       (2 + y) \
	       ((if add \+ \-) r ((expt x y) / (fact2 y 1))) \
	       (not add) \
	       r
    }
  }
}

cos := {
  ->circle := ->circle
  p-series := p-series
  pi := pi
  pi/2 := pi/2
  3pi/2 := 3pi/2
  2pi := 2pi

  function (x) {
    x := ->circle x

    if+ (= 0     x)       (if (inexact? x)  #i1.0  1.0) \
        (= pi/2  x)       (if (inexact? x)  #i0.0  0.0) \
	(= pi    x)       (if (inexact? x) #i-1.0 -1.0) \
	(= 3pi/2 x)       (if (inexact? x)  #i0.0  0.0) \
	(<= 0    x pi/2)  (p-series    x         2 1.0 #f 0) \
	(<= pi/2 x pi)    (- (p-series (- pi x)  2 1.0 #f 0)) \
	(<= pi   x 3pi/2) (- (p-series (- x pi)  2 1.0 #f 0)) \
	else              (p-series    (- 2pi x) 2 1.0 #f 0)
  }
}

sin := {
  ->circle := ->circle
  p-series := p-series
  pi := pi
  pi/2 := pi/2
  3pi/2 := 3pi/2
  2pi := 2pi

  function (x) {
    x := ->circle x

    if+ (= 0     x) (if (inexact? x)  #i0.0  0.0) \
        (= pi/2  x) (if (inexact? x)  #i1.0  1.0) \
	(= pi    x) (if (inexact? x)  #i0.0  0.0) \
	(= 3pi/2 x) (if (inexact? x) #i-1.0 -1.0) \
	else {
	  z := if+ (<= 0    x  pi/2) x \
	           (<= pi/2 x  pi)   (- pi x) \
		   (<= pi   x 3pi/2) (- x pi) \
		   else              (- 2pi x)

	  if (> x pi) {
	    - (p-series z 3 z #f 0)
          } {
	    p-series z 3 z #f 0
          }
        }
  }
}

tan := {
  ->circle := ->circle
  pi := pi
  pi/4 := pi/4
  3pi/4 := 3pi/4
  5pi/4 := 5pi/4
  7pi/4 := 7pi/4

  function (x) {
    x := ->circle x
    if+ (or (= x 0)     (= x  pi))   (if (inexact? x)  #i0.0  0.0) \
        (or (= x  pi/4) (= x 5pi/4)) (if (inexact? x)  #i1.0  1.0) \
	(or (= x 3pi/4) (= x 7pi/4)) (if (inexact? x) #i-1.0 -1.0) \
	else                         ((sin x) / (cos x))
  }
}

atan := {
  pi/2 := pi/2
  at-series :+ function (x y r last) {
    if (= r last) r {
      at-series x \
		(1 + y) \
		(r + ((((expt 2 (y + y)) * (expt (fact2 y 1) 2)) /
		       (fact2 (y + y + 1) 1)) *
		       ((expt x (y + y + 1)) /
			(expt (1 + (x * x)) (1 + y))))) \
		r
    }
  }

  function (x) {
    if+ (negative? x) (- (at-series (- x) 0.0 0 1)) \
	(> x 1) (pi/2 - (atan (/ x))) \
	else (at-series x 0.0 0 1)
  }
}

define (asin x) {
  if+ (= 1 x) (2 * (atan x)) \
      (negative? x) (- (asin (- x))) \
      else (atan (x / (sqrt (1 - (x * x)))))
}

acos := {
  pi := pi
  pi/2 := pi/2

  function (x) {
    if+ (= -1 x) pi \
	(=  1 x) 0 \
	else (pi/2 - (asin x))
  }
}

define (sqrt square) {
  sqrt2 :+ function (x last) {
    if (= last x) x {
      sqrt2 ((x + (square / x)) / 2) x
    }
  }

  if (negative? square) {
    error "sqrt: negative argument" square
  } {
    rt := sqrt2 square 0
    if (= square (* rt rt)) {
      inexact->exact rt
    } rt
  }
}

define (zero? x) (= 0 x)

;; String procedures

define (string & x) (list->string x)

; Used by NUMBER->STRING and STRING->NUMBER
define (number-of-digits n r) {
  if (zero? n) {
    if (zero? r) 1 r
  } {
    number-of-digits (quotient n 10) (1 + r)
  }
}

define number->string {
  number-of-digits := number-of-digits

  function (n & radix) {
    digits :+ list->vector (string->list "0123456789abcdefghijklmnopqrstuvwxyz")
    conv :+ function (n rdx res) {
      if (zero? n) {
        if (null? res) '(#\0) res
      } {
	conv (quotient n rdx) \
	     rdx \
	     (cons (vector-ref digits (remainder n rdx))
		   res)
      }
    }
    conv-int :+ function (n rdx) {
      if (negative? n) {
        list->string (cons #\- (conv (abs n) rdx '#n))
      } {
	list->string (conv n rdx '#n)
      }
    }
    conv-sci-real :+ function (m e) {
      ms := conv-int m 10
      es := conv-int e 10
      i := if (negative? m) 2 1
      k := string-length ms
      string-append (substring ms 0 i) \
		    "." \
		    (if (= k i) "0" (substring ms i k)) \
		    "e" \
		    (if (<= 0 e) "+" "") \
		    es
    }
    zeroes :+ function (n) {
      loop :+ function (n z) {
        if (positive? n) {
          loop (- n 1) (cons #\0 z)
        } {
	  list->string z
        }
      }
      loop n '#n
    }
    conv-expanded-real :+ function (n offset) {
      m := abs n
      string-append (if (negative? n) "-" "") \
		    (if+ (negative? offset) "0."
			 (zero? offset)     "0"
			 else               "") \
		    (zeroes (- offset)) \
		    {
		      ms := conv-int m 10
		      k := string-length ms
		      if (<= 0 offset k){
                        string-append (substring ms 0 offset) \
				      "." \
				      (substring ms offset k)
                      } {
			ms
                      }
                    }
    }
    conv-real :+ function (n) {
      m := mantissa n
      e := exponent n
      d := number-of-digits m 0

      if (< -4 (+ e d) 10) {
        conv-expanded-real m (e + d)
      } {
	conv-sci-real m (e + d + -1)
      }
    }
    get-radix :+ function () {
      if+ (null? radix) 10 \
	  (<= 2 (car radix) 36) (car radix) \
	  else (error "number->string: invalid radix"
                                (car radix))
    }

    r := (get-radix)
    if+ (not (or (integer? n) (= 10 r))) \
          (error "number->string: real number needs a radix of 10" n) \
	(integer? n) (conv-int (inexact->exact n) r) \
	else (conv-real n)
  }
}

string->number := {
  number-of-digits := number-of-digits
  inexact := #f

  function (str & radix) {
    digits :+ string->list "0123456789abcdefghijklmnopqrstuvwxyz"
    value-of-digit :+ function (x) {
      v :+ function (x d n) {
        if+ (null? d) 36 \
	    (char=? (car d) x) n \
	    else (v x (cdr d) (n + 1))
      }
      v (char-downcase x) digits 0
    }
    find-exponent-mark :+ function (c) {
      memv c '(#\d #\D #\e #\E #\f #\F #\l #\L #\s #\S)
    }
    result :+ cons
    value :+ car
    rest :+ cdr
    FAIL :+ '(#f & #f)
    failed? :+ function (res) (eq? #f (cdr res))
    ok? :+ function (res) (not (eq? #f (cdr res)))
    conv3 :+ function (lst val rdx) {
      if (null? lst) {
        result val '#n
      } {
	dval := value-of-digit (car lst)
	if (< dval rdx) {
          conv3 (cdr lst) \
		((value-of-digit (car lst)) + (val * rdx)) \
		rdx
        } {
	  result val lst
        }
      }
    }
    conv :+ function (lst rdx) {
      if (null? lst) FAIL {
        conv3 lst 0 rdx
      }
    }
    conv-int :+ function (lst rdx) {
      if+ (null? lst) FAIL \
	  (char=? (car lst) #\+) (conv (cdr lst) rdx) \
	  (char=? (car lst) #\-) {
            r := conv (cdr lst) rdx
	    if (ok? r) {
              result (- (value r)) (rest r)
            } FAIL 
          } \
	  else (conv lst rdx)
    }
    make-frag :+ function (x) {
      d := number-of-digits x -1
      (x / (expt 10.0 d)) - 1.0
    }
    make-real :+ function (int frag expn) {
      v := (0.0 + (abs int) + (make-frag frag)) * (expt 10.0 expn)
      if (negative? int) (- v) v
    }
    conv-exponent :+ function (int frag lst) {
      if (null? lst) FAIL {
        exp-part := conv-int lst 10
	if (failed? exp-part) FAIL {
          result (make-real int frag (value exp-part)) (rest exp-part)
        }
      }
    }
    conv-decimals :+ function (int lst) {
      if+ (null? lst) (result (0.0 + int) '#n) \
	  (find-exponent-mark (car lst)) (conv-exponent int 10 (cdr lst)) \
	  else {
            frag-part := conv3 lst 1 10
	    if (null? (rest frag-part)) {
              result (make-real int (value frag-part) 0) '#n
            } {
	      conv-exponent int (value frag-part) (cdr (rest frag-part))
            }
          }
    }
    radix-ten? :+ function (rdx) {
      if (not (= 10 rdx)) {
        if (null? radix) #f (error "string->number: real number needs a radix of 10")
      } #t
    }
    mantissa-digits? :+ function (x) {
      if+ (null? x)                    #f \
	  (char-numeric? (car x))      #t \
	  (find-exponent-mark (car x)) #f \
	  else (mantissa-digits? (cdr x))
    }
    conv-real :+ function (lst rdx) {
      int-part := conv-int lst rdx
      if+ (failed? int-part) FAIL \
          (and (zero? (value int-part))
	       (not (mantissa-digits? lst))) FAIL \
	  (null? (rest int-part)) int-part \
	  (find-exponent-mark (car (rest int-part))) {
            if (radix-ten? rdx) {
              conv-exponent (value int-part) \
			    10 \
			    (cdr (rest int-part))
            } FAIL
	  } \
	  (char=? #\. (car (rest int-part))) {
            if (radix-ten? rdx) {
              conv-decimals (value int-part) (cdr (rest int-part))
            } FAIL
          } \
	  else int-part
    }
    replace-inexact-digits! :+ function (a) {
      if+ (null? a) #f \
	  (char=? #\# (car a)) {
            set-car! a #\5
            set! inexact #t
            replace-inexact-digits! (cdr a)
          } \
	  else (replace-inexact-digits! (cdr a))
    }
    get-radix :+ function () {
      if+ (null? radix) 10 \
	  (<= 2 (car radix) 36) (car radix) \
	  else (error "string->number: invalid radix" (car radix))
    }

    set! inexact #f
    radix :+ (get-radix)
    lst :+ string->list str

    if (and (> (string-length str) 1)
	    (char=? #\# (car lst))) {
      mod := cadr lst
      set! lst (cddr lst)
      if+ (char=? mod #\e) (void) \
          (char=? mod #\d) (void) \
	  (char=? mod #\i) (set! inexact #t) \
	  (char=? mod #\b) (set! radix 2) \
	  (char=? mod #\o) (set! radix 8) \
	  (char=? mod #\x) (set! radix 16) \
	  else             (set! lst '#n)
    }
    if (or (null? lst)
	   (memv (car lst) '(#\+ #\- #\.))
	   (char-numeric? (car lst))) {
      replace-inexact-digits! lst
    }

    r := if+ (null? lst) FAIL \
             (char=? #\- (car lst)) (conv-real (cdr lst) radix) \
	     else (conv-real lst radix)

    if (null? (rest r)) {
      v := if (char=? #\- (car lst)) {
        - (value r)
      } {
	value r
      }
      if inexact (exact->inexact v) v
    } #f
  }
}

;; Vector procedures

define (vector & x) (list->vector x)

;; Input/output procedures

define (newline & port) (apply write-char #\newline port)

define (call-with-input-file file proc) {
  f := open-input-file file
  r := proc f
  close-input-port f
  r
}

define (call-with-output-file file proc) {
  f := open-output-file file
  r := proc f
  close-output-port f
  r
}

with-input-from-file := {
  set-input-port! := set-input-port!

  function (file thunk) {
    outer-port := (current-input-port)
    new-port := open-input-file file
    set-input-port! new-port
    input := (thunk)
    close-input-port new-port
    set-input-port! outer-port
    input
  }
}

with-output-to-file := {
  set-output-port! := set-output-port!

  function (file thunk) {
    outer-port := (current-output-port)
    new-port := open-output-file file
    set-output-port! new-port
    (thunk)
    close-output-port new-port
    set-output-port! outer-port
  }
}

;;----- Quasi-quote-expander -----

define-macro (quasiquote-s9) \
  function (form) {
    qq-cons :+ function (a b) {
      if+ (and (pair? a)
	       (eq? 'unquote-splicing (car a))) {
            if (and (pair? b)
		    (eq? 'quote (car b))
		    (null? (cadr b))) {
              cadr a
            } {
	      list 'append (cadr a) b
            }
          } \
          else (list 'cons a b)
    }
    qq-expand :+ function (x) {
      if+ (vector? x) (list 'list->vector (qq-expand (vector->list x))) \
	  (not (pair? x)) (list 'quote x) \
	  (and (eq? 'unquote (car x))
	       (pair? (cdr x))) (cadr x) \
	  (and (eq? 'unquote-splicing (car x))
	       (pair? (cdr x))) (list 'unquote-splicing (cadr x)) \
	  (and (eq? 'quasiquote (car x))
	       (pair? (cdr x))) (error "quasiquote: may not be nested") \
	  else (qq-cons (qq-expand (car x))
			(qq-expand (cdr x)))
    }

    qq-expand form
  }


;;----- Library -----

; LET/LET*/LETREC helper
define (check-bindings b who) {
  if+ (null? b) #t \
      (or (not (pair? b))
	  (not (pair? (car b)))
	  (not (symbol? (caar b)))
	  (not (pair? (cdar b)))
	  (not (null? (cddar b)))) (error (string-append who ": invalid syntax") b) \
      else (check-bindings (cdr b) who)
}

; Now that the QQ expander is here, define a
; clean version of LET (including named LET).
; Can't name it LET yet, because it uses LET.
define-macro %ext-let {
  check-bindings := check-bindings

  function (a1 a2 & a3) {
    split :+ function (bind* vars args) {
      if (null? bind*) {
        cons vars args
      } {
	split (cdr bind*) \
	      (cons (caar bind*) vars) \
	      (cons (cadar bind*) args)
      }
    }
       
    if (symbol? a1) {
      if (null? a3) {
        error "named let: missing body" `(let ,a1 ,a2 ,@a3)
      } {
	 check-bindings a2 "let"
         va := split a2 '#n '#n
	 v := reverse (car va)
	 a := reverse (cdr va)
	 `((letrec ((,a1 (function ,v ,@a3))) ,a1) ,@a)
      }
    } {
      check-bindings a1 "let"
      va := split a1 '#n '#n
      v := car va
      a := cdr va
      `((function ,v ,a2 ,@a3) ,@a)
    }
  }
}

define-macro let %ext-let

; Also define a clean version of LETREC.

define-macro %clean-letrec {
  check-bindings := check-bindings

  function (bindings expr & exprs) {
    check-bindings bindings "letrec"
    tmps := map (function (x) (gensym)) bindings
    vars := map car bindings
    args := map cadr bindings

    undefineds := map (function (v) (list v #f)) vars
    tmp-bindings := map (function (t a) (list t a)) tmps args
    updates := map (function (v t) (list 'set! v t)) vars tmps
    `(let ,undefineds
       (let ,tmp-bindings
	    ,@updates
	    ,expr
	    ,@exprs))
  }
}

define-macro letrec %clean-letrec

define-macro let* {
  check-bindings := check-bindings

  function (bindings expr & exprs) {
    nest-let :+ function (b) {
      if+ (null? b) (cons expr exprs) \
	  (null? (cdr b)) `(let ((,(caar b) ,(cadar b)))
                                ,@(nest-let (cdr b))) \
          else `(let ((,(caar b) ,(cadar b)))
		     ,(nest-let (cdr b)))
    }

    check-bindings bindings "let*"
    if (null? bindings) {
      `(let () ,expr ,@exprs)
    } {
      nest-let bindings
    }
  }
}

define-macro (case key & clauses) {
  gen-clauses :+ function (k c*) {
    if+ (null? c*) '#n \
	(or (not (pair? c*))
	    (not (pair? (car c*)))
	    (not (pair? (cdar c*)))) (error "case: invalid syntax" c*) \
	(null? (cdr c*)) {
          if (eq? 'else (caar c*)) {
            `((else ,@(cdar c*)))
          } {
	    `(((memv ,k ',(caar c*)) ,@(cdar c*)))
          }
        } \
	else `(((memv ,k ',(caar c*)) ,@(cdar c*))
	         ,@(gen-clauses k (cdr c*)))
  }

  k := (gensym)
  `(let ((,k ,key)) (cond ,@(gen-clauses k clauses)))
}

define-macro (do var-clauses test & body) {
  split :+ function (clauses vars inits steps) {
    if+ (null? clauses) (list vars inits steps) \
	(or (not (pair? clauses))
	    (not (pair? (car clauses)))
	    (not (symbol? (caar clauses)))
	    (not (pair? (cdar clauses)))) (error "do: invalid syntax" clauses) \
	else (split (cdr clauses)
		    (cons (caar clauses) vars)
		    (cons (cadar clauses) inits)
		    (if (null? (cddar clauses))
			(cons (caar clauses) steps)
			(cons (caddar clauses) steps)))
  }

  if (or (not (pair? test))
	 (not (list? (cdr test)))) {
    error "do: invalid syntax" test
  } {
    loop := (gensym)
    var+init+step := split var-clauses '#n '#n '#n
    v := car var+init+step
    i := cadr var+init+step
    s := caddr var+init+step

    `(letrec
	 ((,loop
	   (function ,v
	     (if ,(car test)
		 (begin ,@(cdr test))
		 (begin ,@body (,loop ,@s))))))
       (,loop ,@i))
  }
}

define-macro (delay expr) {
  `(let ((value #f))
     (function ()
       (if value
           (car value)
           (let ((x ,expr))
             (if value
                 (car value)
                 (begin (set! value (cons x '()))
                        (car value)))))))
}

define (force x) (x)

;;----- Syntax-rules-transformer -----

; This expander rewrites DEFINE-SYNTAX to DEFINE-MACRO, e.g.:
;
; (define-syntax iff
;   (syntax-rules (then else)
;     ((_ p then c)        (or p c))
;     ((_ p then c else a) (if p c a))))
; ==>
; (define-macro (iff & g283)
;   ((function (syntax-expand syntax-match g283)
;      (cond ((syntax-match g283 '(_ p then c) '(then else) '())
;              => (function (env)
;                   (syntax-expand '(_ p then c) '(or p c) env)))
;            ((syntax-match g283 '(_ p then c else a) '(then else) '())
;              => (function (env)
;                   (syntax-expand '(_ p then c else a) '(if p c a) env)))
;            (else
;              (error "invalid syntax" g283))))
;    #<PROCEDURE syntax-expand>
;    #<PROCEDURE syntax-match>
;    (cons 'iff g283)))

; Match FORM against PATTERN.
; KEYWORDS contains the keywords of SYNTAX-RULES.
; When the given form matches the pattern, bind
; each variable of PATTERN to the corresponding
; part of the FORM, extend ENV by these bondings
; and return it.
; In case of a mismatch, return #F.
;
; NOTE: The ellipsis is an ordinary variable, but
; it binds to an environment rather than a form.
;
define (syntax-match form pattern keywords env) {
  match :+ function (form pattern keywords env) {
    if+ (pair? pattern) {
          if+ (and (pair? (cdr pattern)) \
		   (eq? '... (cadr pattern))) {
                e* := map (function (x)
			    (match x (car pattern) keywords '#n)) \
		      form
		cons (cons '... e*) env
              } \
	      (pair? form) {
                e := match (car form) (car pattern) keywords env
		and e \
		    (match (cdr form) (cdr pattern) keywords e)
              } \
              else #f
        } \
        (memq pattern keywords) {
          if (eq? pattern form) env #f
        } \
	(symbol? pattern) {
          cons (cons pattern form) env
        } \
        else {
          if (equal? pattern form) env #f
        }
  }

  e := match form pattern keywords env
  if e (reverse e) e
}

; Give a unique name to each variable that is bound in FORM.
; BOUND is a list of initially bound variables. This function
; also renames variables of LET, LET*, and LETREC, e.g.:
;
; (ALPHA-CONV '(LET ((X Y)) X) '()) => (LET ((G0 Y)) G0)
;
define (alpha-conv form bound) {
  subst :+ function (x env) {
    if+ (assq x env) (=> cdr) \
	else x
  }
  map-improper :+ function (f a r) {
    if+ (null? a) (reverse r) \
	(not (pair? a)) (append (reverse r) (f a)) \
	else (map-improper f (cdr a) (cons (f (car a)) r))
  }
  remove-bound :+ function (env bound) {
    if+ (null? env) '#n \
	(memq (caar env) bound) (remove-bound (cdr env) bound) \
	else (cons (car env) (remove-bound (cdr env) bound))
  }
  conv :+ function (form env) {
    if+ (symbol? form) (subst form env) \
	(not (pair? form)) form \
	(and (eq? 'quote (car form)) \
	     (pair? (cdr form)) \
	     (null? (cddr form))) form \
	(and (eq? 'function (car form)) \
	     (pair? (cdr form)) \
	     (pair? (cddr form))) {
	  e := map-improper (function (x) 
			      (cons x (gensym))) \
			    (cadr form) \
			    '#n

	  `(function ,@(conv (cdr form)
			   (append (remove-bound e bound)
				   env)))
        } \
	(and (or (eq? (car form) 'let) \
		 (eq? (car form) 'letrec) \
		 (eq? (car form) 'let*)) \
	     (pair? (cdr form)) \
	     (pair? (cadr form)) \
	     (pair? (caadr form)) \
	     (pair? (cddr form))) {
	e := map-improper (function (x)
			    (cons x (gensym))) \
			  (map (function (x)
				 (if (pair? x) (car x) #f))
			       (cadr form)) \
			  '()

        `(,(car form) ,@(conv (cdr form)
			      (append (remove-bound e bound)
				      env)))
        } \
	else (map-improper (function (x) (conv x env))
			   form
			   '#n)
  }

  conv form '#n
}

; Substitute variables of FORM by values of ENV.
;
define (syntax-expand bound tmpl env) {
  alpha-conv := alpha-conv
  expand :+ function (tmpl env) {
    if+ (not (pair? tmpl)) {
      (cond ((assq tmpl env) => cdr)
	    (else tmpl))
        } \
	(and (pair? tmpl) \
	     (pair? (cdr tmpl)) \
	     (eq? (cadr tmpl) '...)) {
	  eenv := assq '... env

	  if (not eenv) {
	    error "syntax-rules: template without matching ... in pattern" tmpl
          } {
	    set-car! eenv '(#f)
            map (function (x)
		  (expand (car tmpl) x)) \
	        (cdr eenv)
          }
        } \
	else {
	  cons (expand (car tmpl) env) \
	       (expand (cdr tmpl) env)
	}
  }

  alpha-conv (expand tmpl env) bound
}

; Check the syntax of DEFINE-SYNTAX and rewrite it
; to an application of DEFINE-MACRO.
;
define-macro define-syntax {
  flatten :+ function (x r) {
    if+ (null? x) r \
	(pair? x) (flatten (car x)
			   (flatten (cdr x) r)) \
        else (cons x r)
  }
  list-of? :+ function (p a) {
      or (null? a) \
	 (and (p (car a)) \
	      (list-of? p (cdr a)))
  }
  keywords-ok? :+ function (x) {
    list-of? symbol? x
  }
  rules-ok? :+ function (x) {
    list-of? (function (x)
	       (and (pair? x) \
		    (pair? (car x)) \
		    (pair? (cdr x)) \
		    (null? (cddr x)))) \
	     x
  }
  pattern := caar
  template := cadar
  rewrite-rules :+ function (app keywords rules-in rules-out) {
    if (null? rules-in) {
      reverse rules-out
    } {
      rewrite-rules app \
		    keywords \
		    (cdr rules-in) \
		    (cons `((syntax-match ,app
					  ',(pattern rules-in)
					  ',keywords
					  '#n)
			    => (function (env)
				 (syntax-expand ',(flatten (pattern rules-in) '())
						',(template rules-in)
						env)))
			  rules-out)
    }
  }

  function (name rules) {
    if+ (not (symbol? name)) (error "define-syntax: expected symbol, got" name) \
        (or (not (pair? rules)) \
	    (not (eq? 'syntax-rules (car rules)))) (error "define-syntax: expected syntax-rules, got" rules) \
	(or (not (pair? (cdr rules))) \
	    (not (pair? (cddr rules)))) (error "syntax-rules: too few arguments" rules) \
	(not (keywords-ok? (cadr rules))) (error "syntax-rules: malformed keyword list" (cadr rules)) \
        (not (rules-ok? (cddr rules))) (error "syntax-rules: invalid clause in rules" (cddr rules)) \
        else {
          app := (gensym)
	  default := `((else (error "invalid syntax" ,app)))

	  `(define-macro ,(cons name app)
	     (let ((,app (cons ',name ,app))
		   (syntax-match ,syntax-match)
		   (syntax-expand ,syntax-expand))
	       (cond ,@(append (rewrite-rules app
					      (cadr rules)
					      (cddr rules)
					      '())
			       default))))
        }
  }
}

;;----- Utilities -----

define (print & x*) {
  p :+ function (x* first) {
    if+ (not (null? x*)) {
      if (not first) (write-char #\space)
      write (car x*)
      p (cdr x*) #f
    }
  }

  p x* #t
  (newline)
}

define (locate-file file) {
  split :+ function (s) {
    loop :+ function (in tmp out) {
      if+ (null? in) {
            if (null? tmp) out {
              reverse (cons (list->string (reverse tmp))
			    out)
            }
          } \
	  (char=? #\: (car in)) {
            loop (cdr in) \
		 '#n \
		 (cons (list->string (reverse tmp))
		       out)
          } \
	  else {
	    loop (cdr in) \
		 (cons (car in) tmp) \
		 out
          }
    }

    loop (string->list s) '#n '#n
  }

  loop :+ function (path) {
    if (null? path) #f {
      full-path := string-append (car path) "/" file

      if (file-exists? full-path) full-path {
        loop (cdr path)
      }
    }
  }

  loop (split *library-path*)
}

define (load-from-library file) {
  full-path := locate-file file
  do-load := function (file) {
    if (not *loading*) {
      display "; loading from "
      display file
      (newline)
    } {
     load file
    }
  }

  if full-path {
    do-load full-path
  } {
    full-path := locate-file (string-append file ".idio")
    if full-path {
      do-load full-path
    } {
      error "cannot locate file" file
    }
  }
}
