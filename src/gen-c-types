#! /bin/bash

types=( \
    intmax_t uintmax_t
    char "unsigned char" \
    short "unsigned short" \
    int "unsigned int" \
    long "unsigned long" \
    float \
    double \
    "void *" \
    int8_t uint8_t \
    int16_t uint16_t \
    int32_t uint32_t \
    int64_t uint64_t \
    size_t \
    off_t \
    pid_t \
    
    )

# id == IDIO_TYPE_CAT_BASE (the start of the C auto-generated types)
# must coordinate with IDIO_TYPE_MAX in gc.h
id=50

cname () 
{
    typeset ctype=${1/unsigned /u}
    ctype=${ctype/void \*/pointer}
    ctype=${ctype/ /_}
    echo ${ctype}
}

cprologue ()
{
    cat <<EOF
/*
 * Copyright (c) 2015 Ian Fitchet <idf(at)idio-lang.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You
 * may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/*
 * $1
 *
 * Autogenerated on $(date)
 *
 * DO NOT EDIT OR CHECK IN! 
 */

EOF
}

######################################################################
#
# header
#

exec 3>&1 > auto-c-type.h
cprologue auto-c-types.h

cat <<EOF
#ifndef AUTO_C_TYPE_H
#define AUTO_C_TYPE_H

EOF

printf "#define %-25s ${id}\n" IDIO_TYPE_CAT_BASE

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    printf "#define %-25s ${id}\n" IDIO_TYPE_C_${CTYPE}
    id=$(( id + 1 ))
done

printf "#define %-25s ${id}\n" IDIO_TYPE_CAT_MAX
echo

cat <<EOF
typedef struct idio_C_pointer_s {
    void *p;
    char freep;
} idio_C_pointer_t;

typedef struct idio_C_type_s {
    union {
EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    case ${ctype} in
    pointer) ;;
    *)
	printf "\t%-20s %s;\n" "${type}" C_${ctype}
	;;
    esac
done

cat <<EOF
	idio_C_pointer_t *C_pointer;
    } u;
} idio_C_type_t;

EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    case ${ctype} in
    pointer)
	cat <<EOF
#define IDIO_C_TYPE_POINTER_P(C)       ((C)->u.C_type.u.C_pointer->p)
#define IDIO_C_TYPE_POINTER_FREEP(C)   ((C)->u.C_type.u.C_pointer->freep)
EOF
	;;
    *)
	printf "#define %-30s ((C)->u.C_type.u.C_${ctype})\n" "IDIO_C_TYPE_${CTYPE}(C)"
	;;
    esac
done

cat <<EOF

void idio_free_C_type (struct idio_s *co);
EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    cat <<EOF
struct idio_s *idio_C_${ctype} (${type} v);
int idio_isa_C_${ctype} (struct idio_s *co);
${type} idio_C_${ctype}_get (struct idio_s *co);
EOF
    case ${ctype} in
    pointer)
	cat <<EOF
struct idio_s *idio_C_${ctype}_free_me (${type} v);
void idio_free_C_${ctype} (struct idio_s *co);
EOF
	;;
    esac
done

cat <<EOF
const char *idio_type_C_enum2string (idio_type_e type);
int idio_C_equal (struct idio_s *o1, struct idio_s *o2);
char *idio_C_as_string (struct idio_s *o, int depth);
idio_hi_t idio_hash_C_hashval (struct idio_s *k);
struct idio_s *idio_C_number_cast (struct idio_s *co, int type);

void idio_init_auto_c_type ();
void idio_auto_c_type_add_primtives ();
void idio_final_auto_c_type ();

#endif /* AUTO_C_TYPE_H */

EOF

######################################################################
#
# C
#

exec > auto-c-type.c
cprologue auto-c-types.c

cat <<EOF

#include "idio.h"

void idio_free_C_type (IDIO co)
{
    IDIO_ASSERT (co);

    /*
    idio_gc_stats_free (sizeof (idio_C_type_t));

    free (co->u.C_type);
    */
}

EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    case ${ctype} in
    pointer)
	cat <<EOF
IDIO idio_C_${ctype} (${type} v)
{
    /*
     * NB Don't IDIO_C_ASSERT (v) as we could be instantiating with NULL
     */

    IDIO co = idio_gc_get (IDIO_TYPE_C_${CTYPE});

    /* IDIO_GC_ALLOC (co->u.C_type, sizeof (idio_C_type_t)); */
    IDIO_GC_ALLOC (co->u.C_type.u.C_pointer, sizeof (idio_C_pointer_t));
    
    IDIO_C_TYPE_${CTYPE}_P (co) = v;
    IDIO_C_TYPE_${CTYPE}_FREEP (co) = 0;

    return co;
}

IDIO idio_C_${ctype}_free_me (${type} v)
{
    /*
     * NB We must IDIO_C_ASSERT (v) as we will be trying to free v
     */
    IDIO_C_ASSERT (v);
    
    IDIO co = idio_C_${ctype} (v);

    IDIO_C_TYPE_${CTYPE}_FREEP (co) = 1;

    return co;
}

int idio_isa_C_${ctype} (IDIO co)
{
    IDIO_ASSERT (co);

    return idio_isa (co, IDIO_TYPE_C_${CTYPE});
}

${type} idio_C_${ctype}_get (IDIO co)
{
    IDIO_ASSERT (co);
    IDIO_TYPE_ASSERT (C_${ctype}, co);

    return IDIO_C_TYPE_${CTYPE}_P (co);
}

void idio_free_C_${ctype} (IDIO co)
{
    IDIO_ASSERT (co);

    /* idio_gc_stats_free (sizeof (idio_C_${ctype}_t)); */

    if (IDIO_C_TYPE_${CTYPE}_FREEP (co)) {
	free (IDIO_C_TYPE_${CTYPE}_P (co));
    }

    free (co->u.C_type.u.C_${ctype});
    /* idio_free_C_type (co); */
}

EOF
	;;
    *)
	cat <<EOF
IDIO idio_C_${ctype} (${type} v)
{
    IDIO co = idio_gc_get (IDIO_TYPE_C_${CTYPE});

    /* IDIO_GC_ALLOC (co->u.C_type, sizeof (idio_C_type_t)); */
    
    IDIO_C_TYPE_${CTYPE} (co) = v;

    return co;
}

int idio_isa_C_${ctype} (IDIO co)
{
    IDIO_ASSERT (co);

    return idio_isa (co, IDIO_TYPE_C_${CTYPE});
}

${type} idio_C_${ctype}_get (IDIO co)
{
    IDIO_ASSERT (co);
    IDIO_TYPE_ASSERT (C_${ctype}, co);

    return IDIO_C_TYPE_${CTYPE} (co);
}

EOF
	;;
    esac
done

cat <<EOF
const char *idio_type_C_enum2string (idio_type_e type)
{
    switch (type) {
EOF
for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    cat <<EOF
    case IDIO_TYPE_C_${CTYPE}: return "C ${CTYPE}";
EOF
done
cat <<EOF
    default:
	IDIO_FPRINTF (stderr, "idio_type_C_enum2string: unexpected type %d\n", type);
	return "NOT KNOWN";
    }
}

/*
 * We have to repeat a few checks here in case we're called direct.
 */
int idio_C_equal (IDIO o1, IDIO o2)
{
    IDIO_ASSERT (o1);
    IDIO_ASSERT (o2);

    if (o1 == o2) {
	return 1;
    }
    
    int m1 = (intptr_t) o1 & 3;
    
    switch (m1) {
    case IDIO_TYPE_FIXNUM_MARK:
    case IDIO_TYPE_CONSTANT_MARK:
    case IDIO_TYPE_CHARACTER_MARK:
	/*
	  We already tested for equality above!
	 */
	return 0;
    case IDIO_TYPE_POINTER_MARK:
	{
	    int m2 = (intptr_t) o2 & 3;
    
	    switch (m2) {
	    case IDIO_TYPE_FIXNUM_MARK:
		{
		    intptr_t v2 = IDIO_FIXNUM_VAL (o2);
		    switch (o1->type) {
EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    case ${ctype} in
    pointer)
	cat <<EOF
		    case IDIO_TYPE_C_${CTYPE}:
			return 0;
EOF
	;;
    *)
	cat <<EOF
		    case IDIO_TYPE_C_${CTYPE}:
			return (IDIO_C_TYPE_${CTYPE} (o1) == v2);
EOF
	;;
    esac
done

cat <<EOF
		    default:
			fprintf (stderr, "idio_C_equal: IDIO_TYPE_POINTER_MARK: o1->type %d unexpected\n", o1->type);
			IDIO_C_ASSERT (0);
			return 0;
	    }
		}
	        break;
	    case IDIO_TYPE_CONSTANT_MARK:
	    case IDIO_TYPE_CHARACTER_MARK:
		/* we would have matched at the top */
		return 0;
	    default:
		break;
	    }
	    
	    if (o1->type != o2->type) {
		return 0;
	    }
    
	    if (IDIO_FLAG_FREE_SET (o1) ||
		IDIO_FLAG_FREE_SET (o2)) {
		return 0;
	    }

	    switch (o1->type) {
EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    case ${ctype} in
    pointer)
	cat <<EOF
	    case IDIO_TYPE_C_${CTYPE}:
		return (IDIO_C_TYPE_${CTYPE}_P (o1) == IDIO_C_TYPE_${CTYPE}_P (o2));
EOF
	;;
    *)
	cat <<EOF
	    case IDIO_TYPE_C_${CTYPE}:
		return (IDIO_C_TYPE_${CTYPE} (o1) == IDIO_C_TYPE_${CTYPE} (o2));
EOF
	;;
    esac
done

cat <<EOF
	    default:
		fprintf (stderr, "idio_equal: IDIO_TYPE_POINTER_MARK: o1->type %d unexpected\n", o1->type);
		IDIO_C_ASSERT (0);
		return 0;
	    }
	}
    default:
	fprintf (stderr, "idio_C_equal: o1->type %p unexpected\n", o1);
	IDIO_C_ASSERT (0);
	return 0;
    }

    return 1;
}

#define IDIO_DEFINE_C_ARITHMETIC_CMP_PRIMITIVE(name,cname,cmp)	\\
    IDIO_DEFINE_PRIMITIVE2 (name, cname, (IDIO n1, IDIO n2))	\\
    {								\\
	IDIO_ASSERT (n1);					\\
	IDIO_ASSERT (n2);					\\
								\\
	int result;						\\
								\\
	if (idio_isa_fixnum (n2)) {				\\
	    if (idio_isa_fixnum (n1)) {				\\
		result = idio_eqp (n1, n2);			\\
	    } else {						\\
		intptr_t v2 = IDIO_FIXNUM_VAL (n2);		\\
		switch (idio_type (n1)) {			\\
EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    case ${ctype} in
    pointer)
	cat <<EOF
		case IDIO_TYPE_C_${CTYPE}:			\\
		    result = 0;					\\
		    break;					\\
EOF
	;;
    *)
	cat <<EOF
		case IDIO_TYPE_C_${CTYPE}:			\\
		    result = (IDIO_C_TYPE_${CTYPE} (n1) cmp v2); \\
		    break;					\\
EOF
	;;
    esac
done

cat <<EOF
		default:					\\
		    fprintf (stderr, #name ": IDIO_TYPE_POINTER_MARK: n1->type %d unexpected\n", n1->type); \\
		    IDIO_C_ASSERT (0);				\\
		    result = 0;					\\
		    break;					\\
		}						\\
	    }							\\
	} else {						\\
	    result = idio_C_equal (n1, n2);			\\
	}							\\
								\\
	IDIO r = idio_S_false;					\\
								\\
	if (result) {						\\
	    r = idio_S_true;					\\
	}							\\
								\\
	return r;						\\
    }


IDIO_DEFINE_C_ARITHMETIC_CMP_PRIMITIVE ("c/le", C_le, <=)
IDIO_DEFINE_C_ARITHMETIC_CMP_PRIMITIVE ("c/lt", C_lt, <)
IDIO_DEFINE_C_ARITHMETIC_CMP_PRIMITIVE ("c/eq", C_eq, ==)
IDIO_DEFINE_C_ARITHMETIC_CMP_PRIMITIVE ("c/ge", C_ge, >=)
IDIO_DEFINE_C_ARITHMETIC_CMP_PRIMITIVE ("c/gt", C_gt, >)

char *idio_C_as_string (IDIO o, int depth)
{
    char *r;
    
    switch ((intptr_t) o & 3) {
    case IDIO_TYPE_FIXNUM_MARK:
    case IDIO_TYPE_CONSTANT_MARK:
    case IDIO_TYPE_CHARACTER_MARK:
        return idio_as_string (o, 0);
    case IDIO_TYPE_POINTER_MARK:
	{
	    switch (idio_type (o)) {
EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    case ${ctype} in
    pointer)
	cat <<EOF
	    case IDIO_TYPE_C_${CTYPE}:
		if (asprintf (&r, "#C_p-%p{%p free=%d}", o, IDIO_C_TYPE_${CTYPE}_P (o), IDIO_C_TYPE_${CTYPE}_FREEP (o)) == -1) {
		    return NULL;
		}
		break;
EOF
	;;
    pid_t)
	cat <<EOF
	    case IDIO_TYPE_C_${CTYPE}:
		if (asprintf (&r, "%ld", (long) IDIO_C_TYPE_${CTYPE} (o)) == -1) {
		    return NULL;
		}
		break;
EOF
	;;
    off_t)
	cat <<EOF
	    case IDIO_TYPE_C_${CTYPE}:
		if (asprintf (&r, "%jd", (intmax_t) IDIO_C_TYPE_${CTYPE} (o)) == -1) {
		    return NULL;
		}
		break;
EOF
	;;
    *)
	case ${ctype} in
	u*)	sign=u ;;
	*)  sign=d ;;
	esac
	case ${ctype} in
	*char)		size=\"hh${sign}\" ;;
	*short)		size=\"h${sign}\" ;;
	*int)		size=\"${sign}\" ;;
	*long)		size=\"l${sign}\" ;;
	*int8_t)	size=PRI${sign}8 ;;
	*int16_t)	size=PRI${sign}16 ;;
	*int32_t)	size=PRI${sign}32 ;;
	*int64_t)	size=PRI${sign}64 ;;
	float|double)	size=\"g\" ;;
	size_t)		size=\"z${sign}\" ;;
	*)		size=\"${sign}\" ;;
	esac
	cat <<EOF
	    case IDIO_TYPE_C_${CTYPE}:
		if (asprintf (&r, "%" ${size}, IDIO_C_TYPE_${CTYPE} (o)) == -1) {
		    return NULL;
		}
		break;
EOF
	;;
    esac
done

cat <<EOF
	    default:
		return idio_as_string (o, 0);
		break;
	    }
	}
	break;
    default:
	if (asprintf (&r, "#??{%10p}", o) == -1) {
	    return NULL;
	}
	break;
    }

    return r;
}

idio_hi_t idio_hash_C_hashval (IDIO k)
{
    IDIO_ASSERT (k);

    idio_hi_t hv;
    switch (idio_type (k)) {
EOF

for type in "${types[@]}" ; do
    ctype=$(cname "${type}")
    CTYPE=${ctype^^}
    case ${ctype} in
    pointer)
	cat <<EOF
    case IDIO_TYPE_C_${CTYPE}:
	hv = idio_hash_hashval_void (IDIO_C_TYPE_${CTYPE}_P (k));
	break;
EOF
	;;
    *)
	cat <<EOF
    case IDIO_TYPE_C_${CTYPE}:
	hv = idio_hash_hashval_uintmax_t (IDIO_C_TYPE_${CTYPE} (k));
	break;
EOF
	;;
    esac
done
cat <<EOF
    default:
	fprintf (stderr, "idio_hash_C_hashval: type n/k\n");
	IDIO_C_ASSERT (0);
    }

    return hv;
}

IDIO idio_C_number_cast (IDIO co, int type)
{
    IDIO_ASSERT (co);
    IDIO_C_ASSERT (type);

    if (! IDIO_TYPE_POINTERP (co)) {
	char em[BUFSIZ];
	sprintf (em, "idio_C_number_cast: conversion not possible from %s %d to %d", idio_type2string (co), idio_type (co), type);
	idio_error_message (em);
	return idio_S_nil;
    }

    IDIO r = idio_S_nil;
    int fail = 0;
    
    switch (type) {
    case IDIO_TYPE_C_UINT64_T:
	{
	    switch (idio_type (co)) {
	    case IDIO_TYPE_C_INT8_T: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_INT8_T (co)); break;
	    case IDIO_TYPE_C_UINT8_T: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_UINT8_T (co)); break;
	    case IDIO_TYPE_C_INT16_T: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_INT16_T (co)); break;
	    case IDIO_TYPE_C_UINT16_T: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_UINT16_T (co)); break;
	    case IDIO_TYPE_C_INT32_T: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_INT32_T (co)); break;
	    case IDIO_TYPE_C_UINT32_T: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_UINT32_T (co)); break;
	    case IDIO_TYPE_C_INT64_T: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_INT64_T (co)); break;
	    case IDIO_TYPE_C_UINT64_T: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_UINT64_T (co)); break;
	    case IDIO_TYPE_C_CHAR: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_CHAR (co)); break;
	    case IDIO_TYPE_C_UCHAR: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_UCHAR (co)); break;
	    case IDIO_TYPE_C_SHORT: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_SHORT (co)); break;
	    case IDIO_TYPE_C_USHORT: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_USHORT (co)); break;
	    case IDIO_TYPE_C_INT: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_INT (co)); break;
	    case IDIO_TYPE_C_UINT: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_UINT (co)); break;
	    case IDIO_TYPE_C_LONG: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_LONG (co)); break;
	    case IDIO_TYPE_C_ULONG: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_ULONG (co)); break;
	    case IDIO_TYPE_C_FLOAT: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_FLOAT (co)); break;
	    case IDIO_TYPE_C_DOUBLE: r = idio_C_uint64_t ((uint64_t) IDIO_C_TYPE_DOUBLE (co)); break;
	    default:
		fail = 1;
		break;
	    }
	    break;
	}
    case IDIO_TYPE_STRING:
	{
	    switch (idio_type (co)) {
	    case IDIO_TYPE_C_POINTER: r = idio_C_pointer (IDIO_C_TYPE_POINTER_P (co)); break;
	    case IDIO_TYPE_STRING: r = idio_C_pointer ((void *) IDIO_STRING_S (co)); break;
	    case IDIO_TYPE_SUBSTRING: r = idio_C_pointer ((void *) IDIO_SUBSTRING_S (co)); break;
	    default:
		fail = 1;
		break;
	    }
	    break;
	}
    default:
	fail = 1;
	break;
    }

    if (fail) {
	char em[BUFSIZ];
	sprintf (em, "idio_C_number_cast: conversion not possible from %s %d to %d", idio_type2string (co), idio_type (co), type);
	idio_error_message (em);
    }

    return r;
}

void idio_init_auto_c_type ()
{
}

void idio_auto_c_type_add_primtives ()
{
    IDIO_ADD_PRIMITIVE (C_le);
    IDIO_ADD_PRIMITIVE (C_lt);
    IDIO_ADD_PRIMITIVE (C_eq);
    IDIO_ADD_PRIMITIVE (C_ge);
    IDIO_ADD_PRIMITIVE (C_gt);
}

void idio_final_auto_c_type ()
{
}

EOF

exec 1>&3
