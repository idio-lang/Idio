
;; define-condition-type/accessors name super pred & fields
;; field == (field accessor)
define-macro (define-condition-type/accessors name parent pred-fname & fields) {
  %T{
    define $name (make-condition-type '$name $parent $@(map (function (field) { %T{ '$(ph field) } }) fields))

    define-condition-type-accessors-only $name $parent $pred-fname $@fields
  }
}

;; define-condition-type-accessors-only name super pred & fields
;; field == (field accessor)
;;
;; We have this two-step shimmy as the basic conditions (eg. ^error)
;; are defined in C-land for internal use yet the predicate/accessors
;; are defined here, in Idio-land, as it is much easier (and C never
;; uses them anyway).  
;;
;; If we (re-)defined those conditions here as well then we'd have two
;; distinct objects with the same name.  Which is generally considered
;; to be "an issue."
define-macro (define-condition-type-accessors-only name parent pred-fname & fields) {
  arg := (gensym)

  %T{
    define ($pred-fname $arg) {
      and (condition? $arg) \
	  (condition-isa? $arg $name)
    }

    $@(map (function (field) {
	      %T{
		define ($(pht field) $arg) {
                  if ($pred-fname $arg) {
                    condition-ref $arg '$(ph field)
		  } {
		    error '$(pht field) '$pred-fname "not a condition:" $arg
		  }
                } 
	     }
	   })
	   fields)
  }
}

;; define-condition-type
;; 
;; generate default pred/accessor names for
;; define-condition-type/accessors
define-macro (define-condition-type name parent & fields) {
  pred-fname := string->symbol (string-append (symbol->string name) "?")
  fa := map (function (field) {
    list field (string->symbol (string-append 
				(symbol->string name) 
				"-"
				(symbol->string field)))
  }) fields

  %T{
    define-condition-type/accessors $name $parent $pred-fname $@fa
  }
}

;; condition
;;
;; use a sequence of condition-set! expressions rather than than
;; anything more direct to allow for multi-type conditions
define-macro (condition type & field-bindings) {
  c := (gensym)

  %T{
    $c := allocate-condition $type 

    $@(map (function (field-binding) {
              %T{
	        condition-set! $c '$(ph field-binding) $(pht field-binding)
	      }
            })
	   field-bindings)

    $c
  }
}

;; SRFI-36-ish standard conditions
define-condition-type-accessors-only ^i/o-error ^error i/o-error?

define-condition-type-accessors-only ^i/o-handle-error ^i/o-error i/o-handle-error? (handle i/o-error-handle)

define-condition-type-accessors-only ^i/o-read-error   ^i/o-handle-error i/o-read-error?
define-condition-type-accessors-only ^i/o-write-error  ^i/o-handle-error i/o-write-error?
define-condition-type-accessors-only ^i/o-closed-error ^i/o-handle-error i/o-closed-error?

define-condition-type-accessors-only ^i/o-filename-error	    ^i/o-error		       i/o-filename-error? (filename i/o-error-filename)

define-condition-type-accessors-only ^i/o-malformed-filename-error  ^i/o-filename-error        i/o-malformed-filename-error?

define-condition-type-accessors-only ^i/o-file-protection-error     ^i/o-filename-error        i/o-file-protection-error?

define-condition-type-accessors-only ^i/o-file-is-read-only-error   ^i/o-file-protection-error i/o-file-is-read-only-error?

define-condition-type-accessors-only ^i/o-file-already-exists-error ^i/o-filename-error        i/o-file-already-exists-error?

define-condition-type-accessors-only ^i/o-no-such-file-error	    ^i/o-filename-error        i/o-no-such-file-error?

;; Idio generated conditions
define-condition-type-accessors-only ^system-error ^idio-error system-error? (errno system-error-errno)

define-condition-type-accessors-only ^static-error           ^idio-error        static-error?
define-condition-type-accessors-only ^st-variable-error      ^static-error      st-variable-error? (name variable-error-name)
define-condition-type-accessors-only ^st-variable-type-error ^st-variable-error st-variable-type-error?

define-condition-type-accessors-only ^st-function-error      ^static-error      st-function-error?
define-condition-type-accessors-only ^st-function-type-error ^st-function-error st-function-type-error?

define-condition-type-accessors-only ^runtime-error			^idio-error		   runtime-error?
define-condition-type-accessors-only ^rt-variable-error			^runtime-error		   rt-variable-error? (name variable-error-name)
define-condition-type-accessors-only ^rt-dynamic-variable-error         ^rt-variable-error         rt-dynamic-variable-error?
define-condition-type-accessors-only ^rt-dynamic-variable-unbound-error ^rt-dynamic-variable-error rt-dynamic-variable-unbound-error?

define-condition-type-accessors-only ^rt-function-error			^runtime-error		   rt-function-error?
define-condition-type-accessors-only ^rt-function-type-error		^rt-function-error	   rt-function-type-error?


