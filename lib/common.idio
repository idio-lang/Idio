;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; common.idio
;;

define-macro (help x) {
  #T{
    cond ((procedure? $x) {
      props := %procedure-properties $x
      sigstr := hash-ref props :sigstr
      docstr := hash-ref props :docstr-raw
      display* "procedure:" '$x $sigstr "\n"
      display docstr
      #t
    }) ((symbol? $x) {
      module := find-module $x #f
      if module {
        display* "module:" '$x "\n"
        display* "imports" (module-imports module)
        exports := (module-exports module)
        display* "exports" exports
        exports_loop :+ function (exports) {
          if (null? exports) #t \
	     {
	       export := ph exports
	       display* " " export
	       exports_loop (pt exports)
	     }
        }
	;exports_loop exports
      }
      #t
    }) (else {
      edisplay* "help: " '$x ": not a function"
      #f
    })
  }
}

define (autodoc) {
  define (display_indented str prefix) {
    loop :+ function (lines prefix) {
      if (null? lines) #t {
        display prefix
        display (ph lines)
	display "\n"
	loop (pt lines) prefix
      }
    }

    if (string? str) {
      loop (split str "\n") prefix
    }
  }

  define (print_docstr mod sym) {
    val := symbol-value sym mod
    cond ((procedure? val) {
      props := %procedure-properties val
      sigstr := hash-ref props :sigstr
      docstr := hash-ref props :docstr-raw
      display* ".. idio:function::" sym sigstr "\n"
      display_indented docstr "   "
      display "\n"
    }) ((symbol? val) {
      module := find-module val #f
      if module {
        display* "module:" sym "\n"
      } {
        display* "symbol:" sym "\n"
      }
    }) (else {
      edisplay* "help: " mod sym ": not a function"
      #f
    })
  }

  symbol_loop :+ function (module symbols) {
    if (null? symbols) #t {
       print_docstr module (ph symbols)
       symbol_loop module (pt symbols)
    }
  }

  module_loop :+ function (modules) {
    if (null? modules) #t {
       module := ph modules
       symbol_loop module (module-symbols (find-module module))
       module_loop (pt modules)
    }
  }

  module_loop (all-modules)
}

define (atom? x) "predicate to test if object is an atom

:param x: object to test
" {
  not (pair? x)
}

define-macro (defined? s) {
  #T{
    %defined? '$s
  }
}

;; http://stackoverflow.com/questions/15552057/is-it-possible-to-implement-define-macro-in-mit-scheme
define-syntax define-syntax-rule (syntax-rules ()
    ((define-syntax-rule (name & pattern) template)
     (define-syntax name
       (syntax-rules ()
         ((name & pattern) template)))))

define-syntax-rule (when test body ...) (
  if test (begin body ...)
)

define-syntax-rule (unless test body ...) (
  if (not test) (begin body ...)
)

load-handle = {
  orig-load-handle := load-handle

  function (handle) {
    if (not (handle? handle)) (error 'load-handle "not a handle" handle)

    load-handle-k := #n

    trap ^condition (function (cont cond) {
      if (not cont) {
        edisplay "load-handle "
        ewrite handle
        edisplay* ": non-cont-error caught: " cond
        edisplay* "load-handle: invoking safe continuation"
	(idio-thread-state)
        load-handle-k cond
      } {
	raise cont cond
      }
    }) {
      call/cc (function (k) {
	load-handle-k = k
	orig-load-handle handle
      })
    }
  }
}

load = {
  orig-load := load

  function (filename) {
    if (not (string? filename)) (error 'load "not a string" filename)

    load-k := #n

    trap ^condition (function (cont cond) {
      if (not cont) {
	edisplay "load "
	ewrite filename
	edisplay* ": non-cont-error caught: " cond
	edisplay* "load: invoking safe continuation"
	(idio-thread-state)
	load-k cond
      } {
	raise cont cond
      }
    }) {
      call/cc (function (k) {
	load-k = k
	orig-load filename
      })
    }
  }
}

define-macro (suppress-errors & cmd) {
  #T{
    trap ^condition (function (cont cond) {
      if cont {
	;; What should we return?  Something hard to mistake for a
	;; possible normal value.  Probably.
	(void)
      } {
	raise cont cond
      }
    }) {
      if (pair? (ph '$cmd)) {
	$@cmd
      } $cmd
    }
  }
}

;; SRFI-8 receive
;; (define-syntax receive
;;   (syntax-rules ()
;;     ((receive formals expression body ...)
;;      (call-with-values (lambda () expression)
;;                        (lambda formals body ...)))))

define-syntax with-values-from \
  (syntax-rules ()
    ((with-values-from formals expression body ...)
     (call-with-values (function () expression) (function formals body ...))))

