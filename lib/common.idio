;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; common.idio
;;

define (atom? x) "predicate to test if object is an atom

:param x: object to test
" {
  not (pair? x)
}

define-macro (defined? s) {
  #T{
    %defined? '$s
  }
}

;; http://stackoverflow.com/questions/15552057/is-it-possible-to-implement-define-macro-in-mit-scheme
define-syntax define-syntax-rule (syntax-rules ()
    ((define-syntax-rule (name & pattern) template)
     (define-syntax name
       (syntax-rules ()
         ((name & pattern) template)))))

define-syntax-rule (when test body ...) (
  if test (begin body ...)
)

define-syntax-rule (unless test body ...) (
  if (not test) (begin body ...)
)

define-macro (suppress-errors conds & cmd) {
  #T{
    trap $conds (function (c) {
		   ;; What should we return?  Something hard to mistake for a
		   ;; possible normal value.  Probably.
		   (void)
    }) {
      if (pair? (ph '$cmd)) {
	$@cmd
      } $cmd
    }
  }
}

;; SRFI-8 receive
;; (define-syntax receive
;;   (syntax-rules ()
;;     ((receive formals expression body ...)
;;      (call-with-values (lambda () expression)
;;                        (lambda formals body ...)))))

define-syntax with-values-from \
  (syntax-rules ()
    ((with-values-from formals expression body ...)
     (call-with-values (function () expression) (function formals body ...))))

define (display* & x*) {
  p :+ function (x* first) {
	 if (not (null? x*)) {
	   if (not first) (write-char #\space)
	   display (ph x*)
	   p (pt x*) #f
	 }
  }

  p x* #t
  (newline)
}

define (ewrite x) {
  write x (current-error-handle)
}

define (edisplay x) {
  display x (current-error-handle)
}

define (edisplay* & x*) {
  p :+ function (x* first) {
	 if (not (null? x*)) {
	   if (not first) (write-char #\space (current-error-handle))
	   edisplay (ph x*)
	   p (pt x*) #f
	 }
  }

  p x* #t
  newline (current-error-handle)
}

define (hprintf handle fmt & args) "

Invoke the ``%printf`` function on ``handle`` with ``fmt`` and
``args``

:param handle: the handle to load from
:type handle: handle
:param fmt: the format string for printf
:type fmt: string
:param args: any args for the format string
:type args: list

:return: #unspec
" {
  if (null? args) {
    %printf handle fmt
  } {
    apply %printf handle fmt args
  }
}

define (printf fmt & args) "

Invoke the ``hprintf`` function on the current output handle with
``fmt`` and ``args``

:param fmt: the format string for printf
:type fmt: string
:param args: any args for the format string
:type args: list

:return: #unspec
" {
  if (null? args) {
    hprintf (current-output-handle) fmt
  } {
    apply hprintf (current-output-handle) fmt args
  }
}

define (eprintf fmt & args) "

Invoke the ``hprintf`` function on the current error handle with
``fmt`` and ``args``

:param fmt: the format string for printf
:type fmt: string
:param args: any args for the format string
:type args: list

:return: #unspec
" {
  if (null? args) {
    hprintf (current-error-handle) fmt
  } {
    apply hprintf (current-error-handle) fmt args
  }
}

define (sprintf fmt & args) "

Invoke the ``hprintf`` function on an output string handle with
``fmt`` and ``args`` and return the resultant string

:param fmt: the format string for printf
:type fmt: string
:param args: any args for the format string
:type args: list

:return: string
" {
  osh := (open-output-string)
  if (null? args) {
    hprintf osh fmt
  } {
    apply hprintf osh fmt args
  }

  get-output-string osh
}

*features* := #n
*subfeatures* :~ #n

define (require feature & subfeatures) "

Load ``feature`` unless it has previous been successfully required.
``subfeatures`` are available to the loaded code as the dynamic
variable ``*subfeatures*``

:param feature: the name of the feature
:type fmt: symbol
:param subfeatures: names of subfeatures
:type args: list

The file to be loaded is ``(symbol->string feature)`` which must
``(provide feature)``.

:return: #t or #f

" {
  if (memq feature *features*) #t {
    *subfeatures* = subfeatures

    load (symbol->string feature)

    if (memq feature *features*) #t {
      eprintf "%s did not provide %s\n" feature feature
      #f
    }
  }
}

define (provide feature) {
  if (not (memq feature *features*)) {
    *features* = pair feature *features*
    }
}
