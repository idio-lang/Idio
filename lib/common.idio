;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; common.idio
;;

define (atom? x) "predicate to test if object is an atom

:param x: object to test
" {
  not (pair? x)
}

define-macro (defined? s) {
  #T{
    %defined? '$s
  }
}

;; http://stackoverflow.com/questions/15552057/is-it-possible-to-implement-define-macro-in-mit-scheme
define-syntax define-syntax-rule (syntax-rules ()
    ((define-syntax-rule (name & pattern) template)
     (define-syntax name
       (syntax-rules ()
         ((name & pattern) template)))))

define-syntax-rule (when test body ...) (
  if test (begin body ...)
)

define-syntax-rule (unless test body ...) (
  if (not test) (begin body ...)
)

load-handle = {
  orig-load-handle := load-handle

  function (handle) "
load Idio code from ``handle``

``load-handle`` works much like ``load`` except uses a handle
as the source of code

:param handle: the handle to load from
:type filename: string

" {
    if (not (handle? handle)) (error 'load-handle "not a handle" handle)

    load-handle-k := #n

    trap ^condition (function (cont cond) {
		       if (not cont) {
			 condition-report (string-append "load-handle: " (handle-location handle)) cont cond (current-error-handle)
			 ;(idio-thread-state)
			 load-handle-k cond
		       } {
			 raise cont cond
		       }
    }) {
      call/cc (function (k) {
		 load-handle-k = k
		 orig-load-handle handle
      })
    }
  }
}

common-load := {
  orig-load := load

  function (filename) "
load Idio code from ``filename``

:param filename: the filename to load from
:type filename: string

This is the common variant which traps ^idio-error and calls:

" {
    if (not (string? filename)) (error 'load "not a string" filename)

    load-k := #n

    trap ^idio-error (function (cont cond) {
			if (not cont) {
			  condition-report (string-append "load(common): " filename) cont cond (current-error-handle)
			  ;(idio-thread-state)
			  load-k cond
			} {
			  raise cont cond
			}
    }) {
      call/cc (function (k) {
		 load-k = k
		 orig-load filename
      })
    }
  }

  ;%set-property! common-load :docstr-raw (string-append (%property common-load :docstr-raw) (%property orig-load :docstr-raw))
}

define-macro (suppress-errors conds & cmd) {
  #T{
    trap $conds (function (cont cond) {
      if cont {
	;; What should we return?  Something hard to mistake for a
	;; possible normal value.  Probably.
	(void)
      } {
	raise cont cond
      }
    }) {
      if (pair? (ph '$cmd)) {
	$@cmd
      } $cmd
    }
  }
}

;; SRFI-8 receive
;; (define-syntax receive
;;   (syntax-rules ()
;;     ((receive formals expression body ...)
;;      (call-with-values (lambda () expression)
;;                        (lambda formals body ...)))))

define-syntax with-values-from \
  (syntax-rules ()
    ((with-values-from formals expression body ...)
     (call-with-values (function () expression) (function formals body ...))))

define (display* & x*) {
  p :+ function (x* first) {
	 if (not (null? x*)) {
	   if (not first) (write-char #\space)
	   display (ph x*)
	   p (pt x*) #f
	 }
  }

  p x* #t
  (newline)
}

define (ewrite x) {
  write x (current-error-handle)
}

define (edisplay x) {
  display x (current-error-handle)
}

define (edisplay* & x*) {
  p :+ function (x* first) {
	 if (not (null? x*)) {
	   if (not first) (write-char #\space (current-error-handle))
	   edisplay (ph x*)
	   p (pt x*) #f
	 }
  }

  p x* #t
  newline (current-error-handle)
}

define (hprintf handle fmt & args) "

Invoke the ``%printf`` function on ``handle`` with ``fmt`` and
``args``

:param handle: the handle to load from
:type handle: handle
:param fmt: the format string for printf
:type fmt: string
:param args: any args for the format string
:type args: list

:return: #unspec
" {
  if (null? args) {
    %printf handle fmt
  } {
    apply %printf handle fmt (map display-string args)
  }
}

define (printf fmt & args) "

Invoke the ``hprintf`` function on the current output handle with
``fmt`` and ``args``

:param fmt: the format string for printf
:type fmt: string
:param args: any args for the format string
:type args: list

:return: #unspec
" {
  if (null? args) {
    hprintf (current-output-handle) fmt
  } {
    apply hprintf (current-output-handle) fmt args
  }
}

define (eprintf fmt & args) "

Invoke the ``hprintf`` function on the current error handle with
``fmt`` and ``args``

:param fmt: the format string for printf
:type fmt: string
:param args: any args for the format string
:type args: list

:return: #unspec
" {
  if (null? args) {
    hprintf (current-error-handle) fmt
  } {
    apply hprintf (current-error-handle) fmt args
  }
}

define (sprintf fmt & args) "

Invoke the ``hprintf`` function on an output string handle with
``fmt`` and ``args`` and return the resultant string

:param fmt: the format string for printf
:type fmt: string
:param args: any args for the format string
:type args: list

:return: string
" {
  osh := (open-output-string)
  if (null? args) {
    hprintf osh fmt
  } {
    apply hprintf osh fmt args
  }

  get-output-string osh
}

