;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; common.idio
;;

define (atom? x) "predicate to test if object is an atom

:param x: object to test
" {
  not (pair? x)
}

define-macro (defined? s) {
  #T{
    %defined? '$s
  }
}

;; http://stackoverflow.com/questions/15552057/is-it-possible-to-implement-define-macro-in-mit-scheme
define-syntax define-syntax-rule (syntax-rules ()
    ((define-syntax-rule (name & pattern) template)
     (define-syntax name
       (syntax-rules ()
         ((name & pattern) template)))))

define-syntax-rule (when test body ...) (
  if test (begin body ...)
)

define-syntax-rule (unless test body ...) (
  if (not test) (begin body ...)
)

load-handle = {
  orig-load-handle := load-handle

  function (handle) {
    if (not (handle? handle)) (error 'load-handle "not a handle" handle)

    load-handle-k := #n

    trap ^condition (function (cont cond) {
		       if (not cont) {
			 condition-report (string-append "load-handle: " (handle-location handle)) cont cond (current-error-handle)
			 ;(idio-thread-state)
			 load-handle-k cond
		       } {
			 raise cont cond
		       }
    }) {
      call/cc (function (k) {
		 load-handle-k = k
		 orig-load-handle handle
      })
    }
  }
}

load = {
  orig-load := load

  function (filename) {
    if (not (string? filename)) (error 'load "not a string" filename)

    load-k := #n

    trap ^condition (function (cont cond) {
      if (not cont) {
	condition-report (string-append "load: " filename) cont cond (current-error-handle)
	;(idio-thread-state)
	load-k cond
      } {
	raise cont cond
      }
    }) {
      call/cc (function (k) {
	load-k = k
	orig-load filename
      })
    }
  }
}

define-macro (suppress-errors conds & cmd) {
  #T{
    trap $conds (function (cont cond) {
      if cont {
	;; What should we return?  Something hard to mistake for a
	;; possible normal value.  Probably.
	(void)
      } {
	raise cont cond
      }
    }) {
      if (pair? (ph '$cmd)) {
	$@cmd
      } $cmd
    }
  }
}

;; SRFI-8 receive
;; (define-syntax receive
;;   (syntax-rules ()
;;     ((receive formals expression body ...)
;;      (call-with-values (lambda () expression)
;;                        (lambda formals body ...)))))

define-syntax with-values-from \
  (syntax-rules ()
    ((with-values-from formals expression body ...)
     (call-with-values (function () expression) (function formals body ...))))

define (hprintf handle fmt & args) {
  with-output-to handle (function () {
			   if (null? args) {
			     printf fmt
			   } {
			     apply printf fmt (map display-string args)
			   }
  })
}

define (oprintf fmt & args) {
  if (null? args) {
    hprintf (current-output-handle) fmt
  } {
    apply hprintf (current-output-handle) fmt args
  }
}

define (eprintf fmt & args) {
  if (null? args) {
    hprintf (current-error-handle) fmt
  } {
    apply hprintf (current-error-handle) fmt args
  }
}

