;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; command.idio
;;
module job-control
import libc
export (%idio-jobs
	%%last-job
	job-failed
	job-detail
	pipeline-detail
	%prep-process
	background-job
	foreground-job
	wait-for-job

	; default SIGCHLD handler via SIGCHLD clause in
	; default-condition-handler (condition.c) and
	; idio_command_SIGCHLD_signal_handler (command.c) which has
	; idio_vm_invoke_C() call "do-job-notification"

	do-job-notification

	bg-job
	wait
	with-input-from
	with-output-to
	with-error-to
	with-handle-dup
	with-handle-redir

	jobs)


export-struct-accessors-only %idio-process	argv pid completed stopped status
export-struct-accessors-only %idio-job		pipeline procs pgid notified tcattrs stdin stdout stderr
export-struct-accessors-only %idio-status	pid state reason

%%last-job := #n

define (job-as-string job seen) {
  if (%idio-job? job) {
    r := (open-output-string)
    hprintf r "#<SI %%idio-job "

    hprintf r "%s %s " job.pgid job.pipeline

    procs-first := #t
    procs-loop :+ function (procs) {
		    proc := ph procs
		    if (null? proc) #t {
		      if procs-first {
			procs-first = #f
		      } {
			hprintf r "| "
		      }
		      hprintf r "[PID=%s C?=%s S?%s: %s] " proc.pid proc.completed proc.stopped proc.argv
		      procs-loop (pt procs)
		    }
    }

    procs-loop (reverse (%idio-job-procs job))

    hprintf r ">"
    get-output-string r
  } #n
}

%%add-as-string %idio-job job-as-string

;;
;; These algorithms are directly from the libc info pages on Job
;; Control: "info libc" then "Job Control" then "Implementing a Shell"
;;

define (job-is-stopped job) "test if job `job` is stopped

:param job: job to test

:return: #t if job `job` is stopped, #f otherwise
" {
  if (null? job) (error 'job-is-stopped "null job" job)

  loop :+ function (procs) {
	    cond ((null? procs) #t) \
		 ((and (not (%idio-process-completed (ph procs)))
		       (not (%idio-process-stopped (ph procs)))) #f) \
		 (else (loop (pt procs)))
  }

  loop (%idio-job-procs job)
}

define (job-is-completed job) "test if job `job` has completed

:param job: job to test

:return: #t if job `job` has completed, #f otherwise
" {
  if (null? job) (error 'job-is-completed "null job" job)

  loop :+ function (procs) {
	    cond ((null? procs) #t) \
		 ((not (%idio-process-completed (ph procs))) #f) \
		 (else {
		   loop (pt procs)
		 })
  }

  loop (%idio-job-procs job)
}

define (job-failed job) "test if job `job` has failed

:param job: job to test

:return: #t if job `job` has failed, #f otherwise
" {
  if (null? job) (error 'job-failed "null job" job)

  loop :+ function (procs) {
	    if (null? procs) #f {
	      status := %idio-process-status (ph procs)
	      cond ((null? status) {
		loop (pt procs)
	      }) \
		   ((WIFEXITED status) {
		     if (not (C/== (WEXITSTATUS status) 0)) #t {
		       loop (pt procs)
		     }
		   }) \
		   ((WIFSIGNALED status) #t) \
		   (else {
		     loop (pt procs)
		   })
	    }
  }

  if (job-is-completed job) {
    loop (%idio-job-procs job)
  } #f
}

;; job-status => #t/#f
define (job-status job) "test if job `job` has a process status

:param job: job to test

:return: #f if job `job` has a process status, #t otherwise

Note that this is the inverse behaviour you might expect.
" {
  if (null? job) (error 'job-status "null job" job)

  loop :+ function (procs) {
	    if (null? procs) #t {
	      status := %idio-process-status (ph procs)
	      cond ((null? status) {
		loop (pt procs)
	      }) \
		   ((WIFEXITED status) {
		     if (not (C/== (WEXITSTATUS status) 0)) #f {
		       loop (pt procs)
		     }
		   }) \
		   ((WIFSIGNALED status) #f) \
		   (else {
		     loop (pt procs)
		   })
	    }
  }

  ;; return rightmost non-zero exit status or the status from the last
  ;; (or any as they all succeeded but the last is top of procs)
  ;;
  ;; NB. the procs were pushed onto the list in reverse order so
  ;; walking down the list we encounter the rightmost first
  procs := %idio-job-procs job
  loop procs
}

;; job-detail => '(exit X) or '(killed Y)
define (job-detail job) "return the process status of job `job`

:param job: job

:return: a (kind value) list

kind can be: 'exit or 'killed
value can be: exit status for 'exit or signal number for 'killed
" {
  if (null? job) (error 'job-detail "null job" job)

  loop :+ function (procs) {
	    if (null? procs) #f {
	      status := %idio-process-status (ph procs)
	      cond ((null? status) {
		loop (pt procs)
	      }) \
		   ((WIFEXITED status) {
		     if (not (C/== (WEXITSTATUS status) 0)) (list 'exit (WEXITSTATUS status)) {
		       loop (pt procs)
		     }
		   }) \
		   ((WIFSIGNALED status) (list 'killed (WTERMSIG status))) \
		   (else {
		     loop (pt procs)
		   })
	    }
  }

  ;; return rightmost non-zero exit status or the status from the last
  ;; (or any as they all succeeded but the last is top of procs)
  ;;
  ;; NB. the procs were pushed onto the list in reverse order so
  ;; walking down the list we encounter the rightmost first
  procs := %idio-job-procs job
  or (loop procs) \
     (list 'exit (WEXITSTATUS (%idio-process-status (ph procs))))
}

define (pipeline-detail job) "return the process status of each process in the pipeline `job`

:param job: job

:return: a list of (kind value) lists

kind can be: 'exit or 'killed
value can be: exit status for 'exit or signal number for 'killed
" {
  if (null? job) (error 'pipeline-detail "null job" job)

  loop :+ function (procs st) {
	    if (null? procs) st {
	      status := %idio-process-status (ph procs)
	      cond ((null? status) {
		loop (pt procs) (pair (list 'no-status) st)
	      }) \
		   ((WIFEXITED status) {
		     loop (pt procs) (pair (list 'exit (WEXITSTATUS status)) st)
		   }) \
		   ((WIFSIGNALED status) {
		     loop (pt procs) (pair (list 'killed (WTERMSIG status)) st)
		   }) \
		   (else {
		     loop (pt procs) (pair (list 'unknown) st)
		   })
	    }
  }

  loop (%idio-job-procs job) #n
}

define (mark-process-status pid status) "update the process status of pid `pid` with `status`

:param pid: process id
:param status: Unix process status

:return: #t if the update was successfull, #f otherwise

Store the `status` of the process `pid` that was returned by
waitpid(2).  Return #f if all went well, some true value otherwise.

This (inverted) convention follows the Libc texinfo algorithm and is
for the benefit of the do loops in update-status_ and wait-for-job_.
" {
  cond ((C/> pid 0) {
    jobs-loop :+ function (jobs) {
		   cond ((null? jobs) {
		     edisplay* "no child process" pid
		     #t
		   }) \
			(else {
			  ;; procs-loop follows the same convention as the outer
			  ;; jobs-loop as returning success (#f!) will be the return
			  ;; value of jobs-loop
			  procs-loop :+ function (procs) {
					  cond ((null? procs) #t) \
					       ((C/== pid (%idio-process-pid (ph procs))) {
						 set-%idio-process-status! (ph procs) status
						 if (WIFSTOPPED status) {
						   set-%idio-process-stopped! (ph procs) #t
						 } {
						   set-%idio-process-completed! (ph procs) #t
						   if (WIFSIGNALED status) {
						     edisplay* "Job Terminated: kill" (append-string "-" (signal-name (WTERMSIG status)))  pid
						   }
						 }
						 #f
					       }) \
					       (else {
						 procs-loop (pt procs)
					       })
			  }

			  (and (procs-loop (%idio-job-procs (ph jobs)))
			       (jobs-loop (pt jobs)))
			})
    }

    jobs-loop %idio-jobs
  })\
       ((or (C/== pid 0)
	    (C/== errno ECHILD)) {
	      ;; edisplay* "mps: pid ==" pid ", errno ==" (strerrno errno)
	      #t
	    }) \
       (else {
	 ;; an error in waitpid would have been signalled there
	 error 'mark-process-status "inconceivable!" pid status
       })
}

define (update-status) "update the process status of any outstanding pids

:return: #<unspec>
" {
  waitany := function () {
    apply values (waitpid WAIT_ANY (WUNTRACED C/| WNOHANG))
  }

  do () ((call-with-values waitany mark-process-status) #n) #n
}

define (wait-for-job job) "wait for job `job` to be stopped or completed

:param job: job

:return: job status
" {
  waitany := function () {
    apply values (waitpid WAIT_ANY WUNTRACED)
  }

  do () ((not (and (not (call-with-values waitany mark-process-status))
	           (not (job-is-stopped job))
	           (not (job-is-completed job))))
         #n) #n

  ;eprintf "wfj: %5s C=%s S=%s %s %s\n" (%idio-job-pgid job) (job-is-completed job) (job-is-stopped job) (if (job-failed job) "failed" "succeeded") (pipeline-detail job)

  if (job-failed job) {
    c := make-condition ^rt-command-status-error "job failed" job (pipeline-detail job) (job-detail job)
    raise c
  }

  job-status job
}

define (format-job-info job msg) "display to stderr `msg` alongside job `job` details

:param job: job
:param msg: string

:return: #<unspec>
" {
  if %idio-interactive {
    jd := job-detail job
    if (not (equal? (list 'exit (C/integer-> 0)) jd)) {
      eprintf "job %5s: %s: %s: %s\n" (%idio-job-pgid job) (%idio-job-pipeline job) msg jd
    }
  }
}

define (do-job-notification) "notify of any job status changes" {
  ;; edisplay* "djn:" (map (function (job) {
  ;; 			   %idio-job-pipeline job
  ;; 			 }) %idio-jobs)
  ;; get the latest data
  (update-status)

  failed-jobs := #n

  loop :+ function (jobs njobs) {
	    cond ((null? jobs) (reverse njobs)) \
		 (else {
		   job := ph jobs
		   cond ((job-is-completed job) {
		     format-job-info job "completed"
		     if (job-failed job) {
		       failed-jobs = pair job failed-jobs
		     }
		     ;; remove job from list (by not including it!)
		     loop (pt jobs) njobs
		   }) \
			((job-is-stopped job) {
			  if (not (%idio-job-notified job)) {
			    format-job-info job "stopped"
			    set-%idio-job-notified! job #t
			  }
			  loop (pt jobs) (pair job njobs)
			}) \
			(else {
			  loop (pt jobs) (pair job njobs)
			})
		 })
  }

  %idio-jobs = loop %idio-jobs #n

  ;; This report->raise condition for failed jobs is badly positioned.
  ;; The problem lies in that we, do-job-notification, have run on the
  ;; back of a SIGCHLD event but will have had nothing to report (in
  ;; the simplest case) because our call to update-status resulted in
  ;; a pid of 0 and/or errno ECHILD.  That's because foreground-job,
  ;; say, was blocked in wait-for-job who had (successfully) called
  ;; waitpid but further processing has been suspended while the
  ;; event handler runs.  Only when we return will it be able to
  ;; continue and usefully call mark-process-status with a proper pid
  ;; and status.

  ;; This isn't an Idio-issue, the Libc texinfo C version (from which
  ;; this is ported) appears to suffer the same problem.

  ;; Underlying that is that, perhaps, we shouldn't be calling
  ;; do-job-notification from the signal handler.  The texinfo
  ;; suggests SIGCHLD->do-job-notification should only enabled when
  ;; waiting at the prompt for user input and not, say, while
  ;; generically processing loaded files.

  ;; All good, but that leaves us with the question of when to raise a
  ;; condition to alert the Idio code?  I've migrated that to
  ;; wait-for-job itself.  It knows the job is complete and can assert
  ;; if the job failed.

  if (not (null? failed-jobs)) {
    report :+ function (jobs) {
		cond ((null? jobs) #n) \
		     (else {
		       job := ph jobs
		       c := make-condition ^rt-command-status-error "job failed" job (pipeline-detail job) (job-detail job)
		       ;edisplay* "djn: raising for job" job
		       ;raise c

		       ;; if someone handled that error and returned (anything)
		       ;; then we can loop onto the next
		       report (pt jobs)
		     })
    }

    report failed-jobs
  }

  #n
}

define (foreground-job job cont) "place job `job` in the foreground

:param job: job
:param cont: boolean

:return: job status

If `cont` is set a SIGCONT is sent to the process group
" {

  if %idio-interactive {
    ;; put the job in the foreground
    suppress-errors ^idio-error tcsetpgrp %idio-terminal (%idio-job-pgid job)
  }
  if cont {
    if %idio-interactive {
      tcsetattr %idio-terminal TCSADRAIN (%idio-job-tcattrs job)
    }
    kill (- (%idio-job-pgid job)) SIGCONT
  }

  r := wait-for-job job

  if %idio-interactive {
    ;; put the shell back in the foreground
    tcsetpgrp %idio-terminal %idio-pgid

    ;; save the job's current terminal state
    set-%idio-job-tcattrs! job (tcgetattr %idio-terminal)

    ;; restore the shell's terminal state
    tcsetattr %idio-terminal TCSADRAIN %idio-tcattrs
  }

  r
}

define (background-job job cont) "place job `job` in the background

:param job: job
:param cont: boolean

:return: #t

If `cont` is set a SIGCONT is sent to the process group

Backgrounding a job is always successful hence returns #t
" {
  job-pgid := %idio-job-pgid job
  if cont {
    kill (- job-pgid) SIGCONT
  }

  ;; result of background-job is always successful, ie. #t
  #t
}

define (hangup-job job) "hangup job `job`

:param job: job

:return: #<unspec>

Send the process group of `job` a SIGCONT then a SIGHUP
" {
  job-pgid := %idio-job-pgid job
  kill (- job-pgid) SIGCONT
  kill (- job-pgid) SIGHUP

  ;; result of hungup-job is #t
  #t
}

define (stop-job job) {
  job-pgid := %idio-job-pgid job
  kill (- job-pgid) SIGSTOP

  ;; result of stop-job is #t
  #t
}

define (mark-job-as-running job) "mark job `job` as running

:param job: job

:return: #<unspec>

In particular, mark job `job` as not stopped.
" {
  loop :+ function (procs) {
	    cond ((null? procs) #n) \
		 (else {
		   set-%idio-process-stopped! (ph procs) #f
		   loop (pt procs)
		 })
  }

  loop (%idio-job-procs job)
  set-%idio-job-notified! job #f
}

define (continue-job job foreground) "mark job `job` as running and foreground it if required

:param job: job
:param foreground: boolean

:return: #<unspec>
" {
  mark-job-as-running job
  if foreground {
    foreground-job job #t
  } {
    background-job job #t
  }
}

define (default-child-handler c) "
The default condition handler set in child processes.

It will report the condition and exit (1).
" {
  condition-report "child exec issue" c (current-error-handle)
  eprintf "child process %s will exit (1)\n" (getpid)
  libc/exit 1
}

define (prep-io infile outfile errfile) "prepare the IO for the current process

:param infile: to be used for stdin
:param outfile: to be used for stdout
:param errfile: to be used for stderr

:return: #<unspec>
" {
  ;; edisplay* "prep-io" infile outfile errfile

  ;; The nominal libc texinfo algorithm is:

  ;;   Switch stdin/stdout/stderr to the supplied file descriptor if
  ;;   it isn't already stdin/stdout/stderr.  (Here, the supplied file
  ;;   descriptor would commonly be one end or other of a pipe(2).)

  ;;   We can then close the supplied file descriptor if it is >
  ;;   STDERR_FILENO (ie. > 2) and isn't one of the later ones.

  ;;   That latter case is for: ls > "foo" 2>& 1

  ;;   Here, "stdout" will be fd N, say, having opened "foo" which we
  ;;   would close because N > 2, before we reached the "2>& 1" which
  ;;   tries to dup2(N, 2)

  ;; However, we *must* set the Idio thread-specific
  ;; input/output/error handles.  The problem lies in that this code,
  ;; prep-io, is most likely called from the | operator in Idio-land
  ;; in which case we are the *first* IO redirection.  However, the
  ;; later IO redirections, (> >& etc.) reference the Idio
  ;; thread-specific IO handles and *not* simply the STD*_FILENO file
  ;; descriptors.  They do that because we can (seamlessly) use
  ;; file-handles, string-handles, file descriptor numbers and
  ;; ... instead of straight file names.  The use of string-handles
  ;; means we have to create temporary files etc..

  ;; In fact they call (stdin-fileno) etc. which furtles about and
  ;; conjures up a file descriptor which represents stdin etc..

  ;; So, leave the final resolution of handle -> *nix file descriptor
  ;; until the last thing before execve().  Just set Idio-level
  ;; params.

  if (not (C/== infile STDIN_FILENO)) {
    ;dup2 infile STDIN_FILENO
    set-input-handle! (open-input-file-from-fd infile)

    ;; if ((C/> infile STDERR_FILENO) and
    ;; 	(not ((C/== infile outfile) or
    ;; 	      (C/== infile errfile)))) {
    ;;   close infile
    ;; }
  }

  if (not (C/== outfile STDOUT_FILENO)) {
    ;dup2 outfile STDOUT_FILENO
    set-output-handle! (open-output-file-from-fd outfile)

    ;; if ((C/> outfile STDERR_FILENO) and
    ;; 	(not (C/== outfile errfile))) {
    ;;   close outfile
    ;; }
  }

  if (not (C/== errfile STDERR_FILENO)) {
    ;dup2 errfile STDERR_FILENO
    set-error-handle! (open-output-file-from-fd errfile)

    ;; if (C/> errfile STDOUT_FILENO) {
    ;;   close errfile
    ;; }
  }
}

define (%prep-process pgid infile outfile errfile foreground) "prepare the current process

:param pgid: process group to be joined
:param infile: to be used for stdin
:param outfile: to be used for stdout
:param errfile: to be used for stderr
:param foreground: place job in foreground

:return: #<unspec>
" {
  ;edisplay* "%pp:" (getpid) infile outfile errfile
  if %idio-interactive {
    pid := (getpid)
    if (C/== pgid 0) {
      pgid = pid
    }

    ;; put the process in the process group -- dupe of parent to avoid
    ;; race conditions
    suppress-errors ^idio-error setpgid pid pgid

    if foreground {
      ;; give the terminal to the process group -- dupe of parent to
      ;; avoid race conditions
      if %idio-interactive {
	suppress-errors ^idio-error tcsetpgrp %idio-terminal pgid
      }
    }

    ;; set job control signals back to default
    signal SIGINT SIG_DFL
    signal SIGQUIT SIG_DFL
    signal SIGTSTP SIG_DFL
    signal SIGTTIN SIG_DFL
    signal SIGTTOU SIG_DFL
    signal SIGCHLD SIG_DFL
  }

  prep-io infile outfile errfile
}

define-infix-operator | 1700 {
  ;; edisplay* "operator" op before after

  foreground := #t
  if (eq? 'bg-job (ph before)) {
    before = pt before
    foreground = #f
  }

  pipeline := append before (append (list op) after)

  ;; we want a list of lists -- a list of the |-separated commands
  split :+ function (op op-args expr after) {
    cond ((null? after)		(reverse (pair (reverse expr) op-args))) \
         ((not (pair? after))	(error '| "bad syntax" op (reverse op-args) after)) \
	 ((eq? op (ph after))	(split op (pair (reverse expr) op-args) #n (pt after))) \
	 (else			(split op op-args (pair (ph after) expr) (pt after)))
  }

  op-args := split op (list before) #n after

  ;; we have created new lists so we should expand any operators in
  ;; them
  op-args = map operator-expand op-args

  ;; pgrp-pipe:

  ;; There's a little process coordination trickery ported from Bash
  ;; -- noting that if the race condition occurs in a slick and fast
  ;; pure C environment then our meandering and inefficient
  ;; byte-compiled script has no hope!
  ;;
  ;; We need to prevent the first process in the pipeline from
  ;; starting until all the others are in place -- otherwise you can
  ;; have the first process, the process group leader, run and exit
  ;; before you manage to start any of the others!  That also leaves
  ;; the small issue of trying to call setpgid with a process group
  ;; that no longer exists (and, worse, could have been replaced with
  ;; a different process all together).  That's all bad for business.
  ;;
  ;; The trick is to open another pipe and have the first process
  ;; block reading from the pipe just before it starts.  All the other
  ;; processes in the pipeline simply close the pipe when they're
  ;; about to exelibc/start.  When the last one has closed the pipe the
  ;; first will have its blocking read() return (with zero bytes, ie
  ;; EOF -- we don't care) and we're good to go.
  ;;
  ;; Incidentally, as we created the pipe in the main Idio process, it
  ;; too holds the pipe open so we can be fairly confident that all
  ;; the child processes are set up and running when the main Idio
  ;; process closes the (last?) pipe write-end.
  ;;
  ;; Well, probably, there's always a race condition between closing
  ;; the pgrp-pipe and exec()ing or starting processing the Idio code
  ;; in which the last process can be prevented from running before
  ;; all the previous processes have been and gone.  But we've done a
  ;; decent job, what more can we do?


  ;; Hygiene

  ;; Looping over the list of commands prepping the children uses a
  ;; number of variables which are at risk of polluting the called
  ;; code (if it is Idio code -- obviously if it is an external
  ;; command we exec()'d it wouldn't matter).  Strict hygiene, please!

  stdin := (gensym)
  infile := (gensym)
  close-stdin := (gensym)
  stdout := (gensym)
  outfile := (gensym)
  recover-stdout := (gensym)
  stderr := (gensym)
  pgid := (gensym)
  job := (gensym)
  proc-id := (gensym)
  pipe := (gensym)
  pgrp-pipe := (gensym)
  proc := (gensym)
  pid := (gensym)
  status := (gensym)

  nprocs := length op-args
  #T{
    {
      $stdin := (stdin-fileno) ; STDIN_FILENO
      $close-stdin := #f
      if (pair? $stdin) {
	$stdin = ph $stdin
	$close-stdin = $stdin
      }
      $infile := $stdin
      $stdout := (stdout-fileno) ; STDOUT_FILENO
      $recover-stdout := #f
      if (pair? $stdout) {
	$recover-stdout = pht $stdout
	$stdout = ph $stdout
      }
      $outfile := $stdout
      $stderr := (stderr-fileno) ; STDERR_FILENO
      $pgid := 0
      $job := make-%idio-job '$pipeline #n $pgid #f #n $stdin $stdout $stderr

      $proc-id := 1
      $pipe := #n
      $pgrp-pipe := (pipe)

      $@(map (function (cmd) {
	        #T{
		  {
		    $proc := make-%idio-process '$cmd -1 #f #f #n

		    ;; NB. Update the procs list asap as we can get a
		    ;; signal about processes in the pipeline at any
		    ;; time including, annoyingly, before we've
		    ;; finished creating the pipeline.
		    ;; do-job-notification/update-status will want to
		    ;; have a proc entry to update.
		    set-%idio-job-procs! $job (pair $proc (%idio-job-procs $job))

		    if (lt $proc-id $nprocs) {
		      $pipe = (pipe)
		      $outfile = (pipe-writer $pipe)
		    } {
		      $outfile = $stdout
		    }
		    $pid := (fork)
		    if (C/== $pid 0) {
		      set-default-handler! ^idio-error default-child-handler
		      %prep-process $pgid $infile $outfile $stderr $foreground

		      ;; The Libc texinfo page seems to have missed
		      ;; this.  On the basis that a $pipe is owned
		      ;; (created?) by the left hand process of the
		      ;; two being connected, then *infile* is the
		      ;; (pipe-reader $pipe) of the left-hand
		      ;; process and will have been closed in
		      ;; %prep-process, above (unless it was $stdin).

		      ;; In turn, the current (pipe-reader $pipe)
		      ;; will become the $infile of the right-hand
		      ;; process (as the parent Idio also has it open
		      ;; and will pass it on).  But what of us?  Who
		      ;; closes (pipe-reader $pipe) in us?

		      ;; Ah, OK.  We do.
		      if (lt $proc-id $nprocs) {
			close (pipe-reader $pipe)
		      }

		      ;; We don't have the same problem with
		      ;; (pipe-writer $pipe) because we only create
		      ;; the $pipe when we know there is another
		      ;; process in the pipeline and $outfile
		      ;; immediately becomes (pipe-writer $pipe).

		      ;; $infile is a left-over from the pipe of the
		      ;; left hand process and we are suffering an
		      ;; off-by-one error and the left-over one is the
		      ;; current (pipe-reader $pipe) we have in our
		      ;; hands.

		      if (C/== $pgid 0) {
			close (pipe-writer $pgrp-pipe)

			;; $pgid is 0 so we must be the first in the
			;; pipeline -- block reading a single byte
			;; from the $pgrp-pipe
			libc/read (pipe-reader $pgrp-pipe) 1
			close (pipe-reader $pgrp-pipe)
                      } {
			close (pipe-reader $pgrp-pipe)
			close (pipe-writer $pgrp-pipe)
		      }

		      ;; edisplay* "child" (getpid) "cmd" '$cmd
		      cond ((pair? (ph '$cmd)) {
			$@cmd
		      }) \
			   (else $cmd)

		      ;; If {cmd} was an external command then this
		      ;; child will have exec()'d it otherwise it is
		      ;; some Idio scripting whereon it will do its
		      ;; thing and continue onto here.  So we ought to
		      ;; stop before this child continues back into
		      ;; the main Idio engine.

		      exit 0
		    } {
		      set-%idio-process-pid! $proc $pid
		      if %idio-interactive {
			if (C/== $pgid 0) {
			  $pgid = $pid
			  set-%idio-job-pgid! $job $pgid
			}
			suppress-errors ^idio-error setpgid $pid $pgid
		      }
		    }

		    ;; tidy up any trailing pipes
		    if (not (C/== $infile $stdin)) {
		      close $infile
		    }
		    if (not (C/== $outfile $stdout)) {
		      close $outfile
		    }

		    $infile = (pipe-reader $pipe)
		    $proc-id = $proc-id + 1
		  }
	        }
      })
	 op-args)

      ;; finally let the first process go
      close (pipe-reader $pgrp-pipe)
      close (pipe-writer $pgrp-pipe)

      %idio-jobs = pair $job %idio-jobs
      %%last-job = $job

      $status := #f
      cond ((not %idio-interactive) {
	$status = wait-for-job $job
      }) \
	   ($foreground {
	     $status = foreground-job $job #f
	   }) \
	   (else {
	     $status = background-job $job #f
	   })

      if $close-stdin {
	close $close-stdin
      }

      if $recover-stdout {
	;; if the job was backgrounded then this won't do much!
        ih := open-input-file-from-fd $stdout
	seek-handle ih 0 'set
        display (read-lines ih) $recover-stdout
	close-handle ih
      }

      $status
    }
  }
}

define-template (fork-command foreground & cmd) {
  stdin          := (gensym)
  close-stdin    := (gensym)
  stdout         := (gensym)
  recover-stdout := (gensym)
  stderr         := (gensym)
  recover-stderr := (gensym)
  pgid           := (gensym)
  proc           := (gensym)
  job            := (gensym)
  pid            := (gensym)
  status         := (gensym)

  #T{
    {
      $stdin       := (stdin-fileno) ; STDIN_FILENO
      $close-stdin := #f
      if (pair? $stdin) {
	$stdin       = ph $stdin
	$close-stdin = $stdin
      }

      $stdout         := (stdout-fileno) ; STDOUT_FILENO
      $recover-stdout := #f
      if (pair? $stdout) {
	$recover-stdout = pht $stdout
	$stdout         = ph $stdout
      }

      $stderr         := (stderr-fileno) ; STDERR_FILENO
      $recover-stderr := #f
      if (pair? $stderr) {
	$recover-stderr = pht $stderr
	$stderr         = ph $stderr
      }
      $pgid := 0
      $proc := make-%idio-process '$cmd -1 #f #f #n
      $job := make-%idio-job '$cmd (list $proc) $pgid #f #n $stdin $stdout $stderr

      $pid := (fork)
      cond ((C/== $pid 0) {
	set-default-handler! ^idio-error default-child-handler
	%prep-process $pgid $stdin $stdout $stderr $foreground
	cond ((pair? (ph '$cmd)) {
	  $@cmd
	}) \
	     (else $cmd)

	exit 0
      }) \
	   (else {
	     set-%idio-process-pid! $proc $pid
	     if %idio-interactive {
	       $pgid = $pid
	       set-%idio-job-pgid! $job $pgid
	       suppress-errors ^idio-error setpgid $pid $pgid
	     }
	   })

      %idio-jobs = pair $job %idio-jobs
      %%last-job = $job

      $status := #f
      cond ((not %idio-interactive) {
	$status = wait-for-job $job
      })\
	   ($foreground {
	     $status = foreground-job $job #f
	   }) \
	   (else {
	     $status = background-job $job #f
	   })

      if $close-stdin {
	close $close-stdin
      }

      if $recover-stdout {
        ih := open-input-file-from-fd $stdout

	;; NB the temporary file has just been written to so the file
	;; pointer is currently at the end, we need to set it back to
	;; the start to be able to read anything!
	seek-handle ih 0 'set
        display (read-lines ih) $recover-stdout
	close-handle ih
      }

      if $recover-stderr {
        ih := open-input-file-from-fd $stderr

	;; NB the temporary file has just been written to so the file
	;; pointer is currently at the end, we need to set it back to
	;; the start to be able to read anything!
	seek-handle ih 0 'set
        display (read-lines ih) $recover-stderr
	close-handle ih
      }

      $status
    }
  }
}

define-template (fg-job & cmd) {
  #T{ fork-command #t $@cmd }
}

define-template (bg-job & cmd) {
  #T{ fork-command #f $@cmd }
}

define (wait & jobs) {
  notify := #f

  loop :+ function (jobs) {
	    if (null? jobs) #t {
	      notify = #t
	      wait-for-job (ph jobs)
	      loop (pt jobs)
	    }
  }

  if (null? jobs) {
    jobs = %idio-jobs
  }

  ;; edisplay* "wait jobs:" (map (function (job) {
  ;; 				%idio-job-pipeline job
  ;; 			      }) jobs)
  loop jobs

  ;; display* "notify?" notify
  if notify (do-job-notification)
}

;; with-handle-redir type s/d thunk
;;
;; wrapper functions with-input-from, with-output-to and with-error-to
;; are identical barring some "directional" function calls.  We'll
;; have a generic function instead.
;;
;; {type} is the symolic name of the handle being modified: 'input,
;; 'output, 'error
;;
;; {s/d} (source/destination) can be:
;; 1. a handle (file or string)
;; 2. a literal string which will be interpreted as the name of the
;;    file to open as per:
;;      open-output-file {s/d} or
;;      open-input-file {s/d}
;; 3. #n as shorthand for the string "/dev/null"
;;
;; {thunk} is the 0-arg function to invoke
with-handle-redir := {
  current-input-handle	:= current-input-handle
  current-output-handle := current-output-handle
  current-error-handle	:= current-error-handle
  set-input-handle!	:= set-input-handle!
  set-output-handle!	:= set-output-handle!
  set-error-handle!	:= set-error-handle!

  function (type s/d thunk) {
    ;; handle-oriented indirection function/variables
    get-current-h := #f
    open-file-h   := #f
    set-h!        := #f
    dir-file-h?   := #f
    dir-string-h? := #f
    msg-h         := #f
    cond ((eq? type 'input) {
      get-current-h = current-input-handle
      open-file-h   = open-input-file
      set-h!        = set-input-handle!
      dir-file-h?   = input-file-handle?
      dir-string-h? = input-string-handle?
      msg-h         = "input"
    }) \
	 ((eq? type 'output) {
	   get-current-h = current-output-handle
	   open-file-h   = open-output-file
	   set-h!        = set-output-handle!
	   dir-file-h?   = output-file-handle?
	   dir-string-h? = output-string-handle?
	   msg-h         = "output"
	 }) \
	 ((eq? type 'error) {
	   get-current-h = current-error-handle
	   open-file-h   = open-output-file
	   set-h!        = set-error-handle!
	   dir-file-h?   = output-file-handle?
	   dir-string-h? = output-string-handle?
	   msg-h         = "output"
	 }) \
	 (else (error 'with-handle-redir "unexpected handle type" type))

    ;; old and new handles
    old-h := (get-current-h)
    new-h := #f

    ;; if we create a new handle we need to close it afterwards
    close-h := #f

    cond ((dir-file-h? s/d) {
      file-handle-fflush s/d
      new-h = s/d
    }) \
	 ((file-handle? s/d) (error 'with-handle-redir (append-string "not an " msg-h "-file-handle") s/d)) \
	 ((dir-string-h? s/d) (new-h = s/d)) \
	 ((string-handle? s/d) (error 'with-handle-redir (append-string "not an " msg-h "-string-handle") s/d)) \
	 ((string? s/d) {
	   new-h = open-file-h s/d
	   close-file-handle-on-exec new-h
	   close-h = #t
	 }) \
	 ((null? s/d) {
	   new-h = open-file-h "/dev/null"
	   close-file-handle-on-exec new-h
	   close-h = #t
	 }) \
	 (else (error 'with-handle-redir (append-string "unexpected " msg-h) s/d))

    if new-h {
      set-h! new-h
    } {
      error 'with-handle-redir (append-string "unexpected " msg-h) s/d
    }

    unwind-protect {
      (thunk)
    } {
      if close-h {
	close-handle new-h
      }
      set-h! old-h
    }
  }
}

define (with-input-from src thunk) {
  with-handle-redir 'input src thunk
}

define (with-output-to dst thunk) {
  with-handle-redir 'output dst thunk
}

define (with-error-to dst thunk) {
  with-handle-redir 'error dst thunk
}

;; with-handle-dup type new thunk
;;
;; nominal functions dup-input-from, dup-output-to and dup-error-to
;; are identical barring some "directional" function calls.  We'll
;; have a generic function instead.
;;
;; {type} is the symolic name of the handle being modified: 'input,
;; 'output, 'error
;;
;; {new} can be:
;; 1. a handle (file or string)
;; 2. a C int or fixnum which will be interpreted as the name of the
;;    file descriptor to call dup2(2) with
;;
;; {thunk} is the 0-arg function to invoke
with-handle-dup := {
  current-input-handle  := current-input-handle
  current-output-handle := current-output-handle
  current-error-handle  := current-error-handle
  set-input-handle!     := set-input-handle!
  set-output-handle!    := set-output-handle!
  set-error-handle!     := set-error-handle!

  function (type new thunk) {
    ;; edisplay* 'with-handle-dup type new
    ;; handle-oriented indirection function/variables
    get-current-h := #f
    set-h!        := #f
    dir-file-h?   := #f
    dir-string-h? := #f
    msg-h         := #f
    cond ((eq? type 'input) {
      get-current-h = current-input-handle
      set-h!        = set-input-handle!
      dir-file-h?   = input-file-handle?
      dir-string-h? = input-string-handle?
      msg-h         = "input"
    }) \
	 ((eq? type 'output) {
	   get-current-h = current-output-handle
	   set-h!        = set-output-handle!
	   dir-file-h?   = output-file-handle?
	   dir-string-h? = output-string-handle?
	   msg-h         = "output"
	 }) \
	 ((eq? type 'error) {
	   get-current-h = current-error-handle
	   set-h!        = set-error-handle!
	   dir-file-h?   = output-file-handle?
	   dir-string-h? = output-string-handle?
	   msg-h         = "output"
	 }) \
	 (else (error 'with-handle-dup "unexpected handle type" type))

    ;; old and new handles
    old-h := (get-current-h)
    new-h := #f

    cond ((dir-file-h? new) {
      file-handle-fflush new
      new-h = new
    }) \
	 ((file-handle? new) (error 'with-handle-dup (append-string "not an " msg-h "-file-handle") new)) \
	 ((dir-string-h? new) (new-h = new)) \
	 ((string-handle? new) (error 'with-handle-dup (append-string "not an " msg-h "-string-handle") new)) \
	 ((or (C/int? new)
	      (fixnum? new)) {
		if (C/int? new) (new = C/->integer new)
		cond ((eq? new 0) {
		  new-h = (current-input-handle)
		}) \
		     ((eq? new 1) {
		       new-h = (current-output-handle)
		     }) \
		     ((eq? new 2) {
		       new-h = (current-error-handle)
		     })
	      }) \
	 (else (error 'with-handle-dup (append-string "unexpected " msg-h) new))

    cond (new-h {
      set-h! new-h
    })\
	 (else {
	   error 'with-handle-dup (append-string "unexpected " msg-h) new
	 })

    unwind-protect {
      (thunk)
    } {
      set-h! old-h
    }
  }
}

;; ... < e1 ...
;; ... > e1 ...
;; ... 2> e1 ...
define-infix-operator > 1600 {
  suffix := #n

  if (and (pair? after)
	  (pair? (pt after))
	  (not (null? (pt (pt after))))) {
    suffix = pt after
    after = (list (ph after))
  }

  type := #f
  cond ((eq? op '<) {
         type = 'input
       }) \
       ((eq? op '>) {
         type = 'output
       }) \
       ((eq? op '2>) {
         type = 'error
       }) \
       (else (error op "unexpected op" op))

  result := #n

  if (null? suffix) {
    result = #T{ with-handle-redir '$type $(ph after) (function () {
        $before
      })
    }
  } {
    result = #T{ with-handle-redir '$type $(ph after) (function () {
        $(operator-expand (append before suffix))
      })
    }
  }

  ;; edisplay* "with-handle-redir result:" result
  result
}

define-infix-operator < 1600 \>
define-infix-operator 2> 1600 \>

;; ... <& e1 ...
;; ... >& e1 ...
;; ... 2>& e1 ...
define-infix-operator >& 1600 {
  suffix := #n

  if (and (pair? after)
	  (pair? (pt after))
	  (not (null? (pt (pt after))))) {
    suffix = pt after
    after = (list (ph after))
  }

  type := #f
  cond ((eq? op '<&) {
	 type = 'input
       }) \
       ((eq? op '>&) {
	 type = 'output
       }) \
       ((eq? op '2>&) {
	 type = 'error
       }) \
       (else (error op "unexpected op" op))

  result := #n

  if (null? suffix) {
    result = #T{ with-handle-dup '$type $(ph after) (function () {
        $before
      })
    }
  } {
    result = #T{ with-handle-dup '$type $(ph after) (function () {
        $(operator-expand (append before suffix))
      })
    }
  }

  ;; edisplay* "with-handle-dup result:" result
  result
}

define-infix-operator <& 1600 \>&
define-infix-operator 2>& 1600 \>&

define (jobs) "display the state of outstanding jobs" {
  first-j := #t
  jobs-loop :+ function (jobs) {
		 cond ((null? jobs) {
		   #t
		 }) \
		      (else {
			job := ph jobs
			if first-j {
			  first-j = #f
			  printf "%5s %s\n" "pgid" "job-pipeline"
			}
			printf "%5s %s\n" job.pgid job.pipeline

			first-p := #t

			procs-loop :+ function (procs) {
					proc := ph procs
					if (null? proc) #t {
					  if first-p {
					    first-p = #f
					    printf "  %5s %2s %2s %s\n" "pid" "C?" "S?" "argv"
					  }
					  printf "  %5s %s %s %s\n" proc.pid proc.completed proc.stopped proc.argv
					  procs-loop (pt procs)
					}
			}

			(and (procs-loop (reverse (%idio-job-procs job)))
			     (jobs-loop (pt jobs)))
		      })
  }

  jobs-loop %idio-jobs
}

provide job-control
