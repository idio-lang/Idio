;;
;; Copyright (c) 2015 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; closure.idio
;;

;; SRFI 17 Generalized set!

;; The general 'setter' meme is for when you want to set! the result
;; of a procedure call:
;;
;;   set! (foo ...) val
;;
;; which the meme says is rewritten as:
;;
;;   (setter foo) ... val
;;
;; ie. call {setter} to look up the "setter" of foo -- which will be a
;; procedure -- and call that with all of the original arguments.
;;
;; How do you bootstrap this?  How do you set the setter of foo?  Why:
;;
;;   set! (setter foo) setter-of-foo
;;
;; of course!.  But wait, this looks like calling set! on the result
;; of a procedure call.  According to the original meme we will now be
;; calling:
;;
;;   (setter setter) foo setter-of-foo
;;
;; Which means that {setter} itself needs a setter whose job is to set
;; the setter of its first argument!  If we can magically craft the
;; setter of {setter} then everything else just follows.
;;
;; :setter is an example of a property of a procedure.
;;
;; NB The canonical implementation of keyword lists uses, um, lists so
;; it doesn't need to do this bootstrap-a-keyword-table mularkey.
;;
;; Why a keyword-table size of 4?  We don't have many procedure
;; properties so why waste space?
{
  ;; bootstrap {setter}'s properties
  setter-kwt := %procedure-properties setter
  if (null? setter-kwt) {
    setter-kwt = (make-keyword-table 4)
    %set-procedure-properties! setter setter-kwt
  }

  ;; actually set {setter}'s setter to a function that takes a proc
  ;; and a setter.  From the example above:
  ;;
  ;;   (setter setter) foo setter-of-foo
  ;;
  ;; means this function will be called with foo and setter-of-foo as
  ;; arguments
  ;;
  ;; The body of {setter}'s setter will do for {proc} what we've just
  ;; done by hand for {setter} itself.
  keyword-set! setter-kwt :setter (function (proc setter) {
    ;; bootstrap proc's properties
    proc-kwt := %procedure-properties proc
    if (null? proc-kwt) {
      proc-kwt = (make-keyword-table 4)
      %set-procedure-properties! proc proc-kwt
    }

    ;; actually set proc's setter
    keyword-set! proc-kwt :setter setter
  })
}

;; standard setters
set! (setter ph)				set-ph!
set! (setter pt)				set-pt!
set! (setter array-ref)				array-set!
set! (setter hash-ref)				hash-set!
set! (setter string-ref)			string-set!
set! (setter struct-instance-ref)		struct-instance-set!
set! (setter %struct-instance-ref-direct)	%struct-instance-set-direct!

;; the . operator uses value-index so it needs a setter
set! (setter value-index)			set-value-index!
