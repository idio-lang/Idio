;;
;; Copyright (c) 2015, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; condition.idio
;;


;; define-condition-type/accessors name super pred & fields
;; field == (field accessor)
define-macro (define-condition-type/accessors name parent pred-fname & fields) {
  #T{
    define $name (make-condition-type '$name $parent $@(map (function (field) { #T{ '$(ph field) } }) fields))

    define-condition-type-accessors-only $name $parent $pred-fname $@fields
  }
}

;; define-condition-type-accessors-only name super pred & fields
;; field == (field accessor)
;;
;; We have this two-step shimmy as the basic conditions (eg. ^error)
;; are defined in C-land for internal use yet the predicate/accessors
;; are defined here, in Idio-land, as it is much easier (and C never
;; uses them anyway).
;;
;; If we (re-)defined those conditions here as well then we'd have two
;; distinct objects with the same name.  Which is generally considered
;; to be "an issue."
define-macro (define-condition-type-accessors-only name parent pred-fname & fields) {
  arg := (gensym)

  #T{
    define ($pred-fname $arg) {
      and (condition? $arg) \
	  (condition-isa? $arg $name)
    }

    $@(map (function (field) {
	      #T{
		define ($(pht field) $arg) {
                  if ($pred-fname $arg) {
                    condition-ref $arg '$(ph field)
		  } {
		    error '$(pht field) '$pred-fname "not a condition:" $arg
		  }
                }
	     }
	   })
	   fields)
  }
}

;; define-condition-type
;;
;; generate default pred/accessor names for
;; define-condition-type/accessors
define-macro (define-condition-type name parent & fields) {
  pred-fname := string->symbol (string-append (symbol->string name) "?")
  fa := map (function (field) {
	       list field (string->symbol (string-append
					   (symbol->string name)
					   "-"
					   (symbol->string field)))
  }) fields

  #T{
    define-condition-type/accessors $name $parent $pred-fname $@fa
  }
}

;; condition
;;
;; use a sequence of condition-set! expressions rather than than
;; anything more direct to allow for multi-type conditions
define-macro (condition type & field-bindings) {
  c := (gensym)

  #T{
    $c := allocate-condition $type

    $@(map (function (field-binding) {
              #T{
	        condition-set! $c '$(ph field-binding) $(pht field-binding)
	      }
    })
       field-bindings)

    $c
  }
}

define-condition-type-accessors-only ^error				^condition			error?

define-condition-type-accessors-only ^idio-error			^error				idio-error? \
	(message idio-error-message) \
	(location idio-error-location) \
	(detail idio-error-detail)

;; SRFI-36-ish standard conditions
define-condition-type-accessors-only ^i/o-error				^idio-error			i/o-error?

define-condition-type-accessors-only ^i/o-handle-error			^i/o-error			i/o-handle-error? \
	(handle i/o-error-handle)

define-condition-type-accessors-only ^i/o-read-error			^i/o-handle-error		i/o-read-error?
define-condition-type-accessors-only ^i/o-write-error			^i/o-handle-error		i/o-write-error?
define-condition-type-accessors-only ^i/o-closed-error			^i/o-handle-error		i/o-closed-error?

define-condition-type-accessors-only ^i/o-filename-error		^i/o-error			i/o-filename-error? \
	(filename i/o-filename-error-filename)

define-condition-type-accessors-only ^i/o-malformed-filename-error	^i/o-filename-error		i/o-malformed-filename-error?

define-condition-type-accessors-only ^i/o-file-protection-error		^i/o-filename-error		i/o-file-protection-error?

define-condition-type-accessors-only ^i/o-file-is-read-only-error	^i/o-file-protection-error	i/o-file-is-read-only-error?

define-condition-type-accessors-only ^i/o-file-already-exists-error	^i/o-filename-error		i/o-file-already-exists-error?

define-condition-type-accessors-only ^i/o-no-such-file-error		^i/o-filename-error		i/o-no-such-file-error?

define-condition-type-accessors-only ^read-error			^idio-error			read-error? \
	(line read-error-line) \
	(position read-error-position)

define-condition-type-accessors-only ^evaluation-error			^idio-error			evaluation-error? \
	(expr evaluation-error-expr)

;; Idio generated conditions
define-condition-type-accessors-only ^system-error			^idio-error			system-error? \
	(errno system-error-errno)

define-condition-type-accessors-only ^static-error			^idio-error			static-error?
define-condition-type-accessors-only ^st-variable-error			^static-error			st-variable-error? \
	(name st-variable-error-name)
define-condition-type-accessors-only ^st-variable-type-error		^st-variable-error		st-variable-type-error?

define-condition-type-accessors-only ^st-function-error			^static-error			st-function-error?
define-condition-type-accessors-only ^st-function-arity-error		^st-function-error		st-function-arity-error?

define-condition-type-accessors-only ^runtime-error			^idio-error			runtime-error?

define-condition-type-accessors-only ^rt-parameter-type-error		^runtime-error			rt-parameter-type-error?
define-condition-type-accessors-only ^rt-parameter-nil-error		^runtime-error			rt-parameter-nil-error?

define-condition-type-accessors-only ^rt-variable-error			^runtime-error			rt-variable-error? \
	(name rt-variable-error-name)
define-condition-type-accessors-only ^rt-variable-unbound-error		^rt-variable-error		rt-variable-unbound-error?
define-condition-type-accessors-only ^rt-dynamic-variable-error         ^rt-variable-error		rt-dynamic-variable-error?
define-condition-type-accessors-only ^rt-dynamic-variable-unbound-error ^rt-dynamic-variable-error	rt-dynamic-variable-unbound-error?

define-condition-type-accessors-only ^rt-environ-variable-error         ^rt-variable-error		rt-environ-variable-error?
define-condition-type-accessors-only ^rt-environ-variable-unbound-error ^rt-environ-variable-error	rt-environ-variable-unbound-error?

define-condition-type-accessors-only ^rt-computed-variable-error         ^rt-variable-error		rt-computed-variable-error?
define-condition-type-accessors-only ^rt-computed-variable-no-accessor-error ^rt-computed-variable-error	rt-computed-variable-no-accessor-error?

define-condition-type-accessors-only ^rt-function-error			^runtime-error			rt-function-error?
define-condition-type-accessors-only ^rt-function-type-error		^rt-function-error		rt-function-type-error?

define-condition-type-accessors-only ^rt-module-error			^runtime-error			rt-module-error? \
	(module rt-module-error-module)
define-condition-type-accessors-only ^rt-module-unbound-error		^rt-module-error		rt-module-unbound-error?
define-condition-type-accessors-only ^rt-module-symbol-unbound-error	^rt-module-error		rt-module-symbol-unbound-error? \
	(symbol rt-module-symbol-unbound-error-symbol)

define-condition-type-accessors-only ^rt-glob-error			^runtime-error			rt-glob-error? \
	(pattern rt-glob-error-pattern)

define-condition-type-accessors-only ^rt-command-exec-error		^runtime-error			rt-command-exec-error?

define-condition-type-accessors-only ^rt-command-status-error		^runtime-error			rt-command-status-error? \
	(status rt-command-status-error-status)

define-condition-type-accessors-only ^rt-array-bounds-error		^runtime-error			rt-array-bounds-error? \
	(index rt-array-bounds-error-index)

define-condition-type-accessors-only ^rt-hash-key-not-found		^runtime-error			rt-hash-key-not-found? \
	(key rt-hash-key-not-found-key)

define-condition-type-accessors-only ^rt-bignum-conversion-error	^runtime-error			rt-bignum-conversion-error? \
	(bignum rt-bignum-conversion-error-bignum)

define-condition-type-accessors-only ^rt-fixnum-conversion-error	^runtime-error			rt-fixnum-conversion-error? \
	(fixnum rt-fixnum-conversion-error-fixnum)

define-condition-type-accessors-only ^rt-divide-by-zero-error		^runtime-error			rt-divide-by-zero-error?

define-condition-type-accessors-only ^rt-signal				^error				rt-signal? \
	(signal rt-signal-signal)

;; have a common method for reporting on a condition
define (condition-report prefix cont cond & args) "print a report on `condition`

:param prefix: a distinguishing string
:param cont: is the condition continuable
:param cond: the condition
:param args: print to optional handle

:return: unspecified
" {
  oh := (current-output-handle)
  if (and (not (null? args))
	  (pair? args)) {
	    oh = ph args
	  }

  define (cr-printf fmt & args*) {
    if (null? args*) {
      hprintf oh fmt
    } {
      apply hprintf oh fmt args*
    }
  }

  if (not (null? prefix)) {
    cr-printf (string-append prefix ":")
  }

  if (and (struct-type-isa (struct-instance-type cond) ^idio-error)
	  (not (or (struct-type-isa (struct-instance-type cond) ^read-error)
		   (struct-type-isa (struct-instance-type cond) ^evaluation-error)
		   (struct-type-isa (struct-instance-type cond) ^rt-command-status-error)))) {
		     cr-printf "%s:" cond.location
		     cr-printf "%s:" (struct-type-name (struct-instance-type cond))
		     cr-printf "%s" cond.message
		     if (not (null? cond.detail)) {
		       cr-printf ": detail %s" cond.detail
		     }
  }

  cond ((struct-type-isa (struct-instance-type cond) ^i/o-handle-error) {
    cr-printf ": handle %s " cond.handle
  }) \
       ((struct-type-isa (struct-instance-type cond) ^i/o-filename-error) {
	 cr-printf ": filename %s " cond.filename
       }) \
       ((struct-type-isa (struct-instance-type cond) ^read-error) {
	 cr-printf "%s:%s:%s" cond.location cond.line cond.message
       }) \
       ((struct-type-isa (struct-instance-type cond) ^evaluation-error) {
	 cr-printf "%s:%s:%s" cond.location cond.expr cond.message
       }) \
       ((struct-type-isa (struct-instance-type cond) ^system-error) {
          cr-printf "errno %s (%s)" cond.errno (libc/errno-name cond.errno)
        }) \
       ((struct-type-isa (struct-instance-type cond) ^st-variable-error) {
	 cr-printf ": variable %s" cond.variable
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-variable-error) {
	 cr-printf ": variable %s" cond.variable
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-module-error) {
	 cr-printf ": module %s" cond.module
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-module-symbol-unbound-error) {
	 cr-printf ": symbol %s" cond.symbol
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-glob-error) {
	 cr-printf ": pattern %s" cond.pattern
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-command-status-error) {
	 job := idio-error-location cond
	 header := #t
	 loop :+ function (procs details) {
		   cond ((null? procs) #t) \
			(else {
			  if header {
			    header = #f
			    cr-printf "  flags: C - completed; !C - not completed; S - stopped\n"
			    cr-printf "  proc: %-6s %-3s %-10s %s\n" "pid" "fl" "status" "cmd"
			  }
			  proc := ph procs
			  cr-printf "  proc: %6s %2s%s %10s %s\n" proc.pid (if proc.completed " C" "!C") (if proc.stopped "S" " ") (ph details) proc.argv
			  loop (pt procs) (pt details)
			})
	 }

	 cr-printf "\n"
	 loop (reverse (%idio-job-procs job)) (reverse (pipeline-detail job))
	 cr-printf "pipeline: %s => %s" (%idio-job-pipeline job) cond.status
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-array-bounds-error) {
	 cr-printf ": index %s" cond.index
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-hash-key-not-found) {
	 cr-printf ": key %s" cond.key
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-bignum-conversion-error) {
	 cr-printf ": bignum %s" cond.bignum
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-fixnum-conversion-error) {
	 cr-printf ": fixnum %s" cond.fixnum
       }) \
       ((struct-type-isa (struct-instance-type cond) ^rt-signal) {
          cr-printf "signal %s (%s)" cond.signum (libc/signal-name cond.signum)
       }) \
       ((struct-type-isa (struct-instance-type cond) ^error) {
          cr-printf " %s" (struct-type-name (struct-instance-type cond))
       }) \
       (else {
          cr-printf " %s" cond
        })
  display "\n" oh
}
