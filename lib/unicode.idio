#*

Copyright (c) 2020 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

unicode.idio

This was going to be a port of SRFI-14 character-sets library to be
modified with John Cowan's 2019 Unicode comments,
https://srfi.schemers.org/srfi-14/contrib/unicode-2019/CharsetDefs.html
as noted in https://srfi.schemers.org/srfi-14/srfi-14.html.

However with bitsets available as an Idio type (created for this
purpose) I think we can skip it and derive the nominal SRFI-14-ish
character sets from UnicodeData.txt (and others) directly.


http://www.unicode.org/reports/tr44/

Broadly, Unicode have defined 17 Planes each with a potential for
65,536 code points.  That makes any mapping be at least 1114109
entries long.  Blocks within those Planes are assigned for groups of
code points with a common ancestry.  For example, code points U+0000
through U+007F are ASCII.  Some of those blocks are complete because
the group is well defined, eg. ASCII, whereas others include
unassigned code points leaving room for later additions.  The order in
which those blocks are assigned is (probably) an editorial whim.

Note: even though Unicode Planes 4-13 are currently unassigned, see
https://en.wikipedia.org/wiki/Plane_(Unicode), it isn't clear that
Unicode will stick to 17 planes.  Given that we have to read the
Unicode UCD files we might as well leave the actual number of Unicode
code points/Planes dynamic based on reading the files.

Further note: given that those 10 planes are unassigned, perhaps we
should invent a sparse bitset format for charsets saving at least 650k
bits per charset.

UnicodeData.txt is a long list (34k entries as of Unicode 13.0.0) of
individual code points and code point ranges (whose individual code
point properties are derivable within the range).  Each code point has
a primary Category: Letter lowercase, "Ll", Letter uppercase, "Lu",
Number digit, "Nd", Symbol Math, "Sm" etc.

The set of code points is not contiguous and the current highest
numbered code point is 10FFFD, Plane 16 Private Use, Last.

DerivedCoreProperties.txt is a fairly long list (12k lines) which
summaries collections of code points which share a common Property:
Alphabetic, Math, etc..  For example, the Property Lowercase is the
collection of the Category Ll plus the Property Other_Lowercase.

Other_Lowercase includes 00AA, FEMININE ORDINAL INDICATOR and 00BA,
MASCULINE ORDINAL INDICATOR, for example.

DerivedCoreProperties.txt defines other Properties such as
ID_Start (the first code point of an identifier) and
ID_Continue (subsequent code points for identifiers).  I'm not sure
where they get their information from as surely such a set is
language-specific?  You are welcome to read
http://www.unicode.org/reports/tr31/ to understand their thinking.

PropList.txt is a fairly short file with more Properties.  Here we're
specifically looking to pick up on the White_Space Property.

If you did trust their ID_Start then you might want to be aware of
their Other_ID_Start too.

Again, it's hard to see how they can clearly define a
Pattern_White_Space and Pattern_Syntax Properties.


In the meanwhile this file, unicode.idio, serves a dual purpose.  By
default it defines the SRFI-14 char-set bitsets as derived from the
above files.

Where did they come from?  If the need arises, set char-set:ascii to
#n (as commented out below) then the bottom section of code kicks in
and (load "unicode") will trawl through the above files and print to
stdout the current bitsets.  You can then replace the definitions in
this file.

Other generated tables include:

char-set:simple-upper-case-map and char-set:simple-lower-case-map
which use the fields (12) and (13) in UnicodeData.txt to generate
simple mappings.

Beware that these two tables are NOT symmetric.  For example:

to-lower (0130;LATIN CAPITAL LETTER I WITH DOT ABOVE)	= 0069;LATIN SMALL LETTER I
to-upper (0069;LATIN SMALL LETTER I)			= 0049;LATIN CAPITAL LETTER I
to-lower (0049;LATIN CAPITAL LETTER I)			= 0069;LATIN SMALL LETTER I

to-upper (01C8;LATIN CAPITAL LETTER L WITH SMALL LETTER J)	= 01C7;LATIN CAPITAL LETTER LJ
to-lower (01C7;LATIN CAPITAL LETTER LJ)				= 01C9;LATIN SMALL LETTER LJ
to-upper (01C9;LATIN SMALL LETTER LJ)				= 01C7;LATIN CAPITAL LETTER LJ

*#

module unicode
export (
	 ; SRFI-14 char-sets
	 char-set:lower-case
	 char-set:upper-case
	 char-set:title-case
	 char-set:letter
	 char-set:digit
	 char-set:letter+digit
	 char-set:graphic
	 char-set:printing
	 char-set:whitespace
	 char-set:iso-control
	 char-set:punctuation
	 char-set:symbol
	 char-set:hex-digit
	 char-set:blank
	 char-set:ascii
	 char-set:empty
	 char-set:full

	 ; useful derived map
	 char-set:simple-upper-case-map
	 char-set:simple-lower-case-map

	 ; support for SRFI-115
	 char-set:nonl
	 char-set:control
	 char-set:word-constituent

	 ; %X == intersection ASCII X
	 %char-set:letter
	 %char-set:lower-case
	 %char-set:upper-case
	 %char-set:digit
	 %char-set:letter+digit
	 %char-set:punctuation
	 %char-set:symbol
	 %char-set:graphic
	 %char-set:whitespace
	 %char-set:printing
	 %char-set:iso-control
)

ascii-char-set:size := 128
char-set:size := 0

load "unicode.auto"

;char-set:ascii := #n

if (null? char-set:ascii) {
  UD := "../utils/Unicode/UnicodeData.txt"
  DCP := "../utils/Unicode/DerivedCoreProperties.txt"
  PL := "../utils/Unicode/PropList.txt"

  char-sets := '(
		  (char-set:lower-case "property Lowercase")
		  (char-set:upper-case "property Uppercase")
		  (char-set:title-case "category Lt")
		  (char-set:letter "property Alphabetic")
		  (char-set:digit "category Nd")
		  (char-set:letter+digit "property Alphabetic + category Nd")
		  (char-set:graphic "category L* + category N* + category M* + category S* + category P*")
		  (char-set:printing "char-set:graphic + char-set:whitespace")
		  (char-set:whitespace "property White_Space")
		  (char-set:iso-control "0000..001F + 007F..009F")
		  (char-set:punctuation "category P*")
		  (char-set:symbol "category S*")
		  (char-set:hex-digit "0030..0039 + 0041..0046 + 0061..0066")
		  (char-set:blank "category Zs + 0009")
		  (char-set:ascii "0000..007F")
		  (char-set:empty "empty")
		  (char-set:full "full == ~ empty")
		  (char-set:nonl "char-set:full excl. #\\newline")
		  (char-set:control "0000..001F")
		  (char-set:word-constituent "char-set:letter+digit + _")
		  (%char-set:letter "char-set:letter restricted to ASCII range")
		  (%char-set:lower-case "char-set:lower-case restricted to ASCII range")
		  (%char-set:upper-case "char-set:upper-case restricted to ASCII range")
		  (%char-set:digit "char-set:digit restricted to ASCII range")
		  (%char-set:letter+digit "char-set:letter+digit restricted to ASCII range")
		  (%char-set:punctuation "char-set:punctuation restricted to ASCII range")
		  (%char-set:symbol "char-set:symbol restricted to ASCII range")
		  (%char-set:graphic "char-set:graphic restricted to ASCII range")
		  (%char-set:whitespace "char-set:whitespace restricted to ASCII range")
		  (%char-set:printing "char-set:printing restricted to ASCII range")
		  (%char-set:iso-control "char-set:iso-control restricted to ASCII range")
  )

  char-set:size := 0
  num-cp := 0
  define (ud-max-cp) {
    loop :+ function () {
	      if (eof? (current-input-handle)) #n {
		num-cp = num-cp + 1
		line := (read-line)
		;display* line
		parts := split-string line ";"
		if (gt (string-length (ph parts)) 0) {
		  d := read-number (ph parts) 16
		  if (gt d char-set:size) {
		    char-set:size = d
		  }
		}
		(loop)
	      }
    }
    (loop)
  }

  eprintf "Parsing %s\n" UD

  with-input-from-file UD ud-max-cp

  ascii-char-set:lower-case	:= make-bitset ascii-char-set:size
  ascii-char-set:upper-case	:= make-bitset ascii-char-set:size
  ascii-char-set:title-case	:= make-bitset ascii-char-set:size
  ascii-char-set:letter		:= make-bitset ascii-char-set:size
  ascii-char-set:digit		:= make-bitset ascii-char-set:size
  ; ascii-char-set:letter+digit is a merge, see below
  ascii-char-set:graphic	:= make-bitset ascii-char-set:size
  ; ascii-char-set:printing is a merge, see below
  ascii-char-set:whitespace	:= make-bitset ascii-char-set:size
  ascii-char-set:iso-control	:= make-bitset ascii-char-set:size
  ascii-char-set:punctuation	:= make-bitset ascii-char-set:size
  ascii-char-set:symbol		:= make-bitset ascii-char-set:size
  ascii-char-set:hex-digit	:= make-bitset ascii-char-set:size
  ascii-char-set:blank		:= make-bitset ascii-char-set:size
  ascii-char-set:ascii		:= make-bitset ascii-char-set:size
  ascii-char-set:empty		:= make-bitset ascii-char-set:size
  ascii-char-set:full		:= bitset-not ascii-char-set:empty
  ascii-char-set:nonl		:= copy-bitset ascii-char-set:full
  clear-bitset! ascii-char-set:nonl (char->integer #\newline)
  ; ascii-char-set:word-constituent is derived from ascii-char-set:letter+digit, see below
  ; The %X char-sets are (obviously?) derived

  ascii-char-set:simple-upper-case-map := make-hash #n #n 64 ; 26
  ascii-char-set:simple-lower-case-map := make-hash #n #n 64 ; 26

  char-set:lower-case	:= make-bitset char-set:size
  char-set:upper-case	:= make-bitset char-set:size
  char-set:title-case	:= make-bitset char-set:size
  char-set:letter	:= make-bitset char-set:size
  char-set:digit	:= make-bitset char-set:size
  ; char-set:letter+digit is a merge, see below
  char-set:graphic	:= make-bitset char-set:size
  ; char-set:printing is a merge, see below
  char-set:whitespace	:= make-bitset char-set:size
  char-set:iso-control	:= make-bitset char-set:size
  char-set:punctuation	:= make-bitset char-set:size
  char-set:symbol	:= make-bitset char-set:size
  char-set:hex-digit	:= make-bitset char-set:size
  char-set:blank	:= make-bitset char-set:size
  char-set:ascii	:= make-bitset char-set:size
  char-set:empty	:= make-bitset char-set:size
  char-set:full		:= bitset-not char-set:empty
  char-set:nonl		:= copy-bitset char-set:full
  clear-bitset! char-set:nonl (char->integer #\newline)
  ; char-set:word-constituent is derived from char-set:letter+digit, see below
  ; The %X char-sets are (obviously?) derived

  char-set:simple-upper-case-map := make-hash #n #n 2500 ; 2303
  char-set:simple-lower-case-map := make-hash #n #n 2500 ; 2303

  define (ud-parser) {
    loop :+ function () {
	      if (eof? (current-input-handle)) #n {
		num-cp = num-cp + 1
		line := (read-line)
		;display* line
		parts := split-string-exactly line ";"
		if (gt (string-length (ph parts)) 0) {
		  d := read-number (ph parts) 16

		  cat := phtt parts

		  cond ((string=? cat "Lt") {
		    set-bitset! char-set:title-case d

		    ; I don't think there are any Titlecase characters in ASCII
		    if (lt d ascii-char-set:size) {
		      set-bitset! ascii-char-set:title-case d
		    }
		  }) \
		       ((string=? cat "Nd") {
			 set-bitset! char-set:digit d

			 if (lt d ascii-char-set:size) {
			   set-bitset! ascii-char-set:digit d
			 }
		       }) \
		       ((string=? cat "Zs") {
			 set-bitset! char-set:blank d

			 if (lt d ascii-char-set:size) {
			   set-bitset! ascii-char-set:blank d
			 }
		       })

		  cat1 := string-ref cat 0

		  case cat1 \
		       ((#\L #\N #\M #\S #\P) {
			 set-bitset! char-set:graphic d

			 if (lt d ascii-char-set:size) {
			   set-bitset! ascii-char-set:graphic d
			 }
		  })

		  case cat1 \
		       ((#\P) {
			 set-bitset! char-set:punctuation d

			 if (lt d ascii-char-set:size) {
			   set-bitset! ascii-char-set:punctuation d
			 }
		  }) \
		       ((#\S) {
			 set-bitset! char-set:symbol d

			 if (lt d ascii-char-set:size) {
			   set-bitset! ascii-char-set:symbol d
			 }
		       })

		  ; upper & lower case mappings
		  if (ge (length parts) 13) {
		    uc-cp := nth parts 13
		    if (gt (string-length uc-cp) 0) {
		      hash-set! char-set:simple-upper-case-map d (read-number uc-cp 16)

		      if (lt d ascii-char-set:size) {
			hash-set! ascii-char-set:simple-upper-case-map d (read-number uc-cp 16)
		      }
		    }
		  } (eprintf "no UC in %d %s from %s\n" (length parts) parts line)
		  if (ge (length parts) 14) {
		    lc-cp := nth parts 14
		    if (gt (string-length lc-cp) 0) {
		      hash-set! char-set:simple-lower-case-map d (read-number lc-cp 16)

		      if (lt d ascii-char-set:size) {
			hash-set! ascii-char-set:simple-lower-case-map d (read-number lc-cp 16)
		      }
		    }
		  }
		}
		(loop)
	      }
    }
    (loop)
  }

  with-input-from-file UD ud-parser

  eprintf "Parsing %s\n" PL

  define (pl-parser) {
    loop :+ function () {
	      if (eof? (current-input-handle)) #n {
		line := (read-line)
		case (string-ref line 0) ((#\#) #n) \
					 (else {
					   parts := split-string line "#"
					   if (gt (string-length (ph parts)) 0) {
					     dcp_parts := split-string (ph parts) ";"
					     range := map (function (n) {
							     read-number n 16
					     }) (split-string (ph dcp_parts) "..")
					     case (length range) ((1) (range = (list (ph range) (ph range)))) \
								 ((2) #n) \
								 (else {
								   eprintf "%s: %s elements in code point range: %s\n" (handle-location (current-input-handle)) (length range) line
								   error 'dcp-parser "unexpected number of elements" line
								 })

					     range-loop :+ function (bs n e) {
						       if (gt n e) #n {
							 set-bitset! bs n
							 range-loop bs (n + 1) e
						       }
					     }

					     cond ((string=? (pht dcp_parts) " White_Space ") {
					       range-loop char-set:whitespace (ph range) (pht range)

					       if (lt (pht range) ascii-char-set:size) {
						 range-loop ascii-char-set:whitespace (ph range) (pht range)
					       }
					     })
					   }
					 })
		(loop)
	      }
    }
    (loop)
  }

  with-input-from-file PL pl-parser

  eprintf "Parsing %s\n" DCP

  define (dcp-parser) {
    c := 0
    m := 0
    loop :+ function () {
	      if (eof? (current-input-handle)) #n {
		line := (read-line)
		case (string-ref line 0) ((#\#) #n) \
					 (else {
					   parts := split-string line "#"
					   if (gt (string-length (ph parts)) 0) {
					     dcp_parts := split-string (ph parts) ";"
					     range := map (function (n) {
							     c = c + 1
							     d := read-number n 16
							     if (gt d m) {
							       m = d
							     }
							     d
					     }) (split-string (ph dcp_parts) "..")
					     case (length range) ((1) (range = (list (ph range) (ph range)))) \
								 ((2) #n) \
								 (else {
								   eprintf "%s: %s elements in code point range: %s\n" (handle-location (current-input-handle)) (length range) line
								   error 'dcp-parser "unexpected number of elements" line
								 })
					     range-loop :+ function (bs n e) {
						       if (gt n e) #n {
							 set-bitset! bs n
							 range-loop bs (n + 1) e
						       }
					     }

					     cond ((string=? (pht dcp_parts) " Lowercase ") {
					       range-loop char-set:lower-case (ph range) (pht range)

					       if (lt (pht range) ascii-char-set:size) {
						 range-loop ascii-char-set:lower-case (ph range) (pht range)
					       }
					     }) \
						  ((string=? (pht dcp_parts) " Uppercase ") {
						    range-loop char-set:upper-case (ph range) (pht range)

						    if (lt (pht range) ascii-char-set:size) {
						      range-loop ascii-char-set:upper-case (ph range) (pht range)
						    }
						  }) \
						  ((string=? (pht dcp_parts) " Alphabetic ") {
						    range-loop char-set:letter (ph range) (pht range)

						    if (lt (pht range) ascii-char-set:size) {
						      range-loop ascii-char-set:letter (ph range) (pht range)
						    }
						  })
					   }
					 })
		(loop)
	      }
    }
    (loop)
  }

  with-input-from-file DCP dcp-parser

  ascii-char-set:letter+digit := merge-bitset ascii-char-set:letter ascii-char-set:digit
  ascii-char-set:printing := merge-bitset ascii-char-set:graphic ascii-char-set:whitespace
  ascii-char-set:word-constituent := copy-bitset ascii-char-set:letter+digit
  set-bitset! ascii-char-set:word-constituent (char->integer #\_)

  char-set:letter+digit := merge-bitset char-set:letter char-set:digit
  char-set:printing := merge-bitset char-set:graphic char-set:whitespace
  char-set:word-constituent := copy-bitset char-set:letter+digit
  set-bitset! char-set:word-constituent (char->integer #\_)

  bs-range-loop :+ function (bs n e) {
	    if (gt n e) #n {
	      set-bitset! bs n
	      bs-range-loop bs (n + 1) e
	    }
  }

  bs-range-loop ascii-char-set:iso-control #x0000 #x001F
  set-bitset! ascii-char-set:iso-control #x007F

  bs-range-loop ascii-char-set:hex-digit #x0030 #x0039
  bs-range-loop ascii-char-set:hex-digit #x0041 #x0046
  bs-range-loop ascii-char-set:hex-digit #x0061 #x0066

  set-bitset! ascii-char-set:blank #x0009

  bs-range-loop ascii-char-set:ascii #x0000 #x007f

  bs-range-loop char-set:iso-control #x0000 #x001F
  bs-range-loop char-set:iso-control #x007F #x009F

  bs-range-loop char-set:hex-digit #x0030 #x0039
  bs-range-loop char-set:hex-digit #x0041 #x0046
  bs-range-loop char-set:hex-digit #x0061 #x0066

  set-bitset! char-set:blank #x0009

  bs-range-loop char-set:ascii #x0000 #x007f

  eprintf "printing after %ss\n" SECONDS

  printf "%s\n\n" "#*

These bitsets are automatically generated from Unicode source files.

*#
  "
  for-each (function (def) {
	      printf "\n; %s\n%-20s := #n\n" (pht def) (ph def)
  }) char-sets

  printf "\n; %s\n%-20s := #n\n" "Simple uppercase mapping (single character result)" "char-set:simple-upper-case-map"

  printf "\n; %s\n%-20s := #n\n" "Simple lowercase mapping (single character result)" "char-set:simple-lower-case-map"

  printf "%s\n" "

if (memq 'ascii *subfeatures*) {
  "

  define (printer cs val) {
    def := assq cs char-sets
    if def {
      printf "\n  ; %s\n  %-20s := %s\n" (pht def) (ph def) val
    }
  }

  printer 'char-set:lower-case ascii-char-set:lower-case
  printer 'char-set:upper-case ascii-char-set:upper-case
  printer 'char-set:title-case ascii-char-set:title-case
  printer 'char-set:letter ascii-char-set:letter
  printer 'char-set:digit ascii-char-set:digit
  printer 'char-set:letter+digit ascii-char-set:letter+digit
  printer 'char-set:graphic ascii-char-set:graphic
  printer 'char-set:printing ascii-char-set:printing
  printer 'char-set:whitespace ascii-char-set:whitespace
  printer 'char-set:iso-control ascii-char-set:iso-control
  printer 'char-set:punctuation ascii-char-set:punctuation
  printer 'char-set:symbol ascii-char-set:symbol
  printer 'char-set:hex-digit ascii-char-set:hex-digit
  printer 'char-set:blank ascii-char-set:blank
  printer 'char-set:ascii ascii-char-set:ascii
  printer 'char-set:empty ascii-char-set:empty
  printer 'char-set:full ascii-char-set:full
  printer 'char-set:nonl ascii-char-set:nonl
  printer 'char-set:word-constituent ascii-char-set:word-constituent
  printer '%char-set:letter ascii-char-set:letter
  printer '%char-set:lower-case ascii-char-set:lower-case
  printer '%char-set:upper-case ascii-char-set:upper-case
  printer '%char-set:digit ascii-char-set:digit
  printer '%char-set:letter+digit ascii-char-set:letter+digit
  printer '%char-set:punctuation ascii-char-set:punctuation
  printer '%char-set:symbol ascii-char-set:symbol
  printer '%char-set:graphic ascii-char-set:graphic
  printer '%char-set:whitespace ascii-char-set:whitespace
  printer '%char-set:printing ascii-char-set:printing
  printer '%char-set:iso-control ascii-char-set:iso-control

  printf "\n  ; %s\n  %-20s = %s\n" "Simple uppercase mapping (single character result)" "char-set:simple-upper-case-map" ascii-char-set:simple-upper-case-map

  printf "\n  ; %s\n  %-20s = %s\n" "Simple lowercase mapping (single character result)" "char-set:simple-lower-case-map" ascii-char-set:simple-lower-case-map

  printf "%s\n" "

} {

"

  printer 'char-set:lower-case char-set:lower-case
  printer 'char-set:upper-case char-set:upper-case
  printer 'char-set:title-case char-set:title-case
  printer 'char-set:letter char-set:letter
  printer 'char-set:digit char-set:digit
  printer 'char-set:letter+digit char-set:letter+digit
  printer 'char-set:graphic char-set:graphic
  printer 'char-set:printing char-set:printing
  printer 'char-set:whitespace char-set:whitespace
  printer 'char-set:iso-control char-set:iso-control
  printer 'char-set:punctuation char-set:punctuation
  printer 'char-set:symbol char-set:symbol
  printer 'char-set:hex-digit char-set:hex-digit
  printer 'char-set:blank char-set:blank
  printer 'char-set:ascii char-set:ascii
  printer 'char-set:empty char-set:empty
  printer 'char-set:full char-set:full
  printer 'char-set:nonl char-set:nonl
  printer 'char-set:word-constituent char-set:word-constituent
  printer '%char-set:letter (bitset-and char-set:ascii char-set:letter)
  printer '%char-set:lower-case (bitset-and char-set:ascii char-set:lower-case)
  printer '%char-set:upper-case (bitset-and char-set:ascii char-set:upper-case)
  printer '%char-set:digit (bitset-and char-set:ascii char-set:digit)
  printer '%char-set:letter+digit (bitset-and char-set:ascii char-set:letter+digit)
  printer '%char-set:punctuation (bitset-and char-set:ascii char-set:punctuation)
  printer '%char-set:symbol (bitset-and char-set:ascii char-set:symbol)
  printer '%char-set:graphic (bitset-and char-set:ascii char-set:graphic)
  printer '%char-set:whitespace (bitset-and char-set:ascii char-set:whitespace)
  printer '%char-set:printing (bitset-and char-set:ascii char-set:printing)
  printer '%char-set:iso-control (bitset-and char-set:ascii char-set:iso-control)

  printf "\n  ; %s\n  %-20s = %s\n" "Simple uppercase mapping (single character result)" "char-set:simple-upper-case-map" char-set:simple-upper-case-map

  printf "\n  ; %s\n  %-20s = %s\n" "Simple lowercase mapping (single character result)" "char-set:simple-lower-case-map" char-set:simple-lower-case-map

  printf "%s\n" "

}

"

}

provide unicode
