;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; test.idio
;;

;; largely ported from
;;
;; Scheme 9 from Empty Space
;; By Nils M Holm <nmh@t3x.org>, 2007,2008,2009

require init

testfile := "__testfile__"

if (file-exists? testfile) {
  delete-file testfile
}
    ;; (error (append-string "Please delete the file \""
    ;;                       testfile
    ;;                       "\" before running this test.")))

Errors := 0
Tests := 0

define (void) (if #f #f)

define (seq) {
  n := 1

  function () {
    x := n
    set! n (1 + n)
    x
  }
}

define (fail expr result expected) {
  set! Errors (1 + Errors)
  display* "Error #" Errors
  display* "test #" Tests " failed: " expr
  display* "got result:  " result
  display* "expected:    " expected
}

define (test3 expr result expected) {
  set! Tests (1 + Tests)
  ;edisplay* "test #" Tests ":" expr "=> (equal? " result expected " )"
  if (not (equal? result expected)) {
    fail expr result expected
  }
}

define-template (test form result) {
  #T{ test3 '$form $form $result }
}

define-template (test/error form result c-msg) {
  #T{
    with-condition-handler ^idio-error (function (c) {
					  test c.message $c-msg
    }) {
      test3 '$form $form $result
    }
  }
}

define (Tests? n) {
  if (not (eqv? Tests n)) {
    printf "#Tests %s != %s\n" Tests n
    Errors = Errors + 1
  }
}

;; put the tests dirs on IDIOLIB
testdir := #n

map (function (d) {
       t-p := join-string "/" (reverse (pt (reverse (split-string d "/"))))
       t-d := append-string "/" t-p "/tests"
       r-e := append-string t-d "/test-operator.idio"
       if (file-exists? r-e) {
	 testdir = t-d
       }
}) (split-string IDIOLIB ":")

if (null? testdir) {
  edisplay* "Cannot find 'tests' subdir on IDIOLIB" IDIOLIB
} {
  IDIOLIB = append-string IDIOLIB ":" testdir
}

printf "[%s/%d] %3ds test.idio using IDIOLIB=%s\n" (getpid) PID SECONDS IDIOLIB

;; put the testing utilities on the PATH
OPATH := PATH
PWD-last := ph (reverse (split-string PWD "/"))
PATH = append-string PATH ":" (append-string PWD "/" (if (equal? PWD-last "src") ".." ".") "/utils/bin")

;; at least one test creates a local file then tries to "load" it --
;; so we need PWD on IDIOLIB
OIDIOLIB := IDIOLIB
IDIOLIB = append-string IDIOLIB ":" PWD

;; running tests under Jenkins means we inherit the agent's max open
;; files (eg. 1048576) which means our file descriptor reaping tests
;; blow up.

;; we'll also use a variable, nofiles_lim, that other people --
;; notably the NOFILES test in test-s9.idio -- can use to provoke some
;; effects

nofiles_lim := 256
C_nofiles_lim := C/integer-> nofiles_lim
rl := libc/getrlimit libc/RLIMIT_NOFILE
if (C/> rl.rlim_cur C_nofiles_lim) {
  rl.rlim_cur = C_nofiles_lim
  libc/setrlimit libc/RLIMIT_NOFILE rl
}

test-load := {
  n := 0

  function (filename) {
    if (not (string? filename)) (error 'load "not a string" filename)

    printf "[%s/%d] %3ds %s\n" (getpid) PID SECONDS filename
    load filename
  }
}


test-load "test-read-error.idio"
test-load "test-read-coverage.idio"
test-load "test-evaluation-error.idio"
test-load "test-expander-error.idio"

time test-load "test-s9-test.idio"
test-load "test-unicode.idio"
test-load "test-operator.idio"
test-load "test-closure.idio"
test-load "test-keyword.idio"
test-load "test-template.idio"
test-load "test-string.idio"
test-load "test-string-error.idio"
test-load "test-array.idio"
test-load "test-hash.idio"
test-load "test-file-handle.idio"
test-load "test-string-handle.idio"
test-load "test-handle.idio"
test-load "test-struct.idio"
test-load "test-condition.idio"
test-load "test-dynamic.idio"
test-load "test-computed.idio"
test-load "test-call-cc.idio"
test-load "test-env.idio"
test-load "test-path.idio"
test-load "test-command.idio"
test-load "test-libc-wrap.idio"

test-load "test-load-handle.idio"
test-load "test-trap.idio"
test-load "test-bitset.idio"
test-load "test-utf-8.idio"
test-load "test-format.idio"

test-load "test-SRFI-89.idio"
test-load "test-SRFI-115.idio"
test-load "test-posix-regex.idio"

test-load "test-issues.idio"

;; test that we've seen as many tests as we should have.  How many is
;; that?  Erm, they've not been counted and are dynamic in number so
;; test we've seen at least as many as the largest number we've
;; seen.  Wait, some tests are OS-specific.  Drat!
Tests? 3722

if (file-exists? testfile) (delete-file testfile)

printf "[%s/%d] %3ds test.idio\n" (getpid) PID SECONDS
printf "# src-props %d\n" (length (hash-keys %idio-src-properties))
if (zero? Errors) (printf "All %d tests passed!\n" Tests) \
   {
     printf "%d error%s in %d tests.\n" Errors (if (Errors gt 1) "s" "") Tests
     exit 1
   }

IDIOLIB = OIDIOLIB
PATH = OPATH

